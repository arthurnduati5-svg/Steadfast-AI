module.exports = {

"[project]/node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnaryMinus": (()=>createUnaryMinus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
var name = 'unaryMinus';
var dependencies = [
    'typed'
];
var createUnaryMinus = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5)      // returns -3.5
   *    math.unaryMinus(-4.2)     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unaryMinusNumber"],
        'Complex | BigNumber | Fraction': (x)=>x.neg(),
        bigint: (x)=>-x,
        Unit: typed.referToSelf((self)=>(x)=>{
                var res = x.clone();
                res.value = typed.find(self, res.valueType())(x.value);
                return res;
            }),
        // deep map collection, skip zeros since unaryMinus(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUnaryPlus": (()=>createUnaryPlus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
;
;
;
;
var name = 'unaryPlus';
var dependencies = [
    'typed',
    'config',
    'numeric'
];
var createUnaryPlus = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, numeric } = _ref;
    /**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5)      // returns 3.5
   *    math.unaryPlus(1)     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {number | BigNumber | bigint | Fraction | string | Complex | Unit | Array | Matrix} x
   *            Input value
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unaryPlusNumber"],
        Complex: function Complex(x) {
            return x; // complex numbers are immutable
        },
        BigNumber: function BigNumber(x) {
            return x; // bignumbers are immutable
        },
        bigint: function bigint(x) {
            return x;
        },
        Fraction: function Fraction(x) {
            return x; // fractions are immutable
        },
        Unit: function Unit(x) {
            return x.clone();
        },
        // deep map collection, skip zeros since unaryPlus(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true)),
        boolean: function boolean(x) {
            return numeric(x ? 1 : 0, config.number);
        },
        string: function string(x) {
            return numeric(x, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["safeNumberType"])(x, config));
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/abs.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAbs": (()=>createAbs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
var name = 'abs';
var dependencies = [
    'typed'
];
var createAbs = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5)                // returns number 3.5
   *    math.abs(-4.2)               // returns number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit} x
   *            A number or matrix for which to get the absolute value
   * @return {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit}
   *            Absolute value of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["absNumber"],
        'Complex | BigNumber | Fraction | Unit': (x)=>x.abs(),
        bigint: (x)=>x < 0n ? -x : x,
        // deep map collection, skip zeros since abs(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAddScalar": (()=>createAddScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'addScalar';
var dependencies = [
    'typed'
];
var createAddScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Add two scalar values, `x + y`.
   * This function is meant for internal use: it is used by the public function
   * `add`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value to add
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to add
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Sum of `x` and `y`
   * @private
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.add(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.plus(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x + y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.add(y);
        },
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>{
                if (x.value === null || x.value === undefined) {
                    throw new Error('Parameter x contains a unit with undefined value');
                }
                if (y.value === null || y.value === undefined) {
                    throw new Error('Parameter y contains a unit with undefined value');
                }
                if (!x.equalBase(y)) throw new Error('Units do not match');
                var res = x.clone();
                res.value = typed.find(self, [
                    res.valueType(),
                    y.valueType()
                ])(res.value, y.value);
                res.fixPrefix = false;
                return res;
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSubtractScalar": (()=>createSubtractScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'subtractScalar';
var dependencies = [
    'typed'
];
var createSubtractScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Subtract two scalar values, `x - y`.
   * This function is meant for internal use: it is used by the public function
   * `subtract`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to be subtracted from `x`
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Difference of `x` and `y`
   * @private
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["subtractNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.sub(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.minus(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x - y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.sub(y);
        },
        'Unit, Unit': typed.referToSelf((self)=>(x, y)=>{
                if (x.value === null || x.value === undefined) {
                    throw new Error('Parameter x contains a unit with undefined value');
                }
                if (y.value === null || y.value === undefined) {
                    throw new Error('Parameter y contains a unit with undefined value');
                }
                if (!x.equalBase(y)) throw new Error('Units do not match');
                var res = x.clone();
                res.value = typed.find(self, [
                    res.valueType(),
                    y.valueType()
                ])(res.value, y.value);
                res.fixPrefix = false;
                return res;
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCbrt": (()=>createCbrt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
var name = 'cbrt';
var dependencies = [
    'config',
    'typed',
    'isNegative',
    'unaryMinus',
    'matrix',
    'Complex',
    'BigNumber',
    'Fraction'
];
var createCbrt = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, typed, isNegative, unaryMinus, matrix, Complex, BigNumber, Fraction } = _ref;
    /**
   * Calculate the cubic root of a value.
   *
   * To avoid confusion with the matrix cube root, this function does not
   * apply to matrices. For a matrix, to take the cube root elementwise,
   * see the examples.
   *
   * Syntax:
   *
   *    math.cbrt(x)
   *    math.cbrt(x, allRoots)
   *
   * Examples:
   *
   *    math.cbrt(27)                  // returns 3
   *    math.cube(3)                   // returns 27
   *    math.cbrt(-64)                 // returns -4
   *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m
   *    math.map([27, 64, 125], x => math.cbrt(x))       // returns [3, 4, 5]
   *
   *    const x = math.complex('8i')
   *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i
   *    math.cbrt(x, true)             // returns Matrix [
   *                                    //    1.7320508075689 + i
   *                                    //   -1.7320508075689 + i
   *                                    //   -2i
   *                                    // ]
   *
   * See also:
   *
   *    square, sqrt, cube
   *
   * @param {number | BigNumber | Complex | Unit} x
   *            Value for which to calculate the cubic root.
   * @param {boolean} [allRoots]  Optional, false by default. Only applicable
   *            when `x` is a number or complex number. If true, all complex
   *            roots are returned, if false (default) the principal root is
   *            returned.
   * @return {number | BigNumber | Complex | Unit}
   *            Returns the cubic root of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cbrtNumber"],
        // note: signature 'number, boolean' is also supported,
        //       created by typed as it knows how to convert number to Complex
        Complex: _cbrtComplex,
        'Complex, boolean': _cbrtComplex,
        BigNumber: function BigNumber(x) {
            return x.cbrt();
        },
        Unit: _cbrtUnit
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the cubic root for a complex number
   * @param {Complex} x
   * @param {boolean} [allRoots]   If true, the function will return an array
   *                               with all three roots. If false or undefined,
   *                               the principal root is returned.
   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
   * @private
   */ function _cbrtComplex(x, allRoots) {
        // https://www.wikiwand.com/en/Cube_root#/Complex_numbers
        var arg3 = x.arg() / 3;
        var abs = x.abs();
        // principal root:
        var principal = new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cbrtNumber"])(abs), 0).mul(new Complex(0, arg3).exp());
        if (allRoots) {
            var all = [
                principal,
                new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cbrtNumber"])(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()),
                new Complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cbrtNumber"])(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())
            ];
            return config.matrix === 'Array' ? all : matrix(all);
        } else {
            return principal;
        }
    }
    /**
   * Calculate the cubic root for a Unit
   * @param {Unit} x
   * @return {Unit} Returns the cubic root of x
   * @private
   */ function _cbrtUnit(x) {
        if (x.value && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isComplex"])(x.value)) {
            var result = x.clone();
            result.value = 1.0;
            result = result.pow(1.0 / 3); // Compute the units
            result.value = _cbrtComplex(x.value); // Compute the value
            return result;
        } else {
            var negate = isNegative(x.value);
            if (negate) {
                x.value = unaryMinus(x.value);
            }
            // TODO: create a helper function for this
            var third;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isBigNumber"])(x.value)) {
                third = new BigNumber(1).div(3);
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFraction"])(x.value)) {
                third = new Fraction(1, 3);
            } else {
                third = 1 / 3;
            }
            var _result = x.pow(third);
            if (negate) {
                _result.value = unaryMinus(_result.value);
            }
            return _result;
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/ceil.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCeil": (()=>createCeil),
    "createCeilNumber": (()=>createCeilNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/decimal.js/decimal.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'ceil';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix'
];
var bigTen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"](10);
var createCeilNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config',
    'round'
], (_ref)=>{
    var { typed, config, round } = _ref;
    function _ceilNumber(x) {
        // See ./floor.js _floorNumber for rationale here
        var c = Math.ceil(x);
        var r = round(x);
        if (c === r) return c;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, r, config.relTol, config.absTol) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, c, config.relTol, config.absTol)) {
            return r;
        }
        return c;
    }
    return typed(name, {
        number: _ceilNumber,
        'number, number': function number_number(x, n) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(n)) {
                throw new RangeError('number of decimals in function ceil must be an integer');
            }
            if (n < 0 || n > 15) {
                throw new RangeError('number of decimals in ceil number must be in range 0-15');
            }
            var shift = 10 ** n;
            return _ceilNumber(x * shift) / shift;
        }
    });
});
var createCeil = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
    var { typed, config, round, matrix, equalScalar, zeros, DenseMatrix } = _ref2;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var ceilNumber = createCeilNumber({
        typed,
        config,
        round
    });
    function _bigCeil(x) {
        // see ./floor.js _floorNumber for rationale
        var bne = (a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(a, b, config.relTol, config.absTol);
        var c = x.ceil();
        var r = round(x);
        if (c.eq(r)) return c;
        if (bne(x, r) && !bne(x, c)) return r;
        return c;
    }
    /**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *    math.ceil(x, n)
   *    math.ceil(unit, valuelessUnit)
   *    math.ceil(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.ceil(3.2)               // returns number 4
   *    math.ceil(3.8)               // returns number 4
   *    math.ceil(-4.2)              // returns number -4
   *    math.ceil(-4.7)              // returns number -4
   *
   *    math.ceil(3.212, 2)          // returns number 3.22
   *    math.ceil(3.288, 2)          // returns number 3.29
   *    math.ceil(-4.212, 2)         // returns number -4.21
   *    math.ceil(-4.782, 2)         // returns number -4.78
   *
   *    const c = math.complex(3.24, -2.71)
   *    math.ceil(c)                 // returns Complex 4 - 2i
   *    math.ceil(c, 1)              // returns Complex 3.3 - 2.7i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.ceil(unit, 1, cm)      // returns Unit 3.3 cm
   *    math.ceil(unit, 1, mm)      // returns Unit 32.5 mm
   *
   *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]
   *    math.ceil([3.21, 3.82, -4.71], 1)  // returns Array [3.3, 3.9, -4.7]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed('ceil', {
        number: ceilNumber.signatures.number,
        'number,number': ceilNumber.signatures['number,number'],
        Complex: function Complex(x) {
            return x.ceil();
        },
        'Complex, number': function Complex_number(x, n) {
            return x.ceil(n);
        },
        'Complex, BigNumber': function Complex_BigNumber(x, n) {
            return x.ceil(n.toNumber());
        },
        BigNumber: _bigCeil,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {
            var shift = bigTen.pow(n);
            return _bigCeil(x.mul(shift)).div(shift);
        },
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.ceil();
        },
        'Fraction, number': function Fraction_number(x, n) {
            return x.ceil(n);
        },
        'Fraction, BigNumber': function Fraction_BigNumber(x, n) {
            return x.ceil(n.toNumber());
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'Array, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (i)=>self(i, n), true);
            }),
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | Complex | Fraction | BigNumber, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }),
        'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf((self)=>(x, y)=>{
                if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
                if (y.storage() === 'dense') {
                    return matAlgo14xDs(y, x, self, true);
                }
                return matAlgo12xSfs(y, x, self, true);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/cube.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createCube": (()=>createCube)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'cube';
var dependencies = [
    'typed'
];
var createCube = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the cube of a value, `x * x * x`.
   * To avoid confusion with `pow(M,3)`, this function does not apply to matrices.
   * If you wish to cube every entry of a matrix, see the examples.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2)            // returns number 8
   *    math.pow(2, 3)          // returns number 8
   *    math.cube(4)            // returns number 64
   *    4 * 4 * 4               // returns number 64
   *
   *    math.map([1, 2, 3, 4], math.cube) // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow, cbrt
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x  Number for which to calculate the cube
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit} Cube of x
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cubeNumber"],
        Complex: function Complex(x) {
            return x.mul(x).mul(x); // Is faster than pow(x, 3)
        },
        BigNumber: function BigNumber(x) {
            return x.times(x).times(x);
        },
        bigint: function bigint(x) {
            return x * x * x;
        },
        Fraction: function Fraction(x) {
            return x.pow(3); // Is faster than mul()mul()mul()
        },
        Unit: function Unit(x) {
            return x.pow(3);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/exp.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createExp": (()=>createExp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'exp';
var dependencies = [
    'typed'
];
var createExp = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Calculate the exponential of a value.
   * For matrices, if you want the matrix exponential of square matrix, use
   * the `expm` function; if you want to take the exponential of each element,
   * see the examples.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2)                  // returns number 7.3890560989306495
   *    math.pow(math.e, 2)          // returns number 7.3890560989306495
   *    math.log(math.exp(2))        // returns number 2
   *
   *    math.map([1, 2, 3], math.exp)
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    expm1, expm, log, pow
   *
   * @param {number | BigNumber | Complex} x  A number to exponentiate
   * @return {number | BigNumber | Complex} Exponential of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["expNumber"],
        Complex: function Complex(x) {
            return x.exp();
        },
        BigNumber: function BigNumber(x) {
            return x.exp();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/expm1.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createExpm1": (()=>createExpm1)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'expm1';
var dependencies = [
    'typed',
    'Complex'
];
var createExpm1 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, Complex: _Complex } = _ref;
    /**
   * Calculate the value of subtracting 1 from the exponential value.
   * This function is more accurate than `math.exp(x)-1` when `x` is near 0
   * To avoid ambiguity with the matrix exponential `expm`, this function
   * does not operate on matrices; if you wish to apply it elementwise, see
   * the examples.
   *
   * Syntax:
   *
   *    math.expm1(x)
   *
   * Examples:
   *
   *    math.expm1(2)                      // returns number 6.38905609893065
   *    math.pow(math.e, 2) - 1            // returns number 6.3890560989306495
   *    math.expm1(1e-8)                   // returns number 1.0000000050000001e-8
   *    math.exp(1e-8) - 1                 // returns number 9.9999999392253e-9
   *    math.log(math.expm1(2) + 1)        // returns number 2
   *
   *    math.map([1, 2, 3], math.expm1)
   *    // returns Array [
   *    //   1.718281828459045,
   *    //   6.3890560989306495,
   *    //   19.085536923187668
   *    // ]
   *
   * See also:
   *
   *    exp, expm, log, pow
   *
   * @param {number | BigNumber | Complex} x  The number to exponentiate
   * @return {number | BigNumber | Complex} Exponential of `x`, minus one
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["expm1Number"],
        Complex: function Complex(x) {
            var r = Math.exp(x.re);
            return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
        },
        BigNumber: function BigNumber(x) {
            return x.exp().minus(1);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/fix.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFix": (()=>createFix),
    "createFixNumber": (()=>createFixNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-rsc] (ecmascript)");
;
;
;
;
var name = 'fix';
var dependencies = [
    'typed',
    'Complex',
    'matrix',
    'ceil',
    'floor',
    'equalScalar',
    'zeros',
    'DenseMatrix'
];
var createFixNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'ceil',
    'floor'
], (_ref)=>{
    var { typed, ceil, floor } = _ref;
    return typed(name, {
        number: function number(x) {
            return x > 0 ? floor(x) : ceil(x);
        },
        'number, number': function number_number(x, n) {
            return x > 0 ? floor(x, n) : ceil(x, n);
        }
    });
});
var createFix = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
    var { typed, Complex: _Complex, matrix, ceil, floor, equalScalar, zeros, DenseMatrix } = _ref2;
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var fixNumber = createFixNumber({
        typed,
        ceil,
        floor
    });
    /**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *    math.fix(x,n)
   *    math.fix(unit, valuelessUnit)
   *    math.fix(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.fix(3.2)                // returns number 3
   *    math.fix(3.8)                // returns number 3
   *    math.fix(-4.2)               // returns number -4
   *    math.fix(-4.7)               // returns number -4
   *
   *    math.fix(3.12, 1)                // returns number 3.1
   *    math.fix(3.18, 1)                // returns number 3.1
   *    math.fix(-4.12, 1)               // returns number -4.1
   *    math.fix(-4.17, 1)               // returns number -4.1
   *
   *    const c = math.complex(3.22, -2.78)
   *    math.fix(c)                  // returns Complex 3 - 2i
   *    math.fix(c, 1)               // returns Complex 3.2 -2.7i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.fix(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.fix(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.fix([3.2, 3.8, -4.7])      // returns Array [3, 3, -4]
   *    math.fix([3.2, 3.8, -4.7], 1)   // returns Array [3.2, 3.8, -4.7]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed('fix', {
        number: fixNumber.signatures.number,
        'number, number | BigNumber': fixNumber.signatures['number,number'],
        Complex: function Complex(x) {
            return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
        },
        'Complex, number': function Complex_number(x, n) {
            return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
        },
        'Complex, BigNumber': function Complex_BigNumber(x, bn) {
            var n = bn.toNumber();
            return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));
        },
        BigNumber: function BigNumber(x) {
            return x.isNegative() ? ceil(x) : floor(x);
        },
        'BigNumber, number | BigNumber': function BigNumber_number__BigNumber(x, n) {
            return x.isNegative() ? ceil(x, n) : floor(x, n);
        },
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.s < 0n ? x.ceil() : x.floor();
        },
        'Fraction, number | BigNumber': function Fraction_number__BigNumber(x, n) {
            return x.s < 0n ? ceil(x, n) : floor(x, n);
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since fix(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since fix(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'Array | Matrix, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // deep map collection, skip zeros since fix(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (i)=>self(i, n), true);
            }),
        'number | Complex | Fraction | BigNumber, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }),
        'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf((self)=>(x, y)=>{
                if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
                if (y.storage() === 'dense') {
                    return matAlgo14xDs(y, x, self, true);
                }
                return matAlgo12xSfs(y, x, self, true);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/floor.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createFloor": (()=>createFloor),
    "createFloorNumber": (()=>createFloorNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/decimal.js/decimal.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'floor';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix'
];
var bigTen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$decimal$2e$js$2f$decimal$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"](10);
var createFloorNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed',
    'config',
    'round'
], (_ref)=>{
    var { typed, config, round } = _ref;
    function _floorNumber(x) {
        // First, if the floor and the round are identical we can be
        // quite comfortable that is the best answer:
        var f = Math.floor(x);
        var r = round(x);
        if (f === r) return f;
        // OK, they are different. If x is truly distinct from f but
        // appears indistinguishable from r, presume it really is just
        // the integer r with rounding/computation error, and return that
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, r, config.relTol, config.absTol) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, f, config.relTol, config.absTol)) {
            return r;
        }
        // Otherwise (x distinct from both r and f, or indistinguishable from
        // both r and f) may as well just return f, as that's the best
        // candidate we can discern:
        return f;
    }
    return typed(name, {
        number: _floorNumber,
        'number, number': function number_number(x, n) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(n)) {
                throw new RangeError('number of decimals in function floor must be an integer');
            }
            if (n < 0 || n > 15) {
                throw new RangeError('number of decimals in floor number must be in range 0 - 15');
            }
            var shift = 10 ** n;
            return _floorNumber(x * shift) / shift;
        }
    });
});
var createFloor = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref2)=>{
    var { typed, config, round, matrix, equalScalar, zeros, DenseMatrix } = _ref2;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    var floorNumber = createFloorNumber({
        typed,
        config,
        round
    });
    function _bigFloor(x) {
        // see _floorNumber above for rationale
        var bne = (a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(a, b, config.relTol, config.absTol);
        var f = x.floor();
        var r = round(x);
        if (f.eq(r)) return f;
        if (bne(x, r) && !bne(x, f)) return r;
        return f;
    }
    /**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *    math.floor(x, n)
   *    math.floor(unit, valuelessUnit)
   *    math.floor(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.floor(3.2)              // returns number 3
   *    math.floor(3.8)              // returns number 3
   *    math.floor(-4.2)             // returns number -5
   *    math.floor(-4.7)             // returns number -5
   *
   *    math.floor(3.212, 2)          // returns number 3.21
   *    math.floor(3.288, 2)          // returns number 3.28
   *    math.floor(-4.212, 2)         // returns number -4.22
   *    math.floor(-4.782, 2)         // returns number -4.79
   *
   *    const c = math.complex(3.24, -2.71)
   *    math.floor(c)                 // returns Complex 3 - 3i
   *    math.floor(c, 1)              // returns Complex 3.2 -2.8i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.floor(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.floor(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.floor([3.2, 3.8, -4.7])       // returns Array [3, 3, -5]
   *    math.floor([3.21, 3.82, -4.71], 1)  // returns Array [3.2, 3.8, -4.8]
   *
   *    math.floor(math.tau, [2, 3])  // returns Array [6.28, 6.283]
   *
   *    // Note that floor(array, array) currently not implemented.
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed('floor', {
        number: floorNumber.signatures.number,
        'number,number': floorNumber.signatures['number,number'],
        Complex: function Complex(x) {
            return x.floor();
        },
        'Complex, number': function Complex_number(x, n) {
            return x.floor(n);
        },
        'Complex, BigNumber': function Complex_BigNumber(x, n) {
            return x.floor(n.toNumber());
        },
        BigNumber: _bigFloor,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {
            var shift = bigTen.pow(n);
            return _bigFloor(x.mul(shift)).div(shift);
        },
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.floor();
        },
        'Fraction, number': function Fraction_number(x, n) {
            return x.floor(n);
        },
        'Fraction, BigNumber': function Fraction_BigNumber(x, n) {
            return x.floor(n.toNumber());
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since floor(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since floor(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'Array, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // deep map collection, skip zeros since ceil(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (i)=>self(i, n), true);
            }),
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo11xS0s(x, y, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, y)=>{
                return matAlgo14xDs(x, y, self, false);
            }),
        'number | Complex | Fraction | BigNumber, Array': typed.referToSelf((self)=>(x, y)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(y), x, self, true).valueOf();
            }),
        'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf((self)=>(x, y)=>{
                if (equalScalar(x, 0)) return zeros(y.size(), y.storage());
                if (y.storage() === 'dense') {
                    return matAlgo14xDs(y, x, self, true);
                }
                return matAlgo12xSfs(y, x, self, true);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/mod.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMod": (()=>createMod)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$floor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/arithmetic/floor.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'mod';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'DenseMatrix',
    'concat'
];
var createMod = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, round, matrix, equalScalar, zeros, DenseMatrix, concat } = _ref;
    var floor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$floor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createFloor"])({
        typed,
        config,
        round,
        matrix,
        equalScalar,
        zeros,
        DenseMatrix
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo05xSfSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo05xSfSf"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See https://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3)                // returns 2
   *    math.mod(11, 2)               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0
   *    }
   *
   *    isOdd(2)                      // returns false
   *    isOdd(3)                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | bigint | Fraction | Array | Matrix} x Dividend
   * @param  {number | BigNumber | bigint | Fraction | Array | Matrix} y Divisor
   * @return {number | BigNumber | bigint | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */ return typed(name, {
        'number, number': _modNumber,
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return y.isZero() ? x : x.sub(y.mul(floor(x.div(y))));
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            if (y === 0n) {
                return x;
            }
            if (x < 0) {
                var m = x % y;
                return m === 0n ? m : m + y;
            }
            return x % y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return y.equals(0) ? x : x.sub(y.mul(floor(x.div(y))));
        }
    }, matrixAlgorithmSuite({
        SS: matAlgo05xSfSf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
    "TURBOPACK unreachable";
    /**
  * Calculate the modulus of two numbers
  * @param {number} x
  * @param {number} y
  * @returns {number} res
  * @private
  */ function _modNumber(x, y) {
        // We don't use JavaScript's % operator here as this doesn't work
        // correctly for x < 0 and x === 0
        // see https://en.wikipedia.org/wiki/Modulo_operation
        // We use mathjs floor to handle errors associated with
        // precision float approximation
        return y === 0 ? x : x - y * floor(x / y);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/gcd.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createGcd": (()=>createGcd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$mod$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/arithmetic/mod.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$ArgumentsError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/error/ArgumentsError.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
var name = 'gcd';
var dependencies = [
    'typed',
    'config',
    'round',
    'matrix',
    'equalScalar',
    'zeros',
    'BigNumber',
    'DenseMatrix',
    'concat'
];
var gcdTypes = 'number | BigNumber | Fraction | Matrix | Array';
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array) {
    return !array.some((element)=>Array.isArray(element));
}
var createGcd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, config, round, equalScalar, zeros, BigNumber, DenseMatrix, concat } = _ref;
    var mod = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$arithmetic$2f$mod$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMod"])({
        typed,
        config,
        round,
        matrix,
        equalScalar,
        zeros,
        DenseMatrix,
        concat
    });
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo04xSidSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo04xSidSid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12)              // returns 4
   *    math.gcd(-4, 6)              // returns 2
   *    math.gcd(25, 15, -10)        // returns 5
   *
   *    math.gcd([8, -4], [12, 6])   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
   */ return typed(name, {
        'number, number': _gcdNumber,
        'BigNumber, BigNumber': _gcdBigNumber,
        'Fraction, Fraction': (x, y)=>x.gcd(y)
    }, matrixAlgorithmSuite({
        SS: matAlgo04xSidSid,
        DS: matAlgo01xDSid,
        Ss: matAlgo10xSids
    }), {
        [gcdManyTypesSignature]: typed.referToSelf((self)=>(a, b, args)=>{
                var res = self(a, b);
                for(var i = 0; i < args.length; i++){
                    res = self(res, args[i]);
                }
                return res;
            }),
        Array: typed.referToSelf((self)=>(array)=>{
                if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
                    return self(...array[0]);
                }
                if (is1d(array)) {
                    return self(...array);
                }
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$error$2f$ArgumentsError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ArgumentsError"]('gcd() supports only 1d matrices!');
            }),
        Matrix: typed.referToSelf((self)=>(matrix)=>{
                return self(matrix.toArray());
            })
    });
    "TURBOPACK unreachable";
    /**
  * Calculate gcd for numbers
  * @param {number} a
  * @param {number} b
  * @returns {number} Returns the greatest common denominator of a and b
  * @private
  */ function _gcdNumber(a, b) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(a) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(b)) {
            throw new Error('Parameters in function gcd must be integer numbers');
        }
        // https://en.wikipedia.org/wiki/Euclidean_algorithm
        var r;
        while(b !== 0){
            r = mod(a, b);
            a = b;
            b = r;
        }
        return a < 0 ? -a : a;
    }
    /**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denominator of a and b
   * @private
   */ function _gcdBigNumber(a, b) {
        if (!a.isInt() || !b.isInt()) {
            throw new Error('Parameters in function gcd must be integer numbers');
        }
        // https://en.wikipedia.org/wiki/Euclidean_algorithm
        var zero = new BigNumber(0);
        while(!b.isZero()){
            var r = mod(a, b);
            a = b;
            b = r;
        }
        return a.lt(zero) ? a.neg() : a;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/lcm.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLcm": (()=>createLcm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
var name = 'lcm';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'concat'
];
var createLcm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo06xS0S0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo06xS0S0"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var lcmTypes = 'number | BigNumber | Fraction | Matrix | Array';
    var lcmManySignature = {};
    lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed.referToSelf((self)=>(a, b, args)=>{
            var res = self(a, b);
            for(var i = 0; i < args.length; i++){
                res = self(res, args[i]);
            }
            return res;
        });
    /**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6)               // returns 12
   *    math.lcm(6, 21)              // returns 42
   *    math.lcm(6, 21, 5)           // returns 210
   *
   *    math.lcm([4, 6], [6, 21])    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Array | Matrix}                           The least common multiple
   */ return typed(name, {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["lcmNumber"],
        'BigNumber, BigNumber': _lcmBigNumber,
        'Fraction, Fraction': (x, y)=>x.lcm(y)
    }, matrixAlgorithmSuite({
        SS: matAlgo06xS0S0,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
    }), lcmManySignature);
    "TURBOPACK unreachable";
    /**
   * Calculate lcm for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns the least common multiple of a and b
   * @private
   */ function _lcmBigNumber(a, b) {
        if (!a.isInt() || !b.isInt()) {
            throw new Error('Parameters in function lcm must be integer numbers');
        }
        if (a.isZero()) {
            return a;
        }
        if (b.isZero()) {
            return b;
        }
        // https://en.wikipedia.org/wiki/Euclidean_algorithm
        // evaluate lcm here inline to reduce overhead
        var prod = a.times(b);
        while(!b.isZero()){
            var t = b;
            b = a.mod(t);
            a = t;
        }
        return prod.div(a).abs();
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log10.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog10": (()=>createLog10)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
;
;
;
var name = 'log10';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var log16 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["log10Number"])(16);
var createLog10 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001)            // returns -5
   *    math.log10(10000)              // returns 4
   *    math.log(10000) / math.log(10) // returns 4
   *    math.pow(10, 4)                // returns 10000
   *
   * See also:
   *
   *    exp, log, log1p, log2
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */ function complexLog(c) {
        return c.log().div(Math.LN10);
    }
    function complexLogNumber(x) {
        return complexLog(new Complex(x, 0));
    }
    return typed(name, {
        number: function number(x) {
            if (x >= 0 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["log10Number"])(x);
            } else {
                // negative value -> complex value computation
                return complexLogNumber(x);
            }
        },
        bigint: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["promoteLogarithm"])(log16, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["log10Number"], config, complexLogNumber),
        Complex: complexLog,
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.log();
            } else {
                // downgrade to number, return Complex valued result
                return complexLogNumber(x.toNumber());
            }
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log2.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog2": (()=>createLog2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
;
;
;
var name = 'log2';
var dependencies = [
    'typed',
    'config',
    'Complex'
];
var createLog2 = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, Complex } = _ref;
    /**
   * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log2(x)
   *
   * Examples:
   *
   *    math.log2(0.03125)           // returns -5
   *    math.log2(16)                // returns 4
   *    math.log2(16) / math.log2(2) // returns 4
   *    math.pow(2, 4)               // returns 16
   *
   * See also:
   *
   *    exp, log, log1p, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 2-base logarithm of `x`
   */ function complexLog2Number(x) {
        return _log2Complex(new Complex(x, 0));
    }
    return typed(name, {
        number: function number(x) {
            if (x >= 0 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["log2Number"])(x);
            } else {
                // negative value -> complex value computation
                return complexLog2Number(x);
            }
        },
        bigint: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["promoteLogarithm"])(4, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["log2Number"], config, complexLog2Number),
        Complex: _log2Complex,
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.log(2);
            } else {
                // downgrade to number, return Complex valued result
                return complexLog2Number(x.toNumber());
            }
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self))
    });
    "TURBOPACK unreachable";
    /**
   * Calculate log2 for a complex value
   * @param {Complex} x
   * @returns {Complex}
   * @private
   */ function _log2Complex(x) {
        var newX = Math.sqrt(x.re * x.re + x.im * x.im);
        return new Complex(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMultiplyScalar": (()=>createMultiplyScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'multiplyScalar';
var dependencies = [
    'typed'
];
var createMultiplyScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Multiply two scalar values, `x * y`.
   * This function is meant for internal use: it is used by the public function
   * `multiply`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value to multiply
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to multiply
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Multiplication of `x` and `y`
   * @private
   */ return typed('multiplyScalar', {
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["multiplyNumber"],
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.mul(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.times(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x * y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.mul(y);
        },
        'number | Fraction | BigNumber | Complex, Unit': (x, y)=>y.multiply(x),
        'Unit, number | Fraction | BigNumber | Complex | Unit': (x, y)=>x.multiply(y)
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/multiply.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createMultiply": (()=>createMultiply)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-rsc] (ecmascript)");
;
;
;
;
;
var name = 'multiply';
var dependencies = [
    'typed',
    'matrix',
    'addScalar',
    'multiplyScalar',
    'equalScalar',
    'dot'
];
var createMultiply = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, addScalar, multiplyScalar, equalScalar, dot } = _ref;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    function _validateMatrixDimensions(size1, size2) {
        // check left operand dimensions
        switch(size1.length){
            case 1:
                // check size2
                switch(size2.length){
                    case 1:
                        // Vector x Vector
                        if (size1[0] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
                        }
                        break;
                    case 2:
                        // Vector x Matrix
                        if (size1[0] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
                        }
                        break;
                    default:
                        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
                }
                break;
            case 2:
                // check size2
                switch(size2.length){
                    case 1:
                        // Matrix x Vector
                        if (size1[1] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
                        }
                        break;
                    case 2:
                        // Matrix x Matrix
                        if (size1[1] !== size2[0]) {
                            // throw error
                            throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
                        }
                        break;
                    default:
                        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
                }
                break;
            default:
                throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
        }
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (N)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {number}             Scalar value
   */ function _multiplyVectorVector(a, b, n) {
        // check empty vector
        if (n === 0) {
            throw new Error('Cannot multiply two empty vectors');
        }
        return dot(a, b);
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Matrix         (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */ function _multiplyVectorMatrix(a, b) {
        // process storage
        if (b.storage() !== 'dense') {
            throw new Error('Support for SparseMatrix not implemented');
        }
        return _multiplyVectorDenseMatrix(a, b);
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Dense Matrix   (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */ function _multiplyVectorDenseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b dense
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var alength = asize[0];
        var bcolumns = bsize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var c = [];
        // loop matrix columns
        for(var j = 0; j < bcolumns; j++){
            // sum (do not initialize it with zero)
            var sum = mf(adata[0], bdata[0][j]);
            // loop vector
            for(var i = 1; i < alength; i++){
                // multiply & accumulate
                sum = af(sum, mf(adata[i], bdata[i][j]));
            }
            c[j] = sum;
        }
        // return matrix
        return a.createDenseMatrix({
            data: c,
            size: [
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {Matrix}             Dense Vector   (M)
   */ var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
        'DenseMatrix, any': _multiplyDenseMatrixVector,
        'SparseMatrix, any': _multiplySparseMatrixVector
    });
    /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Matrix         (NxC)
   *
   * @return {Matrix}             Matrix         (MxC)
   */ var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
        'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
        'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
        'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
        'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
    });
    /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix  (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             Dense Vector (M)
   */ function _multiplyDenseMatrixVector(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b dense
        var bdata = b._data;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = asize[0];
        var acolumns = asize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var c = [];
        // loop matrix a rows
        for(var i = 0; i < arows; i++){
            // current row
            var row = adata[i];
            // sum (do not initialize it with zero)
            var sum = mf(row[0], bdata[0]);
            // loop matrix a columns
            for(var j = 1; j < acolumns; j++){
                // multiply & accumulate
                sum = af(sum, mf(row[j], bdata[j]));
            }
            c[i] = sum;
        }
        // return matrix
        return a.createDenseMatrix({
            data: c,
            size: [
                arows
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            DenseMatrix    (NxC)
   *
   * @return {Matrix}             DenseMatrix    (MxC)
   */ function _multiplyDenseMatrixDenseMatrix(a, b) {
        // getDataType()
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b dense
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = asize[0];
        var acolumns = asize[1];
        var bcolumns = bsize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var c = [];
        // loop matrix a rows
        for(var i = 0; i < arows; i++){
            // current row
            var row = adata[i];
            // initialize row array
            c[i] = [];
            // loop matrix b columns
            for(var j = 0; j < bcolumns; j++){
                // sum (avoid initializing sum to zero)
                var sum = mf(row[0], bdata[0][j]);
                // loop matrix a columns
                for(var x = 1; x < acolumns; x++){
                    // multiply & accumulate
                    sum = af(sum, mf(row[x], bdata[x][j]));
                }
                c[i][j] = sum;
            }
        }
        // return matrix
        return a.createDenseMatrix({
            data: c,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            SparseMatrix   (NxC)
   *
   * @return {Matrix}             SparseMatrix   (MxC)
   */ function _multiplyDenseMatrixSparseMatrix(a, b) {
        // a dense
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype || a.getDataType();
        // b sparse
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // validate b matrix
        if (!bvalues) {
            throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
        }
        // rows & columns
        var arows = asize[0];
        var bcolumns = bsize[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // equalScalar signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
        }
        // result
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // c matrix
        var c = b.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
        // loop b columns
        for(var jb = 0; jb < bcolumns; jb++){
            // update ptr
            cptr[jb] = cindex.length;
            // indeces in column jb
            var kb0 = bptr[jb];
            var kb1 = bptr[jb + 1];
            // do not process column jb if no data exists
            if (kb1 > kb0) {
                // last row mark processed
                var last = 0;
                // loop a rows
                for(var i = 0; i < arows; i++){
                    // column mark
                    var mark = i + 1;
                    // C[i, jb]
                    var cij = void 0;
                    // values in b column j
                    for(var kb = kb0; kb < kb1; kb++){
                        // row
                        var ib = bindex[kb];
                        // check value has been initialized
                        if (last !== mark) {
                            // first value in column jb
                            cij = mf(adata[i][ib], bvalues[kb]);
                            // update mark
                            last = mark;
                        } else {
                            // accumulate value
                            cij = af(cij, mf(adata[i][ib], bvalues[kb]));
                        }
                    }
                    // check column has been processed and value != 0
                    if (last === mark && !eq(cij, zero)) {
                        // push row & value
                        cindex.push(i);
                        cvalues.push(cij);
                    }
                }
            }
        }
        // update ptr
        cptr[bcolumns] = cindex.length;
        // return sparse matrix
        return c;
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix    (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             SparseMatrix    (M, 1)
   */ function _multiplySparseMatrixVector(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // validate a matrix
        if (!avalues) {
            throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
        }
        // b dense
        var bdata = b._data;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = a._size[0];
        var brows = b._size[0];
        // result
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // equalScalar signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
        }
        // workspace
        var x = [];
        // vector with marks indicating a value x[i] exists in a given column
        var w = [];
        // update ptr
        cptr[0] = 0;
        // rows in b
        for(var ib = 0; ib < brows; ib++){
            // b[ib]
            var vbi = bdata[ib];
            // check b[ib] != 0, avoid loops
            if (!eq(vbi, zero)) {
                // A values & index in ib column
                for(var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                    // a row
                    var ia = aindex[ka];
                    // check value exists in current j
                    if (!w[ia]) {
                        // ia is new entry in j
                        w[ia] = true;
                        // add i to pattern of C
                        cindex.push(ia);
                        // x(ia) = A
                        x[ia] = mf(vbi, avalues[ka]);
                    } else {
                        // i exists in C already
                        x[ia] = af(x[ia], mf(vbi, avalues[ka]));
                    }
                }
            }
        }
        // copy values from x to column jb of c
        for(var p1 = cindex.length, p = 0; p < p1; p++){
            // row
            var ic = cindex[p];
            // copy value
            cvalues[p] = x[ic];
        }
        // update ptr
        cptr[1] = cindex.length;
        // matrix to return
        return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                1
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            DenseMatrix       (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */ function _multiplySparseMatrixDenseMatrix(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // validate a matrix
        if (!avalues) {
            throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
        }
        // b dense
        var bdata = b._data;
        var bdt = b._datatype || b.getDataType();
        // rows & columns
        var arows = a._size[0];
        var brows = b._size[0];
        var bcolumns = b._size[1];
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // equalScalar signature to use
        var eq = equalScalar;
        // zero value
        var zero = 0;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
            eq = typed.find(equalScalar, [
                dt,
                dt
            ]);
            // convert 0 to the same datatype
            zero = typed.convert(0, dt);
        }
        // result
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        // c matrix
        var c = a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
        // workspace
        var x = [];
        // vector with marks indicating a value x[i] exists in a given column
        var w = [];
        // loop b columns
        for(var jb = 0; jb < bcolumns; jb++){
            // update ptr
            cptr[jb] = cindex.length;
            // mark in workspace for current column
            var mark = jb + 1;
            // rows in jb
            for(var ib = 0; ib < brows; ib++){
                // b[ib, jb]
                var vbij = bdata[ib][jb];
                // check b[ib, jb] != 0, avoid loops
                if (!eq(vbij, zero)) {
                    // A values & index in ib column
                    for(var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                        // a row
                        var ia = aindex[ka];
                        // check value exists in current j
                        if (w[ia] !== mark) {
                            // ia is new entry in j
                            w[ia] = mark;
                            // add i to pattern of C
                            cindex.push(ia);
                            // x(ia) = A
                            x[ia] = mf(vbij, avalues[ka]);
                        } else {
                            // i exists in C already
                            x[ia] = af(x[ia], mf(vbij, avalues[ka]));
                        }
                    }
                }
            }
            // copy values from x to column jb of c
            for(var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++){
                // row
                var ic = cindex[p];
                // copy value
                cvalues[p] = x[ic];
            }
        }
        // update ptr
        cptr[bcolumns] = cindex.length;
        // return sparse matrix
        return c;
    }
    /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            SparseMatrix      (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */ function _multiplySparseMatrixSparseMatrix(a, b) {
        // a sparse
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
        // b sparse
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
        // rows & columns
        var arows = a._size[0];
        var bcolumns = b._size[1];
        // flag indicating both matrices (a & b) contain data
        var values = avalues && bvalues;
        // datatype
        var dt;
        // addScalar signature to use
        var af = addScalar;
        // multiplyScalar signature to use
        var mf = multiplyScalar;
        // process data types
        if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {
            // datatype
            dt = adt;
            // find signatures that matches (dt, dt)
            af = typed.find(addScalar, [
                dt,
                dt
            ]);
            mf = typed.find(multiplyScalar, [
                dt,
                dt
            ]);
        }
        // result
        var cvalues = values ? [] : undefined;
        var cindex = [];
        var cptr = [];
        // c matrix
        var c = a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [
                arows,
                bcolumns
            ],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
        });
        // workspace
        var x = values ? [] : undefined;
        // vector with marks indicating a value x[i] exists in a given column
        var w = [];
        // variables
        var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
        // loop b columns
        for(var jb = 0; jb < bcolumns; jb++){
            // update ptr
            cptr[jb] = cindex.length;
            // mark in workspace for current column
            var mark = jb + 1;
            // B values & index in j
            for(kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++){
                // b row
                ib = bindex[kb];
                // check we need to process values
                if (values) {
                    // loop values in a[:,ib]
                    for(ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                        // row
                        ia = aindex[ka];
                        // check value exists in current j
                        if (w[ia] !== mark) {
                            // ia is new entry in j
                            w[ia] = mark;
                            // add i to pattern of C
                            cindex.push(ia);
                            // x(ia) = A
                            x[ia] = mf(bvalues[kb], avalues[ka]);
                        } else {
                            // i exists in C already
                            x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
                        }
                    }
                } else {
                    // loop values in a[:,ib]
                    for(ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++){
                        // row
                        ia = aindex[ka];
                        // check value exists in current j
                        if (w[ia] !== mark) {
                            // ia is new entry in j
                            w[ia] = mark;
                            // add i to pattern of C
                            cindex.push(ia);
                        }
                    }
                }
            }
            // check we need to process matrix values (pattern matrix)
            if (values) {
                // copy values from x to column jb of c
                for(var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++){
                    // row
                    var ic = cindex[p];
                    // copy value
                    cvalues[p] = x[ic];
                }
            }
        }
        // update ptr
        cptr[bcolumns] = cindex.length;
        // return sparse matrix
        return c;
    }
    /**
   * Multiply two or more values, `x * y`.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *    math.multiply(x, y, z, ...)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2)        // returns number 20.8
   *    math.multiply(2, 3, 4)       // returns number 24
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(4, 1)
   *    math.multiply(a, b)          // returns Complex 5 + 14i
   *
   *    const c = [[1, 2], [4, 3]]
   *    const d = [[1, 2, 3], [3, -4, 7]]
   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    const e = math.unit('2.1 km')
   *    math.multiply(3, e)          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide, prod, cross, dot
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */ return typed(name, multiplyScalar, {
        // we extend the signatures of multiplyScalar with signatures dealing with matrices
        'Array, Array': typed.referTo('Matrix, Matrix', (selfMM)=>(x, y)=>{
                // check dimensions
                _validateMatrixDimensions((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["arraySize"])(x), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["arraySize"])(y));
                // use dense matrix implementation
                var m = selfMM(matrix(x), matrix(y));
                // return array or scalar
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isMatrix"])(m) ? m.valueOf() : m;
            }),
        'Matrix, Matrix': function Matrix_Matrix(x, y) {
            // dimensions
            var xsize = x.size();
            var ysize = y.size();
            // check dimensions
            _validateMatrixDimensions(xsize, ysize);
            // process dimensions
            if (xsize.length === 1) {
                // process y dimensions
                if (ysize.length === 1) {
                    // Vector * Vector
                    return _multiplyVectorVector(x, y, xsize[0]);
                }
                // Vector * Matrix
                return _multiplyVectorMatrix(x, y);
            }
            // process y dimensions
            if (ysize.length === 1) {
                // Matrix * Vector
                return _multiplyMatrixVector(x, y);
            }
            // Matrix * Matrix
            return _multiplyMatrixMatrix(x, y);
        },
        'Matrix, Array': typed.referTo('Matrix,Matrix', (selfMM)=>(x, y)=>selfMM(x, matrix(y))),
        'Array, Matrix': typed.referToSelf((self)=>(x, y)=>{
                // use Matrix * Matrix implementation
                return self(matrix(x, y.storage()), y);
            }),
        'SparseMatrix, any': function SparseMatrix_any(x, y) {
            return matAlgo11xS0s(x, y, multiplyScalar, false);
        },
        'DenseMatrix, any': function DenseMatrix_any(x, y) {
            return matAlgo14xDs(x, y, multiplyScalar, false);
        },
        'any, SparseMatrix': function any_SparseMatrix(x, y) {
            return matAlgo11xS0s(y, x, multiplyScalar, true);
        },
        'any, DenseMatrix': function any_DenseMatrix(x, y) {
            return matAlgo14xDs(y, x, multiplyScalar, true);
        },
        'Array, any': function Array_any(x, y) {
            // use matrix implementation
            return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();
        },
        'any, Array': function any_Array(x, y) {
            // use matrix implementation
            return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();
        },
        'any, any': multiplyScalar,
        'any, any, ...any': typed.referToSelf((self)=>(x, y, rest)=>{
                var result = self(x, y);
                for(var i = 0; i < rest.length; i++){
                    result = self(result, rest[i]);
                }
                return result;
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNthRoot": (()=>createNthRoot),
    "createNthRootNumber": (()=>createNthRootNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
var name = 'nthRoot';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'BigNumber',
    'concat'
];
var createNthRoot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, BigNumber: _BigNumber, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo06xS0S0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo06xS0S0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo06xS0S0"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Calculate the nth root of a value.
   * The principal nth root of a positive real number A, is the positive real
   * solution of the equation
   *
   *     x^root = A
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *     math.nthRoot(a)
   *     math.nthRoot(a, root)
   *
   * Examples:
   *
   *     math.nthRoot(9, 2)    // returns 3 (since 3^2 == 9)
   *     math.sqrt(9)          // returns 3 (since 3^2 == 9)
   *     math.nthRoot(64, 3)   // returns 4 (since 4^3 == 64)
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param {number | BigNumber | Array | Matrix | Complex} a
   *              Value for which to calculate the nth root
   * @param {number | BigNumber} [root=2]    The root.
   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
   */ function complexErr() {
        throw new Error('Complex number not supported in function nthRoot. Use nthRoots instead.');
    }
    return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nthRootNumber"],
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nthRootNumber"],
        BigNumber: (x)=>_bigNthRoot(x, new _BigNumber(2)),
        'BigNumber, BigNumber': _bigNthRoot,
        Complex: complexErr,
        'Complex, number': complexErr,
        Array: typed.referTo('DenseMatrix,number', (selfDn)=>(x)=>selfDn(matrix(x), 2).valueOf()),
        DenseMatrix: typed.referTo('DenseMatrix,number', (selfDn)=>(x)=>selfDn(x, 2)),
        SparseMatrix: typed.referTo('SparseMatrix,number', (selfSn)=>(x)=>selfSn(x, 2)),
        'SparseMatrix, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // density must be one (no zeros in matrix)
                if (y.density() === 1) {
                    // sparse + sparse
                    return matAlgo06xS0S0(x, y, self);
                } else {
                    // throw exception
                    throw new Error('Root must be non-zero');
                }
            }),
        'DenseMatrix, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // density must be one (no zeros in matrix)
                if (y.density() === 1) {
                    // dense + sparse
                    return matAlgo01xDSid(x, y, self, false);
                } else {
                    // throw exception
                    throw new Error('Root must be non-zero');
                }
            }),
        'Array, SparseMatrix': typed.referTo('DenseMatrix,SparseMatrix', (selfDS)=>(x, y)=>selfDS(matrix(x), y)),
        'number | BigNumber, SparseMatrix': typed.referToSelf((self)=>(x, y)=>{
                // density must be one (no zeros in matrix)
                if (y.density() === 1) {
                    // sparse - scalar
                    return matAlgo11xS0s(y, x, self, true);
                } else {
                    // throw exception
                    throw new Error('Root must be non-zero');
                }
            })
    }, matrixAlgorithmSuite({
        scalar: 'number | BigNumber',
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: false
    }));
    "TURBOPACK unreachable";
    /**
   * Calculate the nth root of a for BigNumbers, solve x^root == a
   * https://rosettacode.org/wiki/Nth_root#JavaScript
   * @param {BigNumber} a
   * @param {BigNumber} root
   * @private
   */ function _bigNthRoot(a, root) {
        var precision = _BigNumber.precision;
        var Big = _BigNumber.clone({
            precision: precision + 2
        });
        var zero = new _BigNumber(0);
        var one = new Big(1);
        var inv = root.isNegative();
        if (inv) {
            root = root.neg();
        }
        if (root.isZero()) {
            throw new Error('Root must be non-zero');
        }
        if (a.isNegative() && !root.abs().mod(2).equals(1)) {
            throw new Error('Root must be odd when a is negative.');
        }
        // edge cases zero and infinity
        if (a.isZero()) {
            return inv ? new Big(Infinity) : 0;
        }
        if (!a.isFinite()) {
            return inv ? zero : a;
        }
        var x = a.abs().pow(one.div(root));
        // If a < 0, we require that root is an odd integer,
        // so (-1) ^ (1/root) = -1
        x = a.isNeg() ? x.neg() : x;
        return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
    }
});
var createNthRootNumber = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, [
    'typed'
], (_ref2)=>{
    var { typed } = _ref2;
    return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nthRootNumber"],
        'number, number': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nthRootNumber"]
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/sign.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSign": (()=>createSign)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
var name = 'sign';
var dependencies = [
    'typed',
    'BigNumber',
    'Fraction',
    'complex'
];
var createSign = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, BigNumber: _BigNumber, complex, Fraction: _Fraction } = _ref;
    /**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x > 0
   * - -1 when x < 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5)               // returns 1
   *    math.sign(-4.2)              // returns -1
   *    math.sign(0)                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit} x
   *            The number for which to determine the sign
   * @return {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit}
   *            The sign of `x`
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["signNumber"],
        Complex: function Complex(x) {
            return x.im === 0 ? complex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["signNumber"])(x.re)) : x.sign();
        },
        BigNumber: function BigNumber(x) {
            return new _BigNumber(x.cmp(0));
        },
        bigint: function bigint(x) {
            return x > 0n ? 1n : x < 0n ? -1n : 0n;
        },
        Fraction: function Fraction(x) {
            return x.n === 0n ? new _Fraction(0) : new _Fraction(x.s);
        },
        // deep map collection, skip zeros since sign(0) = 0
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true)),
        Unit: typed.referToSelf((self)=>(x)=>{
                if (!x._isDerived() && x.units[0].unit.offset !== 0) {
                    throw new TypeError('sign is ambiguous for units with offset');
                }
                return typed.find(self, x.valueType())(x.value);
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSqrt": (()=>createSqrt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
var name = 'sqrt';
var dependencies = [
    'config',
    'typed',
    'Complex'
];
var createSqrt = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, typed, Complex } = _ref;
    /**
   * Calculate the square root of a value.
   *
   * For matrices, if you want the matrix square root of a square matrix,
   * use the `sqrtm` function. If you wish to apply `sqrt` elementwise to
   * a matrix M, use `math.map(M, math.sqrt)`.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25)                // returns 5
   *    math.square(5)               // returns 25
   *    math.sqrt(-4)                // returns Complex 2i
   *
   * See also:
   *
   *    square, multiply, cube, cbrt, sqrtm
   *
   * @param {number | BigNumber | Complex | Unit} x
   *            Value for which to calculate the square root.
   * @return {number | BigNumber | Complex | Unit}
   *            Returns the square root of `x`
   */ return typed('sqrt', {
        number: _sqrtNumber,
        Complex: function Complex(x) {
            return x.sqrt();
        },
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.sqrt();
            } else {
                // negative value -> downgrade to number to do complex value computation
                return _sqrtNumber(x.toNumber());
            }
        },
        Unit: function Unit(x) {
            // Someday will work for complex units when they are implemented
            return x.pow(0.5);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate sqrt for a number
   * @param {number} x
   * @returns {number | Complex} Returns the square root of x
   * @private
   */ function _sqrtNumber(x) {
        if (isNaN(x)) {
            return NaN;
        } else if (x >= 0 || config.predictable) {
            return Math.sqrt(x);
        } else {
            return new Complex(x, 0).sqrt();
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/square.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSquare": (()=>createSquare)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'square';
var dependencies = [
    'typed'
];
var createSquare = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed } = _ref;
    /**
   * Compute the square of a value, `x * x`.
   * To avoid confusion with multiplying a square matrix by itself,
   * this function does not apply to matrices. If you wish to square
   * every element of a matrix, see the examples.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2)           // returns number 4
   *    math.square(3)           // returns number 9
   *    math.pow(3, 2)           // returns number 9
   *    math.multiply(3, 3)      // returns number 9
   *
   *    math.map([1, 2, 3, 4], math.square)  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x
   *            Number for which to calculate the square
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}
   *            Squared value
   */ return typed(name, {
        number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["squareNumber"],
        Complex: function Complex(x) {
            return x.mul(x);
        },
        BigNumber: function BigNumber(x) {
            return x.times(x);
        },
        bigint: function bigint(x) {
            return x * x;
        },
        Fraction: function Fraction(x) {
            return x.mul(x);
        },
        Unit: function Unit(x) {
            return x.pow(2);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/subtract.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSubtract": (()=>createSubtract)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
var name = 'subtract';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'subtractScalar',
    'unaryMinus',
    'DenseMatrix',
    'concat'
];
var createSubtract = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, subtractScalar, unaryMinus, DenseMatrix, concat } = _ref;
    // TODO: split function subtract in two: subtract and subtractScalar
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo05xSfSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo05xSfSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo05xSfSf"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2)        // returns number 3.3
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(4, 1)
   *    math.subtract(a, b)          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
   *
   *    const c = math.unit('2.1 km')
   *    const d = math.unit('500m')
   *    math.subtract(c, d)          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x Initial value
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Value to subtract from `x`
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Subtraction of `x` and `y`
   */ return typed(name, {
        'any, any': subtractScalar
    }, matrixAlgorithmSuite({
        elop: subtractScalar,
        SS: matAlgo05xSfSf,
        DS: matAlgo01xDSid,
        SD: matAlgo03xDSf,
        Ss: matAlgo12xSfs,
        sS: matAlgo10xSids
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createXgcd": (()=>createXgcd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
var name = 'xgcd';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'BigNumber'
];
var createXgcd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, BigNumber } = _ref;
    /**
   * Calculate the extended greatest common divisor for two values.
   * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12)             // returns [4, -1, 1]
   *    math.gcd(8, 12)              // returns 4
   *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */ return typed(name, {
        'number, number': function number_number(a, b) {
            var res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["xgcdNumber"])(a, b);
            return config.matrix === 'Array' ? res : matrix(res);
        },
        'BigNumber, BigNumber': _xgcdBigNumber
    });
    "TURBOPACK unreachable";
    /**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */ function _xgcdBigNumber(a, b) {
        // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
        var // used to swap two variables
        t;
        var // quotient
        q;
        var // remainder
        r;
        var zero = new BigNumber(0);
        var one = new BigNumber(1);
        var x = zero;
        var lastx = one;
        var y = one;
        var lasty = zero;
        if (!a.isInt() || !b.isInt()) {
            throw new Error('Parameters in function xgcd must be integer numbers');
        }
        while(!b.isZero()){
            q = a.div(b).floor();
            r = a.mod(b);
            t = x;
            x = lastx.minus(q.times(x));
            lastx = t;
            t = y;
            y = lasty.minus(q.times(y));
            lasty = t;
            a = b;
            b = r;
        }
        var res;
        if (a.lt(zero)) {
            res = [
                a.neg(),
                lastx.neg(),
                lasty.neg()
            ];
        } else {
            res = [
                a,
                !a.isZero() ? lastx : 0,
                lasty
            ];
        }
        return config.matrix === 'Array' ? res : matrix(res);
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/invmod.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createInvmod": (()=>createInvmod)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
var name = 'invmod';
var dependencies = [
    'typed',
    'config',
    'BigNumber',
    'xgcd',
    'equal',
    'smaller',
    'mod',
    'add',
    'isInteger'
];
var createInvmod = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, BigNumber, xgcd, equal, smaller, mod, add, isInteger } = _ref;
    /**
   * Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation `ax  1 (mod b)`
   * See https://en.wikipedia.org/wiki/Modular_multiplicative_inverse.
   *
   * Syntax:
   *
   *    math.invmod(a, b)
   *
   * Examples:
   *
   *    math.invmod(8, 12)             // returns NaN
   *    math.invmod(7, 13)             // returns 2
   *    math.invmod(15151, 15122)      // returns 10429
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {number | BigNumber }  Returns an integer number
   *                              where `invmod(a,b)*a  1 (mod b)`
   */ return typed(name, {
        'number, number': invmod,
        'BigNumber, BigNumber': invmod
    });
    "TURBOPACK unreachable";
    function invmod(a, b) {
        if (!isInteger(a) || !isInteger(b)) throw new Error('Parameters in function invmod must be integer numbers');
        a = mod(a, b);
        if (equal(b, 0)) throw new Error('Divisor must be non zero');
        var res = xgcd(a, b);
        res = res.valueOf();
        var [gcd, inv] = res;
        if (!equal(gcd, BigNumber(1))) return NaN;
        inv = mod(inv, b);
        if (smaller(inv, BigNumber(0))) inv = add(inv, b);
        return inv;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDotMultiply": (()=>createDotMultiply)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo09xS0Sf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
;
;
;
;
;
var name = 'dotMultiply';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'multiplyScalar',
    'concat'
];
var createDotMultiply = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, multiplyScalar, concat } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo09xS0Sf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo09xS0Sf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo09xS0Sf"])({
        typed,
        equalScalar
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4) // returns 8
   *
   *    a = [[9, 5], [6, 1]]
   *    b = [[3, 2], [5, 2]]
   *
   *    math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b)    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */ return typed(name, matrixAlgorithmSuite({
        elop: multiplyScalar,
        SS: matAlgo09xS0Sf,
        DS: matAlgo02xDS0,
        Ss: matAlgo11xS0s
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDivideScalar": (()=>createDivideScalar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
var name = 'divideScalar';
var dependencies = [
    'typed',
    'numeric'
];
var createDivideScalar = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, numeric } = _ref;
    /**
   * Divide two scalar values, `x / y`.
   * This function is meant for internal use: it is used by the public functions
   * `divide` and `inv`.
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   Numerator
   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Denominator
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Quotient, `x / y`
   * @private
   */ return typed(name, {
        'number, number': function number_number(x, y) {
            return x / y;
        },
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.div(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            return x.div(y);
        },
        'bigint, bigint': function bigint_bigint(x, y) {
            return x / y;
        },
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            return x.div(y);
        },
        'Unit, number | Complex | Fraction | BigNumber | Unit': (x, y)=>x.divide(y),
        'number | Fraction | Complex | BigNumber, Unit': (x, y)=>y.divideInto(x)
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/pow.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPow": (()=>createPow)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
;
var name = 'pow';
var dependencies = [
    'typed',
    'config',
    'identity',
    'multiply',
    'matrix',
    'inv',
    'fraction',
    'number',
    'Complex'
];
var createPow = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, identity, multiply, matrix, inv, number, fraction, Complex } = _ref;
    /**
   * Calculates the power of x to y, `x ^ y`.
   *
   * Matrix exponentiation is supported for square matrices `x` and integers `y`:
   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
   * negative, `x` must be invertible, and then this function returns
   * inv(x)^(-y).
   *
   * For cubic roots of negative numbers, the function returns the principal
   * root by default. In order to let the function return the real root,
   * math.js can be configured with `math.config({predictable: true})`.
   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3)               // returns number 8
   *
   *    const a = math.complex(2, 3)
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    const b = [[1, 2], [4, 3]]
   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
   *
   *    const c = [[1, 2], [4, 3]]
   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
   *
   * See also:
   *
   *    multiply, sqrt, cbrt, nthRoot
   *
   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | bigint | Complex} y                          The exponent
   * @return {number | BigNumber | bigint | Complex | Array | Matrix} The value of `x` to the power `y`
   */ return typed(name, {
        'number, number': _pow,
        'Complex, Complex': function Complex_Complex(x, y) {
            return x.pow(y);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {
            if (y.isInteger() || x >= 0 || config.predictable) {
                return x.pow(y);
            } else {
                return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
            }
        },
        'bigint, bigint': (x, y)=>x ** y,
        'Fraction, Fraction': function Fraction_Fraction(x, y) {
            var result = x.pow(y);
            if (result != null) {
                return result;
            }
            if (config.predictable) {
                throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');
            } else {
                return _pow(x.valueOf(), y.valueOf());
            }
        },
        'Array, number': _powArray,
        'Array, BigNumber': function Array_BigNumber(x, y) {
            return _powArray(x, y.toNumber());
        },
        'Matrix, number': _powMatrix,
        'Matrix, BigNumber': function Matrix_BigNumber(x, y) {
            return _powMatrix(x, y.toNumber());
        },
        'Unit, number | BigNumber': function Unit_number__BigNumber(x, y) {
            return x.pow(y);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number | Complex} res
   * @private
   */ function _pow(x, y) {
        // Alternatively could define a 'realmode' config option or something, but
        // 'predictable' will work for now
        if (config.predictable && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(y) && x < 0) {
            // Check to see if y can be represented as a fraction
            try {
                var yFrac = fraction(y);
                var yNum = number(yFrac);
                if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
                    if (yFrac.d % 2n === 1n) {
                        return (yFrac.n % 2n === 0n ? 1 : -1) * Math.pow(-x, y);
                    }
                }
            } catch (ex) {
            // fraction() throws an error if y is Infinity, etc.
            }
        // Unable to express y as a fraction, so continue on
        }
        // **for predictable mode** x^Infinity === NaN if x < -1
        // N.B. this behavour is different from `Math.pow` which gives
        // (-2)^Infinity === Infinity
        if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
            return NaN;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(y) || x >= 0 || config.predictable) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["powNumber"])(x, y);
        } else {
            // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
            // x^Infinity === 0 if -1 < x < 1
            // A real number 0 is returned instead of complex(0)
            if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
                return 0;
            }
            return new Complex(x, 0).pow(y, 0);
        }
    }
    /**
   * Calculate the power of a 2d array
   * @param {Array} x     must be a 2 dimensional, square matrix
   * @param {number} y    a integer value (positive if `x` is not invertible)
   * @returns {Array}
   * @private
   */ function _powArray(x, y) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInteger"])(y)) {
            throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');
        }
        // verify that A is a 2 dimensional square matrix
        var s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["arraySize"])(x);
        if (s.length !== 2) {
            throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
        }
        if (s[0] !== s[1]) {
            throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
        }
        if (y < 0) {
            try {
                return _powArray(inv(x), -y);
            } catch (error) {
                if (error.message === 'Cannot calculate inverse, determinant is zero') {
                    throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');
                }
                throw error;
            }
        }
        var res = identity(s[0]).valueOf();
        var px = x;
        while(y >= 1){
            if ((y & 1) === 1) {
                res = multiply(px, res);
            }
            y >>= 1;
            px = multiply(px, px);
        }
        return res;
    }
    /**
   * Calculate the power of a 2d matrix
   * @param {Matrix} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Matrix}
   * @private
   */ function _powMatrix(x, y) {
        return matrix(_powArray(x.valueOf(), y));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/round.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRound": (()=>createRound)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
var NO_INT = 'Number of decimals in function round must be an integer';
var name = 'round';
var dependencies = [
    'typed',
    'config',
    'matrix',
    'equalScalar',
    'zeros',
    'BigNumber',
    'DenseMatrix'
];
var createRound = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, matrix, equalScalar, zeros, BigNumber: _BigNumber, DenseMatrix } = _ref;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    function toExponent(epsilon) {
        return Math.abs((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["splitNumber"])(epsilon).exponent);
    }
    /**
   * Round a value towards the nearest rounded value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *    math.round(unit, valuelessUnit)
   *    math.round(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.round(3.22)             // returns number 3
   *    math.round(3.82)             // returns number 4
   *    math.round(-4.2)             // returns number -4
   *    math.round(-4.7)             // returns number -5
   *    math.round(3.22, 1)          // returns number 3.2
   *    math.round(3.88, 1)          // returns number 3.9
   *    math.round(-4.21, 1)         // returns number -4.2
   *    math.round(-4.71, 1)         // returns number -4.7
   *    math.round(math.pi, 3)       // returns number 3.142
   *    math.round(123.45678, 2)     // returns number 123.46
   *
   *    const c = math.complex(3.2, -2.7)
   *    math.round(c)                // returns Complex 3 - 3i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.round(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.round(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.round([3.2, 3.8, -4.7]) // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Rounded value
   */ return typed(name, {
        number: function number(x) {
            // Handle round off errors by first rounding to relTol precision
            var xEpsilon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundNumber"])(x, toExponent(config.relTol));
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundNumber"])(xSelected);
        },
        'number, number': function number_number(x, n) {
            // Same as number: unless user specifies more decimals than relTol
            var epsilonExponent = toExponent(config.relTol);
            if (n >= epsilonExponent) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundNumber"])(x, n);
            }
            var xEpsilon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundNumber"])(x, epsilonExponent);
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundNumber"])(xSelected, n);
        },
        'number, BigNumber': function number_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            return new _BigNumber(x).toDecimalPlaces(n.toNumber());
        },
        Complex: function Complex(x) {
            return x.round();
        },
        'Complex, number': function Complex_number(x, n) {
            if (n % 1) {
                throw new TypeError(NO_INT);
            }
            return x.round(n);
        },
        'Complex, BigNumber': function Complex_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            var _n = n.toNumber();
            return x.round(_n);
        },
        BigNumber: function BigNumber(x) {
            // Handle round off errors by first rounding to relTol precision
            var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config.relTol));
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return xSelected.toDecimalPlaces(0);
        },
        'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            // Same as BigNumber: unless user specifies more decimals than relTol
            var epsilonExponent = toExponent(config.relTol);
            if (n >= epsilonExponent) {
                return x.toDecimalPlaces(n.toNumber());
            }
            var xEpsilon = x.toDecimalPlaces(epsilonExponent);
            var xSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bignumber$2f$nearlyEqual$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nearlyEqual"])(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;
            return xSelected.toDecimalPlaces(n.toNumber());
        },
        // bigints can't be rounded
        bigint: (b)=>b,
        'bigint, number': (b, _dummy)=>b,
        'bigint, BigNumber': (b, _dummy)=>b,
        Fraction: function Fraction(x) {
            return x.round();
        },
        'Fraction, number': function Fraction_number(x, n) {
            if (n % 1) {
                throw new TypeError(NO_INT);
            }
            return x.round(n);
        },
        'Fraction, BigNumber': function Fraction_BigNumber(x, n) {
            if (!n.isInteger()) {
                throw new TypeError(NO_INT);
            }
            return x.round(n.toNumber());
        },
        'Unit, number, Unit': typed.referToSelf((self)=>function(x, n, unit) {
                var valueless = x.toNumeric(unit);
                return unit.multiply(self(valueless, n));
            }),
        'Unit, BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>self(x, n.toNumber(), unit)),
        'Array | Matrix, number | BigNumber, Unit': typed.referToSelf((self)=>(x, n, unit)=>{
                // deep map collection, skip zeros since round(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, (value)=>self(value, n, unit), true);
            }),
        'Array | Matrix | Unit, Unit': typed.referToSelf((self)=>(x, unit)=>self(x, 0, unit)),
        'Array | Matrix': typed.referToSelf((self)=>(x)=>{
                // deep map collection, skip zeros since round(0) = 0
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self, true);
            }),
        'SparseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                return matAlgo11xS0s(x, n, self, false);
            }),
        'DenseMatrix, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                return matAlgo14xDs(x, n, self, false);
            }),
        'Array, number | BigNumber': typed.referToSelf((self)=>(x, n)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(x), n, self, false).valueOf();
            }),
        'number | Complex | BigNumber | Fraction, SparseMatrix': typed.referToSelf((self)=>(x, n)=>{
                // check scalar is zero
                if (equalScalar(x, 0)) {
                    // do not execute algorithm, result will be a zero matrix
                    return zeros(n.size(), n.storage());
                }
                return matAlgo12xSfs(n, x, self, true);
            }),
        'number | Complex | BigNumber | Fraction, DenseMatrix': typed.referToSelf((self)=>(x, n)=>{
                // check scalar is zero
                if (equalScalar(x, 0)) {
                    // do not execute algorithm, result will be a zero matrix
                    return zeros(n.size(), n.storage());
                }
                return matAlgo14xDs(n, x, self, true);
            }),
        'number | Complex | BigNumber | Fraction, Array': typed.referToSelf((self)=>(x, n)=>{
                // use matrix implementation
                return matAlgo14xDs(matrix(n), x, self, true).valueOf();
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog": (()=>createLog)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/bigint.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/plain/number/arithmetic.js [app-rsc] (ecmascript)");
;
;
;
var name = 'log';
var dependencies = [
    'config',
    'typed',
    'typeOf',
    'divideScalar',
    'Complex'
];
var nlg16 = Math.log(16);
var createLog = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, typeOf, config, divideScalar, Complex } = _ref;
    /**
   * Calculate the logarithm of a value.
   *
   * To avoid confusion with the matrix logarithm, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.log(x)
   *    math.log(x, base)
   *
   * Examples:
   *
   *    math.log(3.5)                  // returns 1.252762968495368
   *    math.exp(math.log(2.4))        // returns 2.4
   *
   *    math.pow(10, 4)                // returns 10000
   *    math.log(10000, 10)            // returns 4
   *    math.log(10000) / math.log(10) // returns 4
   *
   *    math.log(1024, 2)              // returns 10
   *    math.pow(2, 10)                // returns 1024
   *
   * See also:
   *
   *    exp, log2, log10, log1p
   *
   * @param {number | BigNumber | Fraction | Complex} x
   *            Value for which to calculate the logarithm.
   * @param {number | BigNumber | Fraction | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x` is calculated.
   * @return {number | BigNumber | Fraction | Complex}
   *            Returns the logarithm of `x`
   */ function complexLog(c) {
        return c.log();
    }
    function complexLogNumber(x) {
        return complexLog(new Complex(x, 0));
    }
    return typed(name, {
        number: function number(x) {
            if (x >= 0 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["logNumber"])(x);
            } else {
                // negative value -> complex value computation
                return complexLogNumber(x);
            }
        },
        bigint: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$bigint$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["promoteLogarithm"])(nlg16, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$plain$2f$number$2f$arithmetic$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["logNumber"], config, complexLogNumber),
        Complex: complexLog,
        BigNumber: function BigNumber(x) {
            if (!x.isNegative() || config.predictable) {
                return x.ln();
            } else {
                // downgrade to number, return Complex valued result
                return complexLogNumber(x.toNumber());
            }
        },
        'any, any': typed.referToSelf((self)=>(x, base)=>{
                // calculate logarithm for a specified base, log(x, base)
                if (typeOf(x) === 'Fraction' && typeOf(base) === 'Fraction') {
                    var result = x.log(base);
                    if (result !== null) {
                        return result;
                    }
                }
                return divideScalar(self(x), self(base));
            })
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/log1p.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLog1p": (()=>createLog1p)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/collection.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-rsc] (ecmascript)");
;
;
;
var name = 'log1p';
var dependencies = [
    'typed',
    'config',
    'divideScalar',
    'log',
    'Complex'
];
var createLog1p = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, divideScalar, log, Complex } = _ref;
    /**
   * Calculate the logarithm of a `value+1`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log1p(x)
   *    math.log1p(x, base)
   *
   * Examples:
   *
   *    math.log1p(2.5)                 // returns 1.252762968495368
   *    math.exp(math.log1p(1.4))       // returns 2.4
   *
   *    math.pow(10, 4)                 // returns 10000
   *    math.log1p(9999, 10)            // returns 4
   *    math.log1p(9999) / math.log(10) // returns 4
   *
   * See also:
   *
   *    exp, log, log2, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm of `x+1`.
   * @param {number | BigNumber | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x+1` is calculated.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the logarithm of `x+1`
   */ return typed(name, {
        number: function number(x) {
            if (x >= -1 || config.predictable) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["log1p"])(x);
            } else {
                // negative value -> complex value computation
                return _log1pComplex(new Complex(x, 0));
            }
        },
        Complex: _log1pComplex,
        BigNumber: function BigNumber(x) {
            var y = x.plus(1);
            if (!y.isNegative() || config.predictable) {
                return y.ln();
            } else {
                // downgrade to number, return Complex valued result
                return _log1pComplex(new Complex(x.toNumber(), 0));
            }
        },
        'Array | Matrix': typed.referToSelf((self)=>(x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$collection$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMap"])(x, self)),
        'any, any': typed.referToSelf((self)=>(x, base)=>{
                // calculate logarithm for a specified base, log1p(x, base)
                return divideScalar(self(x), log(base));
            })
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the natural logarithm of a complex number + 1
   * @param {Complex} x
   * @returns {Complex}
   * @private
   */ function _log1pComplex(x) {
        var xRe1p = x.re + 1;
        return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNthRoots": (()=>createNthRoots)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
var name = 'nthRoots';
var dependencies = [
    'config',
    'typed',
    'divideScalar',
    'Complex'
];
var createNthRoots = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, divideScalar, Complex } = _ref;
    /**
   * Each function here returns a real multiple of i as a Complex value.
   * @param  {number} val
   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3
   */ // This is used to fix float artifacts for zero-valued components.
    var _calculateExactResult = [
        function realPos(val) {
            return new Complex(val, 0);
        },
        function imagPos(val) {
            return new Complex(0, val);
        },
        function realNeg(val) {
            return new Complex(-val, 0);
        },
        function imagNeg(val) {
            return new Complex(0, -val);
        }
    ];
    /**
   * Calculate the nth root of a Complex Number a using De Movire's Theorem.
   * @param  {Complex} a
   * @param  {number} root
   * @return {Array} array of n Complex Roots
   */ function _nthComplexRoots(a, root) {
        if (root < 0) throw new Error('Root must be greater than zero');
        if (root === 0) throw new Error('Root must be non-zero');
        if (root % 1 !== 0) throw new Error('Root must be an integer');
        if (a === 0 || a.abs() === 0) return [
            new Complex(0, 0)
        ];
        var aIsNumeric = typeof a === 'number';
        var offset;
        // determine the offset (argument of a)/(pi/2)
        if (aIsNumeric || a.re === 0 || a.im === 0) {
            if (aIsNumeric) {
                offset = 2 * +(a < 0); // numeric value on the real axis
            } else if (a.im === 0) {
                offset = 2 * +(a.re < 0); // complex value on the real axis
            } else {
                offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis
            }
        }
        var arg = a.arg();
        var abs = a.abs();
        var roots = [];
        var r = Math.pow(abs, 1 / root);
        for(var k = 0; k < root; k++){
            var halfPiFactor = (offset + 4 * k) / root;
            /**
       * If (offset + 4*k)/root is an integral multiple of pi/2
       * then we can produce a more exact result.
       */ if (halfPiFactor === Math.round(halfPiFactor)) {
                roots.push(_calculateExactResult[halfPiFactor % 4](r));
                continue;
            }
            roots.push(new Complex({
                r,
                phi: (arg + 2 * Math.PI * k) / root
            }));
        }
        return roots;
    }
    /**
   * Calculate the nth roots of a value.
   * An nth root of a positive real number A,
   * is a positive real solution of the equation "x^root = A".
   * This function returns an array of Complex values.
   * Note that currently the precision of Complex numbers are limited
   * to the precision of a 64-bit IEEE floating point, so even if the input
   * is a BigNumber with greater precision, rounding to 64 bits will occur
   * in computing the nth roots.
   *
   * Syntax:
   *
   *    math.nthRoots(x)
   *    math.nthRoots(x, root)
   *
   * Examples:
   *
   *    math.nthRoots(1)
   *    // returns [
   *    //   {re: 1, im: 0},
   *    //   {re: -1, im: 0}
   *    // ]
   *    math.nthRoots(1, 3)
   *    // returns [
   *    //   { re: 1, im: 0 },
   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },
   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }
   *    // ]
   *
   * See also:
   *
   *    nthRoot, pow, sqrt
   *
   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded
   * @param {number} [root=2] Optional root, default value is 2
   * @return {number | BigNumber | Fraction | Complex} Returns the nth roots
   */ return typed(name, {
        Complex: function Complex(x) {
            return _nthComplexRoots(x, 2);
        },
        'Complex, number': _nthComplexRoots
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDotPow": (()=>createDotPow)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
var name = 'dotPow';
var dependencies = [
    'typed',
    'equalScalar',
    'matrix',
    'pow',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createDotPow = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, equalScalar, matrix, pow, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    var powScalarSignatures = {};
    for(var signature in pow.signatures){
        if (Object.prototype.hasOwnProperty.call(pow.signatures, signature)) {
            if (!signature.includes('Matrix') && !signature.includes('Array')) {
                powScalarSignatures[signature] = pow.signatures[signature];
            }
        }
    }
    var powScalar = typed(powScalarSignatures);
    /**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3)            // returns number 8
   *
   *    const a = [[1, 2], [4, 3]]
   *    math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */ return typed(name, matrixAlgorithmSuite({
        elop: powScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDotDivide": (()=>createDotDivide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
var name = 'dotDivide';
var dependencies = [
    'typed',
    'matrix',
    'equalScalar',
    'divideScalar',
    'DenseMatrix',
    'concat',
    'SparseMatrix'
];
var createDotDivide = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, equalScalar, divideScalar, DenseMatrix, concat, SparseMatrix } = _ref;
    var matAlgo02xDS0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo02xDS0$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo02xDS0"])({
        typed,
        equalScalar
    });
    var matAlgo03xDSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo03xDSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo03xDSf"])({
        typed
    });
    var matAlgo07xSSf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo07xSSf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo07xSSf"])({
        typed,
        SparseMatrix
    });
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo12xSfs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo12xSfs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo12xSfs"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4)   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]]
   *    b = [[3, 2], [5, 2]]
   *
   *    math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */ return typed(name, matrixAlgorithmSuite({
        elop: divideScalar,
        SS: matAlgo07xSSf,
        DS: matAlgo03xDSf,
        SD: matAlgo02xDS0,
        Ss: matAlgo11xS0s,
        sS: matAlgo12xSfs
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/add.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAdd": (()=>createAdd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js [app-rsc] (ecmascript)");
;
;
;
;
;
var name = 'add';
var dependencies = [
    'typed',
    'matrix',
    'addScalar',
    'equalScalar',
    'DenseMatrix',
    'SparseMatrix',
    'concat'
];
var createAdd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, addScalar, equalScalar, DenseMatrix, SparseMatrix, concat } = _ref;
    var matAlgo01xDSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo01xDSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo01xDSid"])({
        typed
    });
    var matAlgo04xSidSid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo04xSidSid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo04xSidSid"])({
        typed,
        equalScalar
    });
    var matAlgo10xSids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo10xSids$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo10xSids"])({
        typed,
        DenseMatrix
    });
    var matrixAlgorithmSuite = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matrixAlgorithmSuite$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatrixAlgorithmSuite"])({
        typed,
        matrix,
        concat
    });
    /**
   * Add two or more values, `x + y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.add(x, y)
   *    math.add(x, y, z, ...)
   *
   * Examples:
   *
   *    math.add(2, 3)               // returns number 5
   *    math.add(2, 3, 4)            // returns number 9
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(-4, 1)
   *    math.add(a, b)               // returns Complex -2 + 4i
   *
   *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
   *
   *    const c = math.unit('5 cm')
   *    const d = math.unit('2.1 mm')
   *    math.add(c, d)               // returns Unit 52.1 mm
   *
   *    math.add("2.3", "4")         // returns number 6.3
   *
   * See also:
   *
   *    subtract, sum
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to add
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to add
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
   */ return typed(name, {
        'any, any': addScalar,
        'any, any, ...any': typed.referToSelf((self)=>(x, y, rest)=>{
                var result = self(x, y);
                for(var i = 0; i < rest.length; i++){
                    result = self(result, rest[i]);
                }
                return result;
            })
    }, matrixAlgorithmSuite({
        elop: addScalar,
        DS: matAlgo01xDSid,
        SS: matAlgo04xSidSid,
        Ss: matAlgo10xSids
    }));
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/hypot.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createHypot": (()=>createHypot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-rsc] (ecmascript)");
;
;
;
var name = 'hypot';
var dependencies = [
    'typed',
    'abs',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'sqrt',
    'smaller',
    'isPositive'
];
var createHypot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, addScalar, divideScalar, multiplyScalar, sqrt, smaller, isPositive } = _ref;
    /**
   * Calculate the hypotenuse of a list with values. The hypotenuse is defined as:
   *
   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
   *
   * For matrix input, the hypotenuse is calculated for all values in the matrix.
   *
   * Syntax:
   *
   *     math.hypot(a, b, ...)
   *     math.hypot([a, b, c, ...])
   *
   * Examples:
   *
   *     math.hypot(3, 4)      // 5
   *     math.hypot(3, 4, 5)   // 7.0710678118654755
   *     math.hypot([3, 4, 5]) // 7.0710678118654755
   *     math.hypot(-2)        // 2
   *
   * See also:
   *
   *     abs, norm
   *
   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.
   *                                                          Matrix and Array input is flattened and returns a
   *                                                          single number for the whole matrix.
   * @return {number | BigNumber} Returns the hypothenusa of the input values.
   */ return typed(name, {
        '... number | BigNumber': _hypot,
        Array: _hypot,
        Matrix: (M)=>_hypot((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["flatten"])(M.toArray(), true))
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the hypotenuse for an Array with values
   * @param {Array.<number | BigNumber>} args
   * @return {number | BigNumber} Returns the result
   * @private
   */ function _hypot(args) {
        // code based on `hypot` from es6-shim:
        // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
        var result = 0;
        var largest = 0;
        for(var i = 0; i < args.length; i++){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isComplex"])(args[i])) {
                throw new TypeError('Unexpected type of argument to hypot');
            }
            var value = abs(args[i]);
            if (smaller(largest, value)) {
                result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
                result = addScalar(result, 1);
                largest = value;
            } else {
                result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
            }
        }
        return multiplyScalar(largest, sqrt(result));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/norm.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createNorm": (()=>createNorm)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
;
var name = 'norm';
var dependencies = [
    'typed',
    'abs',
    'add',
    'pow',
    'conj',
    'sqrt',
    'multiply',
    'equalScalar',
    'larger',
    'smaller',
    'matrix',
    'ctranspose',
    'eigs'
];
var createNorm = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, add, pow, conj, sqrt, multiply, equalScalar, larger, smaller, matrix, ctranspose, eigs } = _ref;
    /**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5)                         // returns 3.5
   *    math.norm(-3.5)                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4))         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity)        // returns 3
   *    math.norm([1, 2, -3], -Infinity)       // returns 1
   *
   *    math.norm([3, 4], 2)                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs, hypot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the norm
   * @param  {number | BigNumber | string} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {number | BigNumber} the p-norm
   */ return typed(name, {
        number: Math.abs,
        Complex: function Complex(x) {
            return x.abs();
        },
        BigNumber: function BigNumber(x) {
            // norm(x) = abs(x)
            return x.abs();
        },
        boolean: function boolean(x) {
            // norm(x) = abs(x)
            return Math.abs(x);
        },
        Array: function Array(x) {
            return _norm(matrix(x), 2);
        },
        Matrix: function Matrix(x) {
            return _norm(x, 2);
        },
        'Array, number | BigNumber | string': function Array_number__BigNumber__string(x, p) {
            return _norm(matrix(x), p);
        },
        'Matrix, number | BigNumber | string': function Matrix_number__BigNumber__string(x, p) {
            return _norm(x, p);
        }
    });
    "TURBOPACK unreachable";
    /**
   * Calculate the plus infinity norm for a vector
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _vectorNormPlusInfinity(x) {
        // norm(x, Infinity) = max(abs(x))
        var pinf = 0;
        // skip zeros since abs(0) === 0
        x.forEach(function(value) {
            var v = abs(value);
            if (larger(v, pinf)) {
                pinf = v;
            }
        }, true);
        return pinf;
    }
    /**
   * Calculate the minus infinity norm for a vector
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _vectorNormMinusInfinity(x) {
        // norm(x, -Infinity) = min(abs(x))
        var ninf;
        // skip zeros since abs(0) === 0
        x.forEach(function(value) {
            var v = abs(value);
            if (!ninf || smaller(v, ninf)) {
                ninf = v;
            }
        }, true);
        return ninf || 0;
    }
    /**
   * Calculate the norm for a vector
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */ function _vectorNorm(x, p) {
        // check p
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
            return _vectorNormPlusInfinity(x);
        }
        if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
            return _vectorNormMinusInfinity(x);
        }
        if (p === 'fro') {
            return _norm(x, 2);
        }
        if (typeof p === 'number' && !isNaN(p)) {
            // check p != 0
            if (!equalScalar(p, 0)) {
                // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
                var n = 0;
                // skip zeros since abs(0) === 0
                x.forEach(function(value) {
                    n = add(pow(abs(value), p), n);
                }, true);
                return pow(n, 1 / p);
            }
            return Number.POSITIVE_INFINITY;
        }
        // invalid parameter value
        throw new Error('Unsupported parameter value');
    }
    /**
   * Calculate the Frobenius norm for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormFrobenius(x) {
        // norm(x) = sqrt(sum(diag(x'x)))
        var fro = 0;
        x.forEach(function(value, index) {
            fro = add(fro, multiply(value, conj(value)));
        });
        return abs(sqrt(fro));
    }
    /**
   * Calculate the norm L1 for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormOne(x) {
        // norm(x) = the largest column sum
        var c = [];
        // result
        var maxc = 0;
        // skip zeros since abs(0) == 0
        x.forEach(function(value, index) {
            var j = index[1];
            var cj = add(c[j] || 0, abs(value));
            if (larger(cj, maxc)) {
                maxc = cj;
            }
            c[j] = cj;
        }, true);
        return maxc;
    }
    /**
   * Calculate the norm L2 for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormTwo(x) {
        // norm(x) = sqrt( max eigenvalue of A*.A)
        var sizeX = x.size();
        if (sizeX[0] !== sizeX[1]) {
            throw new RangeError('Invalid matrix dimensions');
        }
        var tx = ctranspose(x);
        var squaredX = multiply(tx, x);
        var eigenVals = eigs(squaredX).values.toArray();
        var rho = eigenVals[eigenVals.length - 1];
        return abs(sqrt(rho));
    }
    /**
   * Calculate the infinity norm for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNormInfinity(x) {
        // norm(x) = the largest row sum
        var r = [];
        // result
        var maxr = 0;
        // skip zeros since abs(0) == 0
        x.forEach(function(value, index) {
            var i = index[0];
            var ri = add(r[i] || 0, abs(value));
            if (larger(ri, maxr)) {
                maxr = ri;
            }
            r[i] = ri;
        }, true);
        return maxr;
    }
    /**
   * Calculate the norm for a 2D Matrix (M*N)
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */ function _matrixNorm(x, p) {
        // check p
        if (p === 1) {
            return _matrixNormOne(x);
        }
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
            return _matrixNormInfinity(x);
        }
        if (p === 'fro') {
            return _matrixNormFrobenius(x);
        }
        if (p === 2) {
            return _matrixNormTwo(x);
        } // invalid parameter value
        throw new Error('Unsupported parameter value ' + p);
    }
    /**
   * Calculate the norm for an array
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */ function _norm(x, p) {
        // size
        var sizeX = x.size();
        // check if it is a vector
        if (sizeX.length === 1) {
            return _vectorNorm(x, p);
        }
        // MxN matrix
        if (sizeX.length === 2) {
            if (sizeX[0] && sizeX[1]) {
                return _matrixNorm(x, p);
            } else {
                throw new RangeError('Invalid matrix dimensions');
            }
        }
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/arithmetic/divide.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDivide": (()=>createDivide)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js [app-rsc] (ecmascript)");
;
;
;
;
var name = 'divide';
var dependencies = [
    'typed',
    'matrix',
    'multiply',
    'equalScalar',
    'divideScalar',
    'inv'
];
var createDivide = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, multiply, equalScalar, divideScalar, inv } = _ref;
    var matAlgo11xS0s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo11xS0s$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo11xS0s"])({
        typed,
        equalScalar
    });
    var matAlgo14xDs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$type$2f$matrix$2f$utils$2f$matAlgo14xDs$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createMatAlgo14xDs"])({
        typed
    });
    /**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3)            // returns number 0.6666666666666666
   *
   *    const a = math.complex(5, 14)
   *    const b = math.complex(4, 1)
   *    math.divide(a, b)            // returns Complex 2 + 3i
   *
   *    const c = [[7, -6], [13, -4]]
   *    const d = [[1, 2], [4, 3]]
   *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
   *
   *    const e = math.unit('18 km')
   *    math.divide(e, 4.5)          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x   Numerator
   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix} y          Denominator
   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */ return typed('divide', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extend"])({
        // we extend the signatures of divideScalar with signatures dealing with matrices
        'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(x, y) {
            // TODO: implement matrix right division using pseudo inverse
            // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
            // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
            // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
            return multiply(x, inv(y));
        },
        'DenseMatrix, any': function DenseMatrix_any(x, y) {
            return matAlgo14xDs(x, y, divideScalar, false);
        },
        'SparseMatrix, any': function SparseMatrix_any(x, y) {
            return matAlgo11xS0s(x, y, divideScalar, false);
        },
        'Array, any': function Array_any(x, y) {
            // use matrix implementation
            return matAlgo14xDs(matrix(x), y, divideScalar, false).valueOf();
        },
        'any, Array | Matrix': function any_Array__Matrix(x, y) {
            return multiply(x, inv(y));
        }
    }, divideScalar.signatures));
});
}}),

};

//# sourceMappingURL=node_modules_mathjs_lib_esm_function_arithmetic_fb478cff._.js.map