module.exports = {

"[project]/node_modules/firebase-functions/lib/common/trace.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractTraceContext = exports.traceContext = void 0;
const async_hooks_1 = __turbopack_context__.r("[externals]/async_hooks [external] (async_hooks, cjs)");
exports.traceContext = new async_hooks_1.AsyncLocalStorage();
/**
 * A regex to match the Cloud Trace header.
 *   - ([A-Fa-f0-9]{32}): The trace id, a 32 character hex value. (e.g. 4bf92f3577b34da6a3ce929d0e0e4736)
 *   - ([0-9]+): The parent span id, a 64 bit integer. (e.g. 00f067aa0ba902b7)
 *   - (?:;o=([0-3])): The trace mask, 1-3 denote it should be traced.
 */ const CLOUD_TRACE_REGEX = new RegExp("^(?<traceId>[A-Fa-f0-9]{32})/" + "(?<parentIdInt>[0-9]+)" + "(?:;o=(?<traceMask>[0-3]))?$");
const CLOUD_TRACE_HEADER = "X-Cloud-Trace-Context";
function matchCloudTraceHeader(carrier) {
    let header = carrier === null || carrier === void 0 ? void 0 : carrier[CLOUD_TRACE_HEADER];
    if (!header) {
        // try lowercase header
        header = carrier === null || carrier === void 0 ? void 0 : carrier[CLOUD_TRACE_HEADER.toLowerCase()];
    }
    if (header && typeof header === "string") {
        const matches = CLOUD_TRACE_REGEX.exec(header);
        if (matches && matches.groups) {
            const { traceId, parentIdInt, traceMask } = matches.groups;
            // Convert parentId from unsigned int to hex
            const parentId = parseInt(parentIdInt);
            if (isNaN(parentId)) {
                // Ignore traces with invalid parentIds
                return;
            }
            const sample = !!traceMask && traceMask !== "0";
            return {
                traceId,
                parentId: parentId.toString(16),
                sample,
                version: "00"
            };
        }
    }
}
/**
 * A regex to match the traceparent header.
 *   - ^([a-f0-9]{2}): The specification version (e.g. 00)
 *   - ([a-f0-9]{32}): The trace id, a 16-byte array. (e.g. 4bf92f3577b34da6a3ce929d0e0e4736)
 *   - ([a-f0-9]{16}): The parent span id, an 8-byte array. (e.g. 00f067aa0ba902b7)
 *   - ([a-f0-9]{2}: The sampled flag. (e.g. 00)
 */ const TRACEPARENT_REGEX = new RegExp("^(?<version>[a-f0-9]{2})-" + "(?<traceId>[a-f0-9]{32})-" + "(?<parentId>[a-f0-9]{16})-" + "(?<flag>[a-f0-9]{2})$");
const TRACEPARENT_HEADER = "traceparent";
function matchTraceparentHeader(carrier) {
    const header = carrier === null || carrier === void 0 ? void 0 : carrier[TRACEPARENT_HEADER];
    if (header && typeof header === "string") {
        const matches = TRACEPARENT_REGEX.exec(header);
        if (matches && matches.groups) {
            const { version, traceId, parentId, flag } = matches.groups;
            const sample = flag === "01";
            return {
                traceId,
                parentId,
                sample,
                version
            };
        }
    }
}
/**
 * Extracts trace context from given carrier object, if any.
 *
 * Supports Cloud Trace and traceparent format.
 *
 * @param carrier
 */ function extractTraceContext(carrier) {
    return matchCloudTraceHeader(carrier) || matchTraceparentHeader(carrier);
}
exports.extractTraceContext = extractTraceContext;
}}),
"[project]/node_modules/firebase-functions/lib/logger/common.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UNPATCHED_CONSOLE = exports.CONSOLE_SEVERITY = void 0;
// Map LogSeverity types to their equivalent `console.*` method.
/** @hidden */ exports.CONSOLE_SEVERITY = {
    DEBUG: "debug",
    INFO: "info",
    NOTICE: "info",
    WARNING: "warn",
    ERROR: "error",
    CRITICAL: "error",
    ALERT: "error",
    EMERGENCY: "error"
};
// safely preserve unpatched console.* methods in case of compat require
/** @hidden */ exports.UNPATCHED_CONSOLE = {
    debug: console.debug,
    info: console.info,
    log: console.log,
    warn: console.warn,
    error: console.error
};
}}),
"[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.error = exports.warn = exports.info = exports.log = exports.debug = exports.write = void 0;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const trace_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/trace.js [app-rsc] (ecmascript)");
const common_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/common.js [app-rsc] (ecmascript)");
/** @internal */ function removeCircular(obj, refs = []) {
    if (typeof obj !== "object" || !obj) {
        return obj;
    }
    // If the object defines its own toJSON, prefer that.
    if (obj.toJSON) {
        return obj.toJSON();
    }
    if (refs.includes(obj)) {
        return "[Circular]";
    } else {
        refs.push(obj);
    }
    let returnObj;
    if (Array.isArray(obj)) {
        returnObj = new Array(obj.length);
    } else {
        returnObj = {};
    }
    for(const k in obj){
        if (refs.includes(obj[k])) {
            returnObj[k] = "[Circular]";
        } else {
            returnObj[k] = removeCircular(obj[k], refs);
        }
    }
    refs.pop();
    return returnObj;
}
/**
 * Writes a `LogEntry` to `stdout`/`stderr` (depending on severity).
 * @param entry - The `LogEntry` including severity, message, and any additional structured metadata.
 * @public
 */ function write(entry) {
    const ctx = trace_1.traceContext.getStore();
    if (ctx === null || ctx === void 0 ? void 0 : ctx.traceId) {
        entry["logging.googleapis.com/trace"] = `projects/${process.env.GCLOUD_PROJECT}/traces/${ctx.traceId}`;
    }
    common_1.UNPATCHED_CONSOLE[common_1.CONSOLE_SEVERITY[entry.severity]](JSON.stringify(removeCircular(entry)));
}
exports.write = write;
/**
 * Writes a `DEBUG` severity log. If the last argument provided is a plain object,
 * it is added to the `jsonPayload` in the Cloud Logging entry.
 * @param args - Arguments, concatenated into the log message with space separators.
 * @public
 */ function debug(...args) {
    write(entryFromArgs("DEBUG", args));
}
exports.debug = debug;
/**
 * Writes an `INFO` severity log. If the last argument provided is a plain object,
 * it is added to the `jsonPayload` in the Cloud Logging entry.
 * @param args - Arguments, concatenated into the log message with space separators.
 * @public
 */ function log(...args) {
    write(entryFromArgs("INFO", args));
}
exports.log = log;
/**
 * Writes an `INFO` severity log. If the last argument provided is a plain object,
 * it is added to the `jsonPayload` in the Cloud Logging entry.
 * @param args - Arguments, concatenated into the log message with space separators.
 * @public
 */ function info(...args) {
    write(entryFromArgs("INFO", args));
}
exports.info = info;
/**
 * Writes a `WARNING` severity log. If the last argument provided is a plain object,
 * it is added to the `jsonPayload` in the Cloud Logging entry.
 * @param args - Arguments, concatenated into the log message with space separators.
 * @public
 */ function warn(...args) {
    write(entryFromArgs("WARNING", args));
}
exports.warn = warn;
/**
 * Writes an `ERROR` severity log. If the last argument provided is a plain object,
 * it is added to the `jsonPayload` in the Cloud Logging entry.
 * @param args - Arguments, concatenated into the log message with space separators.
 * @public
 */ function error(...args) {
    write(entryFromArgs("ERROR", args));
}
exports.error = error;
/** @hidden */ function entryFromArgs(severity, args) {
    let entry = {};
    const lastArg = args[args.length - 1];
    if (lastArg && typeof lastArg === "object" && lastArg.constructor === Object) {
        entry = args.pop();
    }
    // mimic `console.*` behavior, see https://nodejs.org/api/console.html#console_console_log_data_args
    let message = (0, util_1.format)(...args);
    if (severity === "ERROR" && !args.find((arg)=>arg instanceof Error)) {
        message = new Error(message).stack || message;
    }
    const out = {
        ...entry,
        severity
    };
    if (message) {
        out.message = message;
    }
    return out;
}
}}),
"[project]/node_modules/firebase-functions/lib/common/options.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RESET_VALUE = exports.ResetValue = void 0;
// The MIT License (MIT)
//
// Copyright (c) 2022 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
/**
 * Special configuration type to reset configuration to platform default.
 *
 * @alpha
 */ class ResetValue {
    toJSON() {
        return null;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor(){}
    static getInstance() {
        return new ResetValue();
    }
}
exports.ResetValue = ResetValue;
/**
 * Special configuration value to reset configuration to platform default.
 */ exports.RESET_VALUE = ResetValue.getInstance();
}}),
"[project]/node_modules/firebase-functions/lib/v1/function-configuration.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MAX_NUMBER_USER_LABELS = exports.DEFAULT_FAILURE_POLICY = exports.INGRESS_SETTINGS_OPTIONS = exports.VPC_EGRESS_SETTINGS_OPTIONS = exports.VALID_MEMORY_OPTIONS = exports.MAX_TIMEOUT_SECONDS = exports.MIN_TIMEOUT_SECONDS = exports.SUPPORTED_REGIONS = exports.RESET_VALUE = void 0;
var options_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/options.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "RESET_VALUE", {
    enumerable: true,
    get: function() {
        return options_1.RESET_VALUE;
    }
});
/**
 * List of all regions supported by Cloud Functions.
 */ exports.SUPPORTED_REGIONS = [
    "us-central1",
    "us-east1",
    "us-east4",
    "us-west2",
    "us-west3",
    "us-west4",
    "europe-central2",
    "europe-west1",
    "europe-west2",
    "europe-west3",
    "europe-west6",
    "asia-east1",
    "asia-east2",
    "asia-northeast1",
    "asia-northeast2",
    "asia-northeast3",
    "asia-south1",
    "asia-southeast1",
    "asia-southeast2",
    "northamerica-northeast1",
    "southamerica-east1",
    "australia-southeast1"
];
/**
 * Cloud Functions min timeout value.
 */ exports.MIN_TIMEOUT_SECONDS = 0;
/**
 * Cloud Functions max timeout value.
 */ exports.MAX_TIMEOUT_SECONDS = 540;
/**
 * List of available memory options supported by Cloud Functions.
 */ exports.VALID_MEMORY_OPTIONS = [
    "128MB",
    "256MB",
    "512MB",
    "1GB",
    "2GB",
    "4GB",
    "8GB"
];
/**
 * List of available options for VpcConnectorEgressSettings.
 */ exports.VPC_EGRESS_SETTINGS_OPTIONS = [
    "VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED",
    "PRIVATE_RANGES_ONLY",
    "ALL_TRAFFIC"
];
/**
 * List of available options for IngressSettings.
 */ exports.INGRESS_SETTINGS_OPTIONS = [
    "INGRESS_SETTINGS_UNSPECIFIED",
    "ALLOW_ALL",
    "ALLOW_INTERNAL_ONLY",
    "ALLOW_INTERNAL_AND_GCLB"
];
exports.DEFAULT_FAILURE_POLICY = {
    retry: {}
};
exports.MAX_NUMBER_USER_LABELS = 58;
}}),
"[project]/node_modules/firebase-functions/lib/params/types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2021 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListParam = exports.BooleanParam = exports.FloatParam = exports.IntParam = exports.InternalExpression = exports.StringParam = exports.SecretParam = exports.Param = exports.BUCKET_PICKER = exports.multiSelect = exports.select = exports.CompareExpression = exports.TernaryExpression = exports.Expression = void 0;
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
/*
 * A CEL expression which can be evaluated during function deployment, and
 * resolved to a value of the generic type parameter: i.e, you can pass
 * an Expression<number> as the value of an option that normally accepts numbers.
 */ class Expression {
    /** Returns the expression's runtime value, based on the CLI's resolution of parameters. */ value() {
        if (process.env.FUNCTIONS_CONTROL_API === "true") {
            logger.warn(`${this.toString()}.value() invoked during function deployment, instead of during runtime.`);
            logger.warn(`This is usually a mistake. In configs, use Params directly without calling .value().`);
            logger.warn(`example: { memory: memoryParam } not { memory: memoryParam.value() }`);
        }
        return this.runtimeValue();
    }
    /** @internal */ runtimeValue() {
        throw new Error("Not implemented");
    }
    /** Returns the expression's representation as a braced CEL expression. */ toCEL() {
        return `{{ ${this.toString()} }}`;
    }
    /** Returns the expression's representation as JSON. */ toJSON() {
        return this.toString();
    }
}
exports.Expression = Expression;
function valueOf(arg) {
    return arg instanceof Expression ? arg.runtimeValue() : arg;
}
/**
 * Returns how an entity (either an `Expression` or a literal value) should be represented in CEL.
 * - Expressions delegate to the `.toString()` method, which is used by the WireManifest
 * - Strings have to be quoted explicitly
 * - Arrays are represented as []-delimited, parsable JSON
 * - Numbers and booleans are not quoted explicitly
 */ function refOf(arg) {
    if (arg instanceof Expression) {
        return arg.toString();
    } else if (typeof arg === "string") {
        return `"${arg}"`;
    } else if (Array.isArray(arg)) {
        return JSON.stringify(arg);
    } else {
        return arg.toString();
    }
}
/**
 * A CEL expression corresponding to a ternary operator, e.g {{ cond ? ifTrue : ifFalse }}
 */ class TernaryExpression extends Expression {
    constructor(test, ifTrue, ifFalse){
        super();
        this.test = test;
        this.ifTrue = ifTrue;
        this.ifFalse = ifFalse;
        this.ifTrue = ifTrue;
        this.ifFalse = ifFalse;
    }
    /** @internal */ runtimeValue() {
        return this.test.runtimeValue() ? valueOf(this.ifTrue) : valueOf(this.ifFalse);
    }
    toString() {
        return `${this.test} ? ${refOf(this.ifTrue)} : ${refOf(this.ifFalse)}`;
    }
}
exports.TernaryExpression = TernaryExpression;
/**
 * A CEL expression that evaluates to boolean true or false based on a comparison
 * between the value of another expression and a literal of that same type.
 */ class CompareExpression extends Expression {
    constructor(cmp, lhs, rhs){
        super();
        this.cmp = cmp;
        this.lhs = lhs;
        this.rhs = rhs;
    }
    /** @internal */ runtimeValue() {
        const left = this.lhs.runtimeValue();
        const right = valueOf(this.rhs);
        switch(this.cmp){
            case "==":
                return Array.isArray(left) ? this.arrayEquals(left, right) : left === right;
            case "!=":
                return Array.isArray(left) ? !this.arrayEquals(left, right) : left !== right;
            case ">":
                return left > right;
            case ">=":
                return left >= right;
            case "<":
                return left < right;
            case "<=":
                return left <= right;
            default:
                throw new Error(`Unknown comparator ${this.cmp}`);
        }
    }
    /** @internal */ arrayEquals(a, b) {
        return a.every((item)=>b.includes(item)) && b.every((item)=>a.includes(item));
    }
    toString() {
        const rhsStr = refOf(this.rhs);
        return `${this.lhs} ${this.cmp} ${rhsStr}`;
    }
    /** Returns a `TernaryExpression` which can resolve to one of two values, based on the resolution of this comparison. */ thenElse(ifTrue, ifFalse) {
        return new TernaryExpression(this, ifTrue, ifFalse);
    }
}
exports.CompareExpression = CompareExpression;
/** Create a select input from a series of values or a map of labels to values */ function select(options) {
    let wireOpts;
    if (Array.isArray(options)) {
        wireOpts = options.map((opt)=>({
                value: opt
            }));
    } else {
        wireOpts = Object.entries(options).map(([label, value])=>({
                label,
                value
            }));
    }
    return {
        select: {
            options: wireOpts
        }
    };
}
exports.select = select;
/** Create a multi-select input from a series of values or map of labels to values. */ function multiSelect(options) {
    let wireOpts;
    if (Array.isArray(options)) {
        wireOpts = options.map((opt)=>({
                value: opt
            }));
    } else {
        wireOpts = Object.entries(options).map(([label, value])=>({
                label,
                value
            }));
    }
    return {
        multiSelect: {
            options: wireOpts
        }
    };
}
exports.multiSelect = multiSelect;
/**
 * Autogenerate a list of buckets in a project that a user can select from.
 */ exports.BUCKET_PICKER = {
    resource: {
        type: "storage.googleapis.com/Bucket"
    }
};
/**
 * Represents a parametrized value that will be read from .env files if present,
 * or prompted for by the CLI if missing. Instantiate these with the defineX
 * methods exported by the firebase-functions/params namespace.
 */ class Param extends Expression {
    constructor(name, options = {}){
        super();
        this.name = name;
        this.options = options;
    }
    /** @internal */ runtimeValue() {
        throw new Error("Not implemented");
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ cmp(cmp, rhs) {
        return new CompareExpression(cmp, this, rhs);
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ equals(rhs) {
        return this.cmp("==", rhs);
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ notEquals(rhs) {
        return this.cmp("!=", rhs);
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ greaterThan(rhs) {
        return this.cmp(">", rhs);
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ greaterThanOrEqualTo(rhs) {
        return this.cmp(">=", rhs);
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ lessThan(rhs) {
        return this.cmp("<", rhs);
    }
    /** Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression. */ lessThanOrEqualTo(rhs) {
        return this.cmp("<=", rhs);
    }
    /**
     * Returns a parametrized expression of Boolean type, based on comparing the value of this parameter to a literal or a different expression.
     * @deprecated A typo. Use lessThanOrEqualTo instead.
     */ lessThanorEqualTo(rhs) {
        return this.lessThanOrEqualTo(rhs);
    }
    toString() {
        return `params.${this.name}`;
    }
    /** @internal */ toSpec() {
        const { default: paramDefault, ...otherOptions } = this.options;
        const out = {
            name: this.name,
            ...otherOptions,
            type: this.constructor.type
        };
        if (paramDefault instanceof Expression) {
            out.default = paramDefault.toCEL();
        } else if (paramDefault !== undefined) {
            out.default = paramDefault;
        }
        if (out.input && "text" in out.input && out.input.text.validationRegex instanceof RegExp) {
            out.input.text.validationRegex = out.input.text.validationRegex.source;
        }
        return out;
    }
}
exports.Param = Param;
Param.type = "string";
/**
 * A parametrized string whose value is stored in Cloud Secret Manager
 * instead of the local filesystem. Supply instances of SecretParams to
 * the secrets array while defining a Function to make their values accessible
 * during execution of that Function.
 */ class SecretParam {
    constructor(name){
        this.name = name;
    }
    /** @internal */ runtimeValue() {
        const val = process.env[this.name];
        if (val === undefined) {
            logger.warn(`No value found for secret parameter "${this.name}". A function can only access a secret if you include the secret in the function's dependency array.`);
        }
        return val || "";
    }
    /** @internal */ toSpec() {
        return {
            type: "secret",
            name: this.name
        };
    }
    /** Returns the secret's value at runtime. Throws an error if accessed during deployment. */ value() {
        if (process.env.FUNCTIONS_CONTROL_API === "true") {
            throw new Error(`Cannot access the value of secret "${this.name}" during function deployment. Secret values are only available at runtime.`);
        }
        return this.runtimeValue();
    }
}
exports.SecretParam = SecretParam;
SecretParam.type = "secret";
/**
 *  A parametrized value of String type that will be read from .env files
 *  if present, or prompted for by the CLI if missing.
 */ class StringParam extends Param {
    /** @internal */ runtimeValue() {
        return process.env[this.name] || "";
    }
}
exports.StringParam = StringParam;
/**
 * A CEL expression which represents an internal Firebase variable. This class
 * cannot be instantiated by developers, but we provide several canned instances
 * of it to make available parameters that will never have to be defined at
 * deployment time, and can always be read from process.env.
 * @internal
 */ class InternalExpression extends Param {
    constructor(name, getter){
        super(name);
        this.getter = getter;
    }
    /** @internal */ runtimeValue() {
        return this.getter(process.env) || "";
    }
    toSpec() {
        throw new Error("An InternalExpression should never be marshalled for wire transmission.");
    }
}
exports.InternalExpression = InternalExpression;
/**
 *  A parametrized value of Integer type that will be read from .env files
 *  if present, or prompted for by the CLI if missing.
 */ class IntParam extends Param {
    /** @internal */ runtimeValue() {
        return parseInt(process.env[this.name] || "0", 10) || 0;
    }
}
exports.IntParam = IntParam;
IntParam.type = "int";
/**
 *  A parametrized value of Float type that will be read from .env files
 *  if present, or prompted for by the CLI if missing.
 */ class FloatParam extends Param {
    /** @internal */ runtimeValue() {
        return parseFloat(process.env[this.name] || "0") || 0;
    }
}
exports.FloatParam = FloatParam;
FloatParam.type = "float";
/**
 *  A parametrized value of Boolean type that will be read from .env files
 *  if present, or prompted for by the CLI if missing.
 */ class BooleanParam extends Param {
    /** @internal */ runtimeValue() {
        return !!process.env[this.name] && process.env[this.name] === "true";
    }
    /** @deprecated */ then(ifTrue, ifFalse) {
        return this.thenElse(ifTrue, ifFalse);
    }
    thenElse(ifTrue, ifFalse) {
        return new TernaryExpression(this, ifTrue, ifFalse);
    }
}
exports.BooleanParam = BooleanParam;
BooleanParam.type = "boolean";
/**
 *  A parametrized value of String[] type that will be read from .env files
 *  if present, or prompted for by the CLI if missing.
 */ class ListParam extends Param {
    /** @internal */ runtimeValue() {
        const val = JSON.parse(process.env[this.name]);
        if (!Array.isArray(val) || !val.every((v)=>typeof v === "string")) {
            return [];
        }
        return val;
    }
    /** @hidden */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    greaterThan(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
    }
    /** @hidden */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    greaterThanOrEqualTo(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
    }
    /** @hidden */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    lessThan(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
    }
    /** @hidden */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    lessThanorEqualTo(rhs) {
        throw new Error(">/< comparison operators not supported on params of type List");
    }
}
exports.ListParam = ListParam;
ListParam.type = "list";
}}),
"[project]/node_modules/firebase-functions/lib/params/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2021 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defineList = exports.defineFloat = exports.defineInt = exports.defineBoolean = exports.defineString = exports.defineSecret = exports.storageBucket = exports.gcloudProject = exports.projectID = exports.databaseURL = exports.clearParams = exports.declaredParams = exports.Expression = exports.multiSelect = exports.select = exports.BUCKET_PICKER = void 0;
/**
 * @hidden
 * @alpha
 */ const types_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/types.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Expression", {
    enumerable: true,
    get: function() {
        return types_1.Expression;
    }
});
var types_2 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/types.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "BUCKET_PICKER", {
    enumerable: true,
    get: function() {
        return types_2.BUCKET_PICKER;
    }
});
Object.defineProperty(exports, "select", {
    enumerable: true,
    get: function() {
        return types_2.select;
    }
});
Object.defineProperty(exports, "multiSelect", {
    enumerable: true,
    get: function() {
        return types_2.multiSelect;
    }
});
exports.declaredParams = [];
/**
 * Use a helper to manage the list such that parameters are uniquely
 * registered once only but order is preserved.
 * @internal
 */ function registerParam(param) {
    for(let i = 0; i < exports.declaredParams.length; i++){
        if (exports.declaredParams[i].name === param.name) {
            exports.declaredParams.splice(i, 1);
        }
    }
    exports.declaredParams.push(param);
}
/**
 * For testing.
 * @internal
 */ function clearParams() {
    exports.declaredParams.splice(0, exports.declaredParams.length);
}
exports.clearParams = clearParams;
/**
 * A built-in parameter that resolves to the default RTDB database URL associated
 * with the project, without prompting the deployer. Empty string if none exists.
 */ exports.databaseURL = new types_1.InternalExpression("DATABASE_URL", (env)=>{
    var _a;
    return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.databaseURL) || "";
});
/**
 * A built-in parameter that resolves to the Cloud project ID associated with
 * the project, without prompting the deployer.
 */ exports.projectID = new types_1.InternalExpression("PROJECT_ID", (env)=>{
    var _a;
    return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.projectId) || "";
});
/**
 * A built-in parameter that resolves to the Cloud project ID, without prompting
 * the deployer.
 */ exports.gcloudProject = new types_1.InternalExpression("GCLOUD_PROJECT", (env)=>{
    var _a;
    return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.projectId) || "";
});
/**
 * A builtin parameter that resolves to the Cloud storage bucket associated
 * with the function, without prompting the deployer. Empty string if not
 * defined.
 */ exports.storageBucket = new types_1.InternalExpression("STORAGE_BUCKET", (env)=>{
    var _a;
    return ((_a = JSON.parse(env.FIREBASE_CONFIG)) === null || _a === void 0 ? void 0 : _a.storageBucket) || "";
});
/**
 * Declares a secret param, that will persist values only in Cloud Secret Manager.
 * Secrets are stored internally as bytestrings. Use `ParamOptions.as` to provide type
 * hinting during parameter resolution.
 *
 * @param name The name of the environment variable to use to load the parameter.
 * @returns A parameter with a `string` return type for `.value`.
 */ function defineSecret(name) {
    const param = new types_1.SecretParam(name);
    registerParam(param);
    return param;
}
exports.defineSecret = defineSecret;
/**
 * Declare a string parameter.
 *
 * @param name The name of the environment variable to use to load the parameter.
 * @param options Configuration options for the parameter.
 * @returns A parameter with a `string` return type for `.value`.
 */ function defineString(name, options = {}) {
    const param = new types_1.StringParam(name, options);
    registerParam(param);
    return param;
}
exports.defineString = defineString;
/**
 * Declare a boolean parameter.
 *
 * @param name The name of the environment variable to use to load the parameter.
 * @param options Configuration options for the parameter.
 * @returns A parameter with a `boolean` return type for `.value`.
 */ function defineBoolean(name, options = {}) {
    const param = new types_1.BooleanParam(name, options);
    registerParam(param);
    return param;
}
exports.defineBoolean = defineBoolean;
/**
 * Declare an integer parameter.
 *
 * @param name The name of the environment variable to use to load the parameter.
 * @param options Configuration options for the parameter.
 * @returns A parameter with a `number` return type for `.value`.
 */ function defineInt(name, options = {}) {
    const param = new types_1.IntParam(name, options);
    registerParam(param);
    return param;
}
exports.defineInt = defineInt;
/**
 * Declare a float parameter.
 *
 * @param name The name of the environment variable to use to load the parameter.
 * @param options Configuration options for the parameter.
 * @returns A parameter with a `number` return type for `.value`.
 *
 * @internal
 */ function defineFloat(name, options = {}) {
    const param = new types_1.FloatParam(name, options);
    registerParam(param);
    return param;
}
exports.defineFloat = defineFloat;
/**
 * Declare a list parameter.
 *
 * @param name The name of the environment variable to use to load the parameter.
 * @param options Configuration options for the parameter.
 * @returns A parameter with a `string[]` return type for `.value`.
 */ function defineList(name, options = {}) {
    const param = new types_1.ListParam(name, options);
    registerParam(param);
    return param;
}
exports.defineList = defineList;
}}),
"[project]/node_modules/firebase-functions/lib/common/encoding.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2021 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertInvoker = exports.serviceAccountFromShorthand = exports.convertIfPresent = exports.copyIfPresent = exports.durationFromSeconds = void 0;
const params_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/index.js [app-rsc] (ecmascript)");
/** Get a google.protobuf.Duration for a number of seconds. */ function durationFromSeconds(s) {
    return `${s}s`;
}
exports.durationFromSeconds = durationFromSeconds;
/**
 * Utility function to help copy fields from type A to B.
 * As a safety net, catches typos or fields that aren't named the same
 * in A and B, but cannot verify that both Src and Dest have the same type for the same field.
 */ function copyIfPresent(dest, src, ...fields) {
    if (!src) {
        return;
    }
    for (const field of fields){
        if (!Object.prototype.hasOwnProperty.call(src, field)) {
            continue;
        }
        dest[field] = src[field];
    }
}
exports.copyIfPresent = copyIfPresent;
function convertIfPresent(dest, src, destField, srcField, converter = (from)=>{
    return from;
}) {
    if (!src) {
        return;
    }
    if (!Object.prototype.hasOwnProperty.call(src, srcField)) {
        return;
    }
    dest[destField] = converter(src[srcField]);
}
exports.convertIfPresent = convertIfPresent;
function serviceAccountFromShorthand(serviceAccount) {
    if (serviceAccount === "default") {
        return null;
    } else if (serviceAccount instanceof params_1.Expression) {
        return serviceAccount;
    } else if (serviceAccount.endsWith("@")) {
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error(`Unable to determine email for service account '${serviceAccount}' because process.env.GCLOUD_PROJECT is not set.`);
        }
        return `${serviceAccount}${process.env.GCLOUD_PROJECT}.iam.gserviceaccount.com`;
    } else if (serviceAccount.includes("@")) {
        return serviceAccount;
    } else {
        throw new Error(`Invalid option for serviceAccount: '${serviceAccount}'. Valid options are 'default', a service account email, or '{serviceAccountName}@'`);
    }
}
exports.serviceAccountFromShorthand = serviceAccountFromShorthand;
function convertInvoker(invoker) {
    if (typeof invoker === "string") {
        invoker = [
            invoker
        ];
    }
    if (invoker.length === 0) {
        throw new Error("Invalid option for invoker: Must be a non-empty array.");
    }
    if (invoker.find((inv)=>inv.length === 0)) {
        throw new Error("Invalid option for invoker: Must be a non-empty string.");
    }
    if (invoker.length > 1 && invoker.find((inv)=>inv === "public" || inv === "private")) {
        throw new Error("Invalid option for invoker: Cannot have 'public' or 'private' in an array of service accounts.");
    }
    return invoker;
}
exports.convertInvoker = convertInvoker;
}}),
"[project]/node_modules/firebase-functions/lib/runtime/manifest.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2021 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.initV2ScheduleTrigger = exports.initV1ScheduleTrigger = exports.initTaskQueueTrigger = exports.initV2Endpoint = exports.initV1Endpoint = exports.stackToWire = void 0;
const options_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/options.js [app-rsc] (ecmascript)");
const params_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/index.js [app-rsc] (ecmascript)");
/**
 * Returns the JSON representation of a ManifestStack, which has CEL
 * expressions in its options as object types, with its expressions
 * transformed into the actual CEL strings.
 *
 * @alpha
 */ function stackToWire(stack) {
    const wireStack = stack;
    const traverse = function traverse(obj) {
        for (const [key, val] of Object.entries(obj)){
            if (val instanceof params_1.Expression) {
                obj[key] = val.toCEL();
            } else if (val instanceof options_1.ResetValue) {
                obj[key] = val.toJSON();
            } else if (typeof val === "object" && val !== null) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                traverse(val);
            }
        }
    };
    traverse(wireStack.endpoints);
    return wireStack;
}
exports.stackToWire = stackToWire;
const RESETTABLE_OPTIONS = {
    availableMemoryMb: null,
    timeoutSeconds: null,
    minInstances: null,
    maxInstances: null,
    ingressSettings: null,
    concurrency: null,
    serviceAccountEmail: null,
    vpc: null
};
function initEndpoint(resetOptions, ...opts) {
    const endpoint = {};
    if (opts.every((opt)=>!(opt === null || opt === void 0 ? void 0 : opt.preserveExternalChanges))) {
        for (const key of Object.keys(resetOptions)){
            endpoint[key] = options_1.RESET_VALUE;
        }
    }
    return endpoint;
}
/**
 * @internal
 */ function initV1Endpoint(...opts) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { concurrency, ...resetOpts } = RESETTABLE_OPTIONS;
    return initEndpoint({
        ...resetOpts
    }, ...opts);
}
exports.initV1Endpoint = initV1Endpoint;
/**
 * @internal
 */ function initV2Endpoint(...opts) {
    return initEndpoint(RESETTABLE_OPTIONS, ...opts);
}
exports.initV2Endpoint = initV2Endpoint;
const RESETTABLE_RETRY_CONFIG_OPTIONS = {
    maxAttempts: null,
    maxDoublings: null,
    maxBackoffSeconds: null,
    maxRetrySeconds: null,
    minBackoffSeconds: null
};
const RESETTABLE_RATE_LIMITS_OPTIONS = {
    maxConcurrentDispatches: null,
    maxDispatchesPerSecond: null
};
/**
 * @internal
 */ function initTaskQueueTrigger(...opts) {
    const taskQueueTrigger = {
        retryConfig: {},
        rateLimits: {}
    };
    if (opts.every((opt)=>!(opt === null || opt === void 0 ? void 0 : opt.preserveExternalChanges))) {
        for (const key of Object.keys(RESETTABLE_RETRY_CONFIG_OPTIONS)){
            taskQueueTrigger.retryConfig[key] = options_1.RESET_VALUE;
        }
        for (const key of Object.keys(RESETTABLE_RATE_LIMITS_OPTIONS)){
            taskQueueTrigger.rateLimits[key] = options_1.RESET_VALUE;
        }
    }
    return taskQueueTrigger;
}
exports.initTaskQueueTrigger = initTaskQueueTrigger;
const RESETTABLE_V1_SCHEDULE_OPTIONS = {
    retryCount: null,
    maxDoublings: null,
    maxRetryDuration: null,
    maxBackoffDuration: null,
    minBackoffDuration: null
};
const RESETTABLE_V2_SCHEDULE_OPTIONS = {
    retryCount: null,
    maxDoublings: null,
    maxRetrySeconds: null,
    minBackoffSeconds: null,
    maxBackoffSeconds: null
};
function initScheduleTrigger(resetOptions, schedule, ...opts) {
    let scheduleTrigger = {
        schedule,
        retryConfig: {}
    };
    if (opts.every((opt)=>!(opt === null || opt === void 0 ? void 0 : opt.preserveExternalChanges))) {
        for (const key of Object.keys(resetOptions)){
            scheduleTrigger.retryConfig[key] = options_1.RESET_VALUE;
        }
        scheduleTrigger = {
            ...scheduleTrigger,
            timeZone: options_1.RESET_VALUE
        };
    }
    return scheduleTrigger;
}
/**
 * @internal
 */ function initV1ScheduleTrigger(schedule, ...opts) {
    return initScheduleTrigger(RESETTABLE_V1_SCHEDULE_OPTIONS, schedule, ...opts);
}
exports.initV1ScheduleTrigger = initV1ScheduleTrigger;
/**
 * @internal
 */ function initV2ScheduleTrigger(schedule, ...opts) {
    return initScheduleTrigger(RESETTABLE_V2_SCHEDULE_OPTIONS, schedule, ...opts);
}
exports.initV2ScheduleTrigger = initV2ScheduleTrigger;
}}),
"[project]/node_modules/firebase-functions/lib/common/onInit.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withInit = exports.onInit = void 0;
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
let initCallback = null;
let didInit = false;
/**
 * Registers a callback that should be run when in a production environment
 * before executing any functions code.
 * Calling this function more than once leads to undefined behavior.
 * @param callback initialization callback to be run before any function executes.
 */ function onInit(callback) {
    if (initCallback) {
        logger.warn("Setting onInit callback more than once. Only the most recent callback will be called");
    }
    initCallback = callback;
    didInit = false;
}
exports.onInit = onInit;
/** @internal */ function withInit(func) {
    return async (...args)=>{
        if (!didInit) {
            if (initCallback) {
                await initCallback();
            }
            didInit = true;
        }
        // Note: This cast is actually inaccurate because it may be a promise, but
        // it doesn't actually matter because the async function will promisify
        // non-promises and forward promises.
        return func(...args);
    };
}
exports.withInit = withInit;
}}),
"[project]/node_modules/firebase-functions/lib/common/change.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2022 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Change = exports.applyFieldMask = void 0;
/** @internal */ function applyFieldMask(sparseBefore, after, fieldMask) {
    const before = {
        ...after
    };
    const masks = fieldMask.split(",");
    for (const mask of masks){
        const parts = mask.split(".");
        const head = parts[0];
        const tail = parts.slice(1).join(".");
        if (parts.length > 1) {
            before[head] = applyFieldMask(sparseBefore === null || sparseBefore === void 0 ? void 0 : sparseBefore[head], after[head], tail);
            continue;
        }
        const val = sparseBefore === null || sparseBefore === void 0 ? void 0 : sparseBefore[head];
        if (typeof val === "undefined") {
            delete before[mask];
        } else {
            before[mask] = val;
        }
    }
    return before;
}
exports.applyFieldMask = applyFieldMask;
/**
 * The Cloud Functions interface for events that change state, such as
 * Realtime Database or Cloud Firestore `onWrite` and `onUpdate` events.
 *
 * For more information about the format used to construct `Change` objects, see
 * {@link ChangeJson} below.
 *
 */ class Change {
    /**
     * Factory method for creating a `Change` from a `before` object and an `after`
     * object.
     */ static fromObjects(before, after) {
        return new Change(before, after);
    }
    /**
     * Factory method for creating a `Change` from JSON and an optional customizer
     * function to be applied to both the `before` and the `after` fields.
     */ static fromJSON(json, customizer = (x)=>x) {
        let before = {
            ...json.before
        };
        if (json.fieldMask) {
            before = applyFieldMask(before, json.after, json.fieldMask);
        }
        return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));
    }
    constructor(before, after){
        this.before = before;
        this.after = after;
    }
}
exports.Change = Change;
}}),
"[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.optionsToEndpoint = exports.optionsToTrigger = exports.makeCloudFunction = exports.Change = void 0;
const logger_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
const function_configuration_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/function-configuration.js [app-rsc] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/encoding.js [app-rsc] (ecmascript)");
const manifest_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/runtime/manifest.js [app-rsc] (ecmascript)");
const options_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/options.js [app-rsc] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/types.js [app-rsc] (ecmascript)");
const onInit_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/onInit.js [app-rsc] (ecmascript)");
var change_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/change.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Change", {
    enumerable: true,
    get: function() {
        return change_1.Change;
    }
});
/** @internal */ const WILDCARD_REGEX = new RegExp("{[^/{}]*}", "g");
/** @internal */ function makeCloudFunction({ contextOnlyHandler, dataConstructor = (raw)=>raw.data, eventType, handler, labels = {}, legacyEventType, options = {}, provider, service, triggerResource }) {
    handler = (0, onInit_1.withInit)(handler !== null && handler !== void 0 ? handler : contextOnlyHandler);
    const cloudFunction = (data, context)=>{
        if (legacyEventType && context.eventType === legacyEventType) {
            /*
             * v1beta1 event flow has different format for context, transform them to
             * new format.
             */ context.eventType = provider + "." + eventType;
            context.resource = {
                service,
                name: context.resource
            };
        }
        const event = {
            data,
            context
        };
        if (provider === "google.firebase.database") {
            context.authType = _detectAuthType(event);
            if (context.authType !== "ADMIN") {
                context.auth = _makeAuth(event, context.authType);
            } else {
                delete context.auth;
            }
        }
        if (triggerResource() == null) {
            Object.defineProperty(context, "params", {
                get: ()=>{
                    throw new Error("context.params is not available when using the handler namespace.");
                }
            });
        } else {
            context.params = context.params || _makeParams(context, triggerResource);
        }
        let promise;
        if (labels && labels["deployment-scheduled"]) {
            // Scheduled function do not have meaningful data, so exclude it
            promise = contextOnlyHandler(context);
        } else {
            const dataOrChange = dataConstructor(event);
            promise = handler(dataOrChange, context);
        }
        if (typeof promise === "undefined") {
            (0, logger_1.warn)("Function returned undefined, expected Promise or value");
        }
        return Promise.resolve(promise);
    };
    Object.defineProperty(cloudFunction, "__trigger", {
        get: ()=>{
            if (triggerResource() == null) {
                return {};
            }
            const trigger = {
                ...optionsToTrigger(options),
                eventTrigger: {
                    resource: triggerResource(),
                    eventType: legacyEventType || provider + "." + eventType,
                    service
                }
            };
            if (!!labels && Object.keys(labels).length) {
                trigger.labels = {
                    ...trigger.labels,
                    ...labels
                };
            }
            return trigger;
        }
    });
    Object.defineProperty(cloudFunction, "__endpoint", {
        get: ()=>{
            if (triggerResource() == null) {
                return undefined;
            }
            const endpoint = {
                platform: "gcfv1",
                ...(0, manifest_1.initV1Endpoint)(options),
                ...optionsToEndpoint(options)
            };
            if (options.schedule) {
                endpoint.scheduleTrigger = (0, manifest_1.initV1ScheduleTrigger)(options.schedule.schedule, options);
                (0, encoding_1.copyIfPresent)(endpoint.scheduleTrigger, options.schedule, "timeZone");
                (0, encoding_1.copyIfPresent)(endpoint.scheduleTrigger.retryConfig, options.schedule.retryConfig, "retryCount", "maxDoublings", "maxBackoffDuration", "maxRetryDuration", "minBackoffDuration");
            } else {
                endpoint.eventTrigger = {
                    eventType: legacyEventType || provider + "." + eventType,
                    eventFilters: {
                        resource: triggerResource()
                    },
                    retry: !!options.failurePolicy
                };
            }
            // Note: We intentionally don't make use of labels args here.
            // labels is used to pass SDK-defined labels to the trigger, which isn't
            // something we will do in the container contract world.
            endpoint.labels = {
                ...endpoint.labels
            };
            return endpoint;
        }
    });
    if (options.schedule) {
        cloudFunction.__requiredAPIs = [
            {
                api: "cloudscheduler.googleapis.com",
                reason: "Needed for scheduled functions."
            }
        ];
    }
    cloudFunction.run = handler || contextOnlyHandler;
    return cloudFunction;
}
exports.makeCloudFunction = makeCloudFunction;
function _makeParams(context, triggerResourceGetter) {
    var _a, _b, _c;
    if (context.params) {
        // In unit testing, user may directly provide `context.params`.
        return context.params;
    }
    if (!context.resource) {
        // In unit testing, `resource` may be unpopulated for a test event.
        return {};
    }
    const triggerResource = triggerResourceGetter();
    const wildcards = triggerResource.match(WILDCARD_REGEX);
    const params = {};
    // Note: some tests don't set context.resource.name
    const eventResourceParts = (_c = (_b = (_a = context === null || context === void 0 ? void 0 : context.resource) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.split) === null || _c === void 0 ? void 0 : _c.call(_b, "/");
    if (wildcards && eventResourceParts) {
        const triggerResourceParts = triggerResource.split("/");
        for (const wildcard of wildcards){
            const wildcardNoBraces = wildcard.slice(1, -1);
            const position = triggerResourceParts.indexOf(wildcard);
            params[wildcardNoBraces] = eventResourceParts[position];
        }
    }
    return params;
}
function _makeAuth(event, authType) {
    var _a, _b, _c, _d, _e, _f;
    if (authType === "UNAUTHENTICATED") {
        return null;
    }
    return {
        uid: (_c = (_b = (_a = event.context) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.variable) === null || _c === void 0 ? void 0 : _c.uid,
        token: (_f = (_e = (_d = event.context) === null || _d === void 0 ? void 0 : _d.auth) === null || _e === void 0 ? void 0 : _e.variable) === null || _f === void 0 ? void 0 : _f.token
    };
}
function _detectAuthType(event) {
    var _a, _b, _c, _d;
    if ((_b = (_a = event.context) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.admin) {
        return "ADMIN";
    }
    if ((_d = (_c = event.context) === null || _c === void 0 ? void 0 : _c.auth) === null || _d === void 0 ? void 0 : _d.variable) {
        return "USER";
    }
    return "UNAUTHENTICATED";
}
/** @hidden */ function optionsToTrigger(options) {
    const trigger = {};
    (0, encoding_1.copyIfPresent)(trigger, options, "regions", "schedule", "minInstances", "maxInstances", "ingressSettings", "vpcConnectorEgressSettings", "vpcConnector", "labels", "secrets");
    (0, encoding_1.convertIfPresent)(trigger, options, "failurePolicy", "failurePolicy", (policy)=>{
        if (policy === false) {
            return undefined;
        } else if (policy === true) {
            return function_configuration_1.DEFAULT_FAILURE_POLICY;
        } else {
            return policy;
        }
    });
    (0, encoding_1.convertIfPresent)(trigger, options, "timeout", "timeoutSeconds", encoding_1.durationFromSeconds);
    (0, encoding_1.convertIfPresent)(trigger, options, "availableMemoryMb", "memory", (mem)=>{
        const memoryLookup = {
            "128MB": 128,
            "256MB": 256,
            "512MB": 512,
            "1GB": 1024,
            "2GB": 2048,
            "4GB": 4096,
            "8GB": 8192
        };
        return memoryLookup[mem];
    });
    (0, encoding_1.convertIfPresent)(trigger, options, "serviceAccountEmail", "serviceAccount", encoding_1.serviceAccountFromShorthand);
    return trigger;
}
exports.optionsToTrigger = optionsToTrigger;
function optionsToEndpoint(options) {
    const endpoint = {};
    (0, encoding_1.copyIfPresent)(endpoint, options, "omit", "minInstances", "maxInstances", "ingressSettings", "labels", "timeoutSeconds");
    (0, encoding_1.convertIfPresent)(endpoint, options, "region", "regions");
    (0, encoding_1.convertIfPresent)(endpoint, options, "serviceAccountEmail", "serviceAccount", (sa)=>sa);
    (0, encoding_1.convertIfPresent)(endpoint, options, "secretEnvironmentVariables", "secrets", (secrets)=>secrets.map((secret)=>({
                key: secret instanceof types_1.SecretParam ? secret.name : secret
            })));
    if ((options === null || options === void 0 ? void 0 : options.vpcConnector) !== undefined) {
        if (options.vpcConnector === null || options.vpcConnector instanceof options_1.ResetValue) {
            endpoint.vpc = function_configuration_1.RESET_VALUE;
        } else {
            const vpc = {
                connector: options.vpcConnector
            };
            (0, encoding_1.convertIfPresent)(vpc, options, "egressSettings", "vpcConnectorEgressSettings");
            endpoint.vpc = vpc;
        }
    }
    (0, encoding_1.convertIfPresent)(endpoint, options, "availableMemoryMb", "memory", (mem)=>{
        const memoryLookup = {
            "128MB": 128,
            "256MB": 256,
            "512MB": 512,
            "1GB": 1024,
            "2GB": 2048,
            "4GB": 4096,
            "8GB": 8192
        };
        return typeof mem === "object" ? mem : memoryLookup[mem];
    });
    return endpoint;
}
exports.optionsToEndpoint = optionsToEndpoint;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/analytics.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExportBundleInfo = exports.UserPropertyValue = exports.UserDimensions = exports.AnalyticsEvent = exports.AnalyticsEventBuilder = exports._eventWithOptions = exports.event = exports.service = exports.provider = void 0;
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.analytics";
/** @internal */ exports.service = "app-measurement.com";
/**
 * Registers a function to handle analytics events.
 *
 * @param analyticsEventType Name of the analytics event type to which
 *   this Cloud Function is scoped.
 *
 * @returns Analytics event builder interface.
 */ function event(analyticsEventType) {
    return _eventWithOptions(analyticsEventType, {});
}
exports.event = event;
/** @internal */ function _eventWithOptions(analyticsEventType, options) {
    return new AnalyticsEventBuilder(()=>{
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error("process.env.GCLOUD_PROJECT is not set.");
        }
        return "projects/" + process.env.GCLOUD_PROJECT + "/events/" + analyticsEventType;
    }, options);
}
exports._eventWithOptions = _eventWithOptions;
/**
 * The Firebase Analytics event builder interface.
 *
 * Access via `functions.analytics.event()`.
 */ class AnalyticsEventBuilder {
    /** @hidden */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    /**
     * Event handler that fires every time a Firebase Analytics event occurs.
     *
     * @param handler Event handler that fires every time a Firebase Analytics event
     *   occurs.
     *
     * @returns A function that you can export and deploy.
     */ onLog(handler) {
        const dataConstructor = (raw)=>{
            return new AnalyticsEvent(raw.data);
        };
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            eventType: "event.log",
            service: exports.service,
            legacyEventType: `providers/google.firebase.analytics/eventTypes/event.log`,
            triggerResource: this.triggerResource,
            dataConstructor,
            options: this.options
        });
    }
}
exports.AnalyticsEventBuilder = AnalyticsEventBuilder;
/** Interface representing a Firebase Analytics event that was logged for a specific user. */ class AnalyticsEvent {
    /** @hidden */ constructor(wireFormat){
        this.params = {}; // In case of absent field, show empty (not absent) map.
        if (wireFormat.eventDim && wireFormat.eventDim.length > 0) {
            // If there's an eventDim, there'll always be exactly one.
            const eventDim = wireFormat.eventDim[0];
            copyField(eventDim, this, "name");
            copyField(eventDim, this, "params", (p)=>mapKeys(p, unwrapValue));
            copyFieldTo(eventDim, this, "valueInUsd", "valueInUSD");
            copyFieldTo(eventDim, this, "date", "reportingDate");
            copyTimestampToString(eventDim, this, "timestampMicros", "logTime");
            copyTimestampToString(eventDim, this, "previousTimestampMicros", "previousLogTime");
        }
        copyFieldTo(wireFormat, this, "userDim", "user", (dim)=>new UserDimensions(dim));
    }
}
exports.AnalyticsEvent = AnalyticsEvent;
/**
 * Interface representing the user who triggered the events.
 */ class UserDimensions {
    /** @hidden */ constructor(wireFormat){
        // These are interfaces or primitives, no transformation needed.
        copyFields(wireFormat, this, [
            "userId",
            "deviceInfo",
            "geoInfo",
            "appInfo"
        ]);
        // The following fields do need transformations of some sort.
        copyTimestampToString(wireFormat, this, "firstOpenTimestampMicros", "firstOpenTime");
        this.userProperties = {}; // With no entries in the wire format, present an empty (as opposed to absent) map.
        copyField(wireFormat, this, "userProperties", (r)=>{
            const entries = Object.entries(r).map(([k, v])=>[
                    k,
                    new UserPropertyValue(v)
                ]);
            return Object.fromEntries(entries);
        });
        copyField(wireFormat, this, "bundleInfo", (r)=>new ExportBundleInfo(r));
        // BUG(36000368) Remove when no longer necessary
        /* tslint:disable:no-string-literal */ if (!this.userId && this.userProperties["user_id"]) {
            this.userId = this.userProperties["user_id"].value;
        }
    /* tslint:enable:no-string-literal */ }
}
exports.UserDimensions = UserDimensions;
/** Predefined or custom properties stored on the client side. */ class UserPropertyValue {
    /** @hidden */ constructor(wireFormat){
        copyField(wireFormat, this, "value", unwrapValueAsString);
        copyTimestampToString(wireFormat, this, "setTimestampUsec", "setTime");
    }
}
exports.UserPropertyValue = UserPropertyValue;
/** Interface representing the bundle these events were uploaded to. */ class ExportBundleInfo {
    /** @hidden */ constructor(wireFormat){
        copyField(wireFormat, this, "bundleSequenceId");
        copyTimestampToMillis(wireFormat, this, "serverTimestampOffsetMicros", "serverTimestampOffset");
    }
}
exports.ExportBundleInfo = ExportBundleInfo;
/** @hidden */ function copyFieldTo(from, to, fromField, toField, transform) {
    if (typeof from[fromField] === "undefined") {
        return;
    }
    if (transform) {
        to[toField] = transform(from[fromField]);
        return;
    }
    to[toField] = from[fromField];
}
/** @hidden */ function copyField(from, to, field, transform = (from)=>from) {
    copyFieldTo(from, to, field, field, transform);
}
/** @hidden */ function copyFields(from, to, fields) {
    for (const field of fields){
        copyField(from, to, field);
    }
}
function mapKeys(obj, transform) {
    const entries = Object.entries(obj).map(([k, v])=>[
            k,
            transform(v)
        ]);
    return Object.fromEntries(entries);
}
// The incoming payload will have fields like:
// {
//   'myInt': {
//     'intValue': '123'
//   },
//   'myDouble': {
//     'doubleValue': 1.0
//   },
//   'myFloat': {
//     'floatValue': 1.1
//   },
//   'myString': {
//     'stringValue': 'hi!'
//   }
// }
//
// The following method will remove these four types of 'xValue' fields, flattening them
// to just their values, as a string:
// {
//   'myInt': '123',
//   'myDouble': '1.0',
//   'myFloat': '1.1',
//   'myString': 'hi!'
// }
//
// Note that while 'intValue' will have a quoted payload, 'doubleValue' and 'floatValue' will not. This
// is due to the encoding library, which renders int64 values as strings to avoid loss of precision. This
// method always returns a string, similarly to avoid loss of precision, unlike the less-conservative
// 'unwrapValue' method just below.
/** @hidden */ function unwrapValueAsString(wrapped) {
    const key = Object.keys(wrapped)[0];
    return wrapped[key].toString();
}
// Ditto as the method above, but returning the values in the idiomatic JavaScript type (string for strings,
// number for numbers):
// {
//   'myInt': 123,
//   'myDouble': 1.0,
//   'myFloat': 1.1,
//   'myString': 'hi!'
// }
//
// The field names in the incoming xValue fields identify the type a value has, which for JavaScript's
// purposes can be divided into 'number' versus 'string'. This method will render all the numbers as
// JavaScript's 'number' type, since we prefer using idiomatic types. Note that this may lead to loss
// in precision for int64 fields, so use with care.
/** @hidden */ const xValueNumberFields = [
    "intValue",
    "floatValue",
    "doubleValue"
];
/** @hidden */ function unwrapValue(wrapped) {
    const key = Object.keys(wrapped)[0];
    const value = unwrapValueAsString(wrapped);
    return xValueNumberFields.includes(key) ? Number(value) : value;
}
// The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.
// The JavaScript convention is to use numbers denoted in milliseconds. This method
// makes it easy to convert a field of one type into the other.
/** @hidden */ function copyTimestampToMillis(from, to, fromName, toName) {
    if (from[fromName] !== undefined) {
        to[toName] = Math.round(from[fromName] / 1000);
    }
}
// The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.
// In our SDK, we'd like to present timestamp as ISO-format strings. This method makes it easy
// to convert a field of one type into the other.
/** @hidden */ function copyTimestampToString(from, to, fromName, toName) {
    if (from[fromName] !== undefined) {
        to[toName] = new Date(from[fromName] / 1000).toISOString();
    }
}
}}),
"[project]/node_modules/firebase-functions/lib/common/config.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.firebaseConfig = exports.resetCache = void 0;
const fs_1 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
let cache = null;
/**
 * @internal
 * @alpha
 */ function resetCache(newCache = null) {
    cache = newCache;
}
exports.resetCache = resetCache;
/**
 * Get the fields you need to initialize a Firebase app
 * @alpha
 */ function firebaseConfig() {
    if (cache) {
        return cache;
    }
    let env = process.env.FIREBASE_CONFIG;
    if (env) {
        // Firebase Tools will always use a JSON blob in prod, but docs
        // explicitly state that the user can set the env to a file:
        // https://firebase.google.com/docs/admin/setup#initialize-without-parameters
        if (!env.startsWith("{")) {
            env = (0, fs_1.readFileSync)(path.join(process.env.PWD, env)).toString("utf8");
        }
        cache = JSON.parse(env);
        return cache;
    }
    if (process.env.GCLOUD_PROJECT) {
        logger.warn("Warning, estimating Firebase Config based on GCLOUD_PROJECT. Initializing firebase-admin may fail");
        cache = {
            databaseURL: process.env.DATABASE_URL || `https://${process.env.GCLOUD_PROJECT}.firebaseio.com`,
            storageBucket: process.env.STORAGE_BUCKET_URL || `${process.env.GCLOUD_PROJECT}.appspot.com`,
            projectId: process.env.GCLOUD_PROJECT
        };
        return cache;
    } else {
        logger.warn("Warning, FIREBASE_CONFIG and GCLOUD_PROJECT environment variables are missing. Initializing firebase-admin will fail");
    }
    return null;
}
exports.firebaseConfig = firebaseConfig;
}}),
"[project]/node_modules/firebase-functions/lib/common/app.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setApp = exports.getApp = void 0;
const app_1 = __turbopack_context__.r("[externals]/firebase-admin/app [external] (firebase-admin/app, cjs)");
const config_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/config.js [app-rsc] (ecmascript)");
const APP_NAME = "__FIREBASE_FUNCTIONS_SDK__";
let cache;
function getApp() {
    if (typeof cache === "undefined") {
        try {
            cache = (0, app_1.getApp)();
        } catch  {
            // Default app does not exist. Initialize app.
            cache = (0, app_1.initializeApp)({
                ...(0, config_1.firebaseConfig)(),
                credential: (0, app_1.applicationDefault)()
            }, APP_NAME);
        }
    }
    return cache;
}
exports.getApp = getApp;
/**
 * This function allows the Firebase Emulator Suite to override the FirebaseApp instance
 * used by the Firebase Functions SDK. Developers should never call this function for
 * other purposes.
 * N.B. For clarity for use in testing this name has no mention of emulation, but
 * it must be exported from index as app.setEmulatedAdminApp or we break the emulator.
 * We can remove this export when:
 * A) We complete the new emulator and no longer depend on monkeypatching
 * B) We tweak the CLI to look for different APIs to monkeypatch depending on versions.
 * @alpha
 */ function setApp(app) {
    if ((cache === null || cache === void 0 ? void 0 : cache.name) === APP_NAME) {
        void (0, app_1.deleteApp)(cache);
    }
    cache = app;
}
exports.setApp = setApp;
}}),
"[project]/node_modules/firebase-functions/lib/common/debug.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2021 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isDebugFeatureEnabled = exports.debugFeatureValue = void 0;
// Do NOT turn on a debug feature in production.
const debugMode = process.env.FIREBASE_DEBUG_MODE === "true";
function loadDebugFeatures() {
    if (!debugMode) {
        return {};
    }
    try {
        const obj = JSON.parse(process.env.FIREBASE_DEBUG_FEATURES);
        if (typeof obj !== "object") {
            return {};
        }
        return obj;
    } catch (e) {
        return {};
    }
}
/* @internal */ function debugFeatureValue(feat) {
    if (!debugMode) {
        return;
    }
    return loadDebugFeatures()[feat];
}
exports.debugFeatureValue = debugFeatureValue;
/* @internal */ function isDebugFeatureEnabled(feat) {
    return debugMode && !!debugFeatureValue(feat);
}
exports.isDebugFeatureEnabled = isDebugFeatureEnabled;
}}),
"[project]/node_modules/firebase-functions/lib/common/providers/https.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2021 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onCallHandler = exports.checkAuthToken = exports.unsafeDecodeAppCheckToken = exports.unsafeDecodeIdToken = exports.unsafeDecodeToken = exports.decode = exports.encode = exports.isValidRequest = exports.HttpsError = exports.DEFAULT_HEARTBEAT_SECONDS = exports.ORIGINAL_AUTH_HEADER = exports.CALLABLE_AUTH_HEADER = void 0;
const cors = __turbopack_context__.r("[project]/node_modules/cors/lib/index.js [app-rsc] (ecmascript)");
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
// TODO(inlined): Decide whether we want to un-version apps or whether we want a
// different strategy
const app_check_1 = __turbopack_context__.r("[externals]/firebase-admin/app-check [external] (firebase-admin/app-check, cjs)");
const auth_1 = __turbopack_context__.r("[externals]/firebase-admin/auth [external] (firebase-admin/auth, cjs)");
const app_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/app.js [app-rsc] (ecmascript)");
const debug_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/debug.js [app-rsc] (ecmascript)");
const JWT_REGEX = /^[a-zA-Z0-9\-_=]+?\.[a-zA-Z0-9\-_=]+?\.([a-zA-Z0-9\-_=]+)?$/;
/** @internal */ exports.CALLABLE_AUTH_HEADER = "x-callable-context-auth";
/** @internal */ exports.ORIGINAL_AUTH_HEADER = "x-original-auth";
/** @internal */ exports.DEFAULT_HEARTBEAT_SECONDS = 30;
/**
 * Standard error codes and HTTP statuses for different ways a request can fail,
 * as defined by:
 * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto
 *
 * This map is used primarily to convert from a client error code string to
 * to the HTTP format error code string and status, and make sure it's in the
 * supported set.
 */ const errorCodeMap = {
    ok: {
        canonicalName: "OK",
        status: 200
    },
    cancelled: {
        canonicalName: "CANCELLED",
        status: 499
    },
    unknown: {
        canonicalName: "UNKNOWN",
        status: 500
    },
    "invalid-argument": {
        canonicalName: "INVALID_ARGUMENT",
        status: 400
    },
    "deadline-exceeded": {
        canonicalName: "DEADLINE_EXCEEDED",
        status: 504
    },
    "not-found": {
        canonicalName: "NOT_FOUND",
        status: 404
    },
    "already-exists": {
        canonicalName: "ALREADY_EXISTS",
        status: 409
    },
    "permission-denied": {
        canonicalName: "PERMISSION_DENIED",
        status: 403
    },
    unauthenticated: {
        canonicalName: "UNAUTHENTICATED",
        status: 401
    },
    "resource-exhausted": {
        canonicalName: "RESOURCE_EXHAUSTED",
        status: 429
    },
    "failed-precondition": {
        canonicalName: "FAILED_PRECONDITION",
        status: 400
    },
    aborted: {
        canonicalName: "ABORTED",
        status: 409
    },
    "out-of-range": {
        canonicalName: "OUT_OF_RANGE",
        status: 400
    },
    unimplemented: {
        canonicalName: "UNIMPLEMENTED",
        status: 501
    },
    internal: {
        canonicalName: "INTERNAL",
        status: 500
    },
    unavailable: {
        canonicalName: "UNAVAILABLE",
        status: 503
    },
    "data-loss": {
        canonicalName: "DATA_LOSS",
        status: 500
    }
};
/**
 * An explicit error that can be thrown from a handler to send an error to the
 * client that called the function.
 */ class HttpsError extends Error {
    constructor(code, message, details){
        super(message);
        // A sanity check for non-TypeScript consumers.
        if (code in errorCodeMap === false) {
            throw new Error(`Unknown error code: ${code}.`);
        }
        this.code = code;
        this.details = details;
        this.httpErrorCode = errorCodeMap[code];
    }
    /**
     * Returns a JSON-serializable representation of this object.
     */ toJSON() {
        const { details, httpErrorCode: { canonicalName: status }, message } = this;
        return {
            ...details === undefined ? {} : {
                details
            },
            message,
            status
        };
    }
}
exports.HttpsError = HttpsError;
/** @hidden */ // Returns true if req is a properly formatted callable request.
function isValidRequest(req) {
    // The body must not be empty.
    if (!req.body) {
        logger.warn("Request is missing body.");
        return false;
    }
    // Make sure it's a POST.
    if (req.method !== "POST") {
        logger.warn("Request has invalid method.", req.method);
        return false;
    }
    // Check that the Content-Type is JSON.
    let contentType = (req.header("Content-Type") || "").toLowerCase();
    // If it has a charset, just ignore it for now.
    const semiColon = contentType.indexOf(";");
    if (semiColon >= 0) {
        contentType = contentType.slice(0, semiColon).trim();
    }
    if (contentType !== "application/json") {
        logger.warn("Request has incorrect Content-Type.", contentType);
        return false;
    }
    // The body must have data.
    if (typeof req.body.data === "undefined") {
        logger.warn("Request body is missing data.", req.body);
        return false;
    }
    // TODO(klimt): Allow only specific http headers.
    // Verify that the body does not have any extra fields.
    const extraKeys = Object.keys(req.body).filter((field)=>field !== "data");
    if (extraKeys.length !== 0) {
        logger.warn("Request body has extra fields: ", extraKeys.join(", "));
        return false;
    }
    return true;
}
exports.isValidRequest = isValidRequest;
/** @hidden */ const LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
/** @hidden */ const UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
/**
 * Encodes arbitrary data in our special format for JSON.
 * This is exposed only for testing.
 */ /** @hidden */ function encode(data) {
    if (data === null || typeof data === "undefined") {
        return null;
    }
    if (data instanceof Number) {
        data = data.valueOf();
    }
    if (Number.isFinite(data)) {
        // Any number in JS is safe to put directly in JSON and parse as a double
        // without any loss of precision.
        return data;
    }
    if (typeof data === "boolean") {
        return data;
    }
    if (typeof data === "string") {
        return data;
    }
    if (Array.isArray(data)) {
        return data.map(encode);
    }
    if (typeof data === "object" || typeof data === "function") {
        // Sadly we don't have Object.fromEntries in Node 10, so we can't use a single
        // list comprehension
        const obj = {};
        for (const [k, v] of Object.entries(data)){
            obj[k] = encode(v);
        }
        return obj;
    }
    // If we got this far, the data is not encodable.
    logger.error("Data cannot be encoded in JSON.", data);
    throw new Error(`Data cannot be encoded in JSON: ${data}`);
}
exports.encode = encode;
/**
 * Decodes our special format for JSON into native types.
 * This is exposed only for testing.
 */ /** @hidden */ function decode(data) {
    if (data === null) {
        return data;
    }
    if (data["@type"]) {
        switch(data["@type"]){
            case LONG_TYPE:
            // Fall through and handle this the same as unsigned.
            case UNSIGNED_LONG_TYPE:
                {
                    // Technically, this could work return a valid number for malformed
                    // data if there was a number followed by garbage. But it's just not
                    // worth all the extra code to detect that case.
                    const value = parseFloat(data.value);
                    if (isNaN(value)) {
                        logger.error("Data cannot be decoded from JSON.", data);
                        throw new Error(`Data cannot be decoded from JSON: ${data}`);
                    }
                    return value;
                }
            default:
                {
                    logger.error("Data cannot be decoded from JSON.", data);
                    throw new Error(`Data cannot be decoded from JSON: ${data}`);
                }
        }
    }
    if (Array.isArray(data)) {
        return data.map(decode);
    }
    if (typeof data === "object") {
        const obj = {};
        for (const [k, v] of Object.entries(data)){
            obj[k] = decode(v);
        }
        return obj;
    }
    // Anything else is safe to return.
    return data;
}
exports.decode = decode;
/** @internal */ function unsafeDecodeToken(token) {
    if (!JWT_REGEX.test(token)) {
        return {};
    }
    const components = token.split(".").map((s)=>Buffer.from(s, "base64").toString());
    let payload = components[1];
    if (typeof payload === "string") {
        try {
            const obj = JSON.parse(payload);
            if (typeof obj === "object") {
                payload = obj;
            }
        } catch (e) {
        // ignore error
        }
    }
    return payload;
}
exports.unsafeDecodeToken = unsafeDecodeToken;
/**
 * Decode, but not verify, a Auth ID token.
 *
 * Do not use in production. Token should always be verified using the Admin SDK.
 *
 * This is exposed only for testing.
 */ /** @internal */ function unsafeDecodeIdToken(token) {
    const decoded = unsafeDecodeToken(token);
    decoded.uid = decoded.sub;
    return decoded;
}
exports.unsafeDecodeIdToken = unsafeDecodeIdToken;
/**
 * Decode, but not verify, an App Check token.
 *
 * Do not use in production. Token should always be verified using the Admin SDK.
 *
 * This is exposed only for testing.
 */ /** @internal */ function unsafeDecodeAppCheckToken(token) {
    const decoded = unsafeDecodeToken(token);
    decoded.app_id = decoded.sub;
    return decoded;
}
exports.unsafeDecodeAppCheckToken = unsafeDecodeAppCheckToken;
/**
 * Check and verify tokens included in the requests. Once verified, tokens
 * are injected into the callable context.
 *
 * @param {Request} req - Request sent to the Callable function.
 * @param {CallableContext} ctx - Context to be sent to callable function handler.
 * @returns {CallableTokenStatus} Status of the token verifications.
 */ /** @internal */ async function checkTokens(req, ctx, options) {
    const verifications = {
        app: "INVALID",
        auth: "INVALID"
    };
    [verifications.auth, verifications.app] = await Promise.all([
        checkAuthToken(req, ctx),
        checkAppCheckToken(req, ctx, options)
    ]);
    const logPayload = {
        verifications,
        "logging.googleapis.com/labels": {
            "firebase-log-type": "callable-request-verification"
        }
    };
    const errs = [];
    if (verifications.app === "INVALID") {
        errs.push("AppCheck token was rejected.");
    }
    if (verifications.auth === "INVALID") {
        errs.push("Auth token was rejected.");
    }
    if (errs.length === 0) {
        logger.debug("Callable request verification passed", logPayload);
    } else {
        logger.warn(`Callable request verification failed: ${errs.join(" ")}`, logPayload);
    }
    return verifications;
}
/** @interanl */ async function checkAuthToken(req, ctx) {
    const authorization = req.header("Authorization");
    if (!authorization) {
        return "MISSING";
    }
    const match = authorization.match(/^Bearer (.*)$/i);
    if (!match) {
        return "INVALID";
    }
    const idToken = match[1];
    try {
        let authToken;
        if ((0, debug_1.isDebugFeatureEnabled)("skipTokenVerification")) {
            authToken = unsafeDecodeIdToken(idToken);
        } else {
            authToken = await (0, auth_1.getAuth)((0, app_1.getApp)()).verifyIdToken(idToken);
        }
        ctx.auth = {
            uid: authToken.uid,
            token: authToken
        };
        return "VALID";
    } catch (err) {
        logger.warn("Failed to validate auth token.", err);
        return "INVALID";
    }
}
exports.checkAuthToken = checkAuthToken;
/** @internal */ async function checkAppCheckToken(req, ctx, options) {
    var _a;
    const appCheckToken = req.header("X-Firebase-AppCheck");
    if (!appCheckToken) {
        return "MISSING";
    }
    try {
        let appCheckData;
        if ((0, debug_1.isDebugFeatureEnabled)("skipTokenVerification")) {
            const decodedToken = unsafeDecodeAppCheckToken(appCheckToken);
            appCheckData = {
                appId: decodedToken.app_id,
                token: decodedToken
            };
            if (options.consumeAppCheckToken) {
                appCheckData.alreadyConsumed = false;
            }
        } else {
            const appCheck = (0, app_check_1.getAppCheck)((0, app_1.getApp)());
            if (options.consumeAppCheckToken) {
                if (((_a = appCheck.verifyToken) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                    const errorMsg = "Unsupported version of the Admin SDK." + " App Check token will not be consumed." + " Please upgrade the firebase-admin to the latest version.";
                    logger.error(errorMsg);
                    throw new HttpsError("internal", "Internal Error");
                }
                appCheckData = await (0, app_check_1.getAppCheck)((0, app_1.getApp)()).verifyToken(appCheckToken, {
                    consume: true
                });
            } else {
                appCheckData = await (0, app_check_1.getAppCheck)((0, app_1.getApp)()).verifyToken(appCheckToken);
            }
        }
        ctx.app = appCheckData;
        return "VALID";
    } catch (err) {
        logger.warn("Failed to validate AppCheck token.", err);
        if (err instanceof HttpsError) {
            throw err;
        }
        return "INVALID";
    }
}
/** @internal */ function onCallHandler(options, handler, version) {
    const wrapped = wrapOnCallHandler(options, handler, version);
    return (req, res)=>{
        return new Promise((resolve)=>{
            res.on("finish", resolve);
            cors(options.cors)(req, res, ()=>{
                resolve(wrapped(req, res));
            });
        });
    };
}
exports.onCallHandler = onCallHandler;
function encodeSSE(data) {
    return `data: ${JSON.stringify(data)}\n\n`;
}
/** @internal */ function wrapOnCallHandler(options, handler, version) {
    return async (req, res)=>{
        var _a;
        const abortController = new AbortController();
        let heartbeatInterval = null;
        const heartbeatSeconds = options.heartbeatSeconds === undefined ? exports.DEFAULT_HEARTBEAT_SECONDS : options.heartbeatSeconds;
        const clearScheduledHeartbeat = ()=>{
            if (heartbeatInterval) {
                clearTimeout(heartbeatInterval);
                heartbeatInterval = null;
            }
        };
        const scheduleHeartbeat = ()=>{
            clearScheduledHeartbeat();
            if (!abortController.signal.aborted) {
                heartbeatInterval = setTimeout(()=>{
                    if (!abortController.signal.aborted) {
                        res.write(": ping\n\n");
                        scheduleHeartbeat();
                    }
                }, heartbeatSeconds * 1000);
            }
        };
        res.on("close", ()=>{
            clearScheduledHeartbeat();
            abortController.abort();
        });
        try {
            if (!isValidRequest(req)) {
                logger.error("Invalid request, unable to process.");
                throw new HttpsError("invalid-argument", "Bad Request");
            }
            const context = {
                rawRequest: req
            };
            // TODO(colerogers): yank this when we release a breaking change of the CLI that removes
            // our monkey-patching code referenced below and increases the minimum supported SDK version.
            //
            // Note: This code is needed to fix v1 callable functions in the emulator with a monorepo setup.
            // The original monkey-patched code lived in the functionsEmulatorRuntime
            // (link: https://github.com/firebase/firebase-tools/blob/accea7abda3cc9fa6bb91368e4895faf95281c60/src/emulator/functionsEmulatorRuntime.ts#L480)
            // and was not compatible with how monorepos separate out packages (see https://github.com/firebase/firebase-tools/issues/5210).
            if ((0, debug_1.isDebugFeatureEnabled)("skipTokenVerification") && version === "gcfv1") {
                const authContext = context.rawRequest.header(exports.CALLABLE_AUTH_HEADER);
                if (authContext) {
                    logger.debug("Callable functions auth override", {
                        key: exports.CALLABLE_AUTH_HEADER,
                        value: authContext
                    });
                    context.auth = JSON.parse(decodeURIComponent(authContext));
                    delete context.rawRequest.headers[exports.CALLABLE_AUTH_HEADER];
                }
                const originalAuth = context.rawRequest.header(exports.ORIGINAL_AUTH_HEADER);
                if (originalAuth) {
                    context.rawRequest.headers["authorization"] = originalAuth;
                    delete context.rawRequest.headers[exports.ORIGINAL_AUTH_HEADER];
                }
            }
            const tokenStatus = await checkTokens(req, context, options);
            if (tokenStatus.auth === "INVALID") {
                throw new HttpsError("unauthenticated", "Unauthenticated");
            }
            if (tokenStatus.app === "INVALID") {
                if (options.enforceAppCheck) {
                    throw new HttpsError("unauthenticated", "Unauthenticated");
                } else {
                    logger.warn("Allowing request with invalid AppCheck token because enforcement is disabled");
                }
            }
            if (tokenStatus.app === "MISSING" && options.enforceAppCheck) {
                throw new HttpsError("unauthenticated", "Unauthenticated");
            }
            const instanceId = req.header("Firebase-Instance-ID-Token");
            if (instanceId) {
                // Validating the token requires an http request, so we don't do it.
                // If the user wants to use it for something, it will be validated then.
                // Currently, the only real use case for this token is for sending
                // pushes with FCM. In that case, the FCM APIs will validate the token.
                context.instanceIdToken = req.header("Firebase-Instance-ID-Token");
            }
            const acceptsStreaming = req.header("accept") === "text/event-stream";
            if (acceptsStreaming && version === "gcfv1") {
                // streaming responses are not supported in v1 callable
                throw new HttpsError("invalid-argument", "Unsupported Accept header 'text/event-stream'");
            }
            const data = decode(req.body.data);
            if (options.authPolicy) {
                const authorized = await options.authPolicy((_a = context.auth) !== null && _a !== void 0 ? _a : null, data);
                if (!authorized) {
                    throw new HttpsError("permission-denied", "Permission Denied");
                }
            }
            let result;
            if (version === "gcfv1") {
                result = await handler(data, context);
            } else {
                const arg = {
                    ...context,
                    data,
                    acceptsStreaming
                };
                const responseProxy = {
                    sendChunk (chunk) {
                        // if client doesn't accept sse-protocol, response.write() is no-op.
                        if (!acceptsStreaming) {
                            return Promise.resolve(false);
                        }
                        // if connection is already closed, response.write() is no-op.
                        if (abortController.signal.aborted) {
                            return Promise.resolve(false);
                        }
                        const formattedData = encodeSSE({
                            message: chunk
                        });
                        let resolve;
                        let reject;
                        const p = new Promise((res, rej)=>{
                            resolve = res;
                            reject = rej;
                        });
                        const wrote = res.write(formattedData, (error)=>{
                            if (error) {
                                reject(error);
                                return;
                            }
                            resolve(wrote);
                        });
                        // Reset heartbeat timer after successful write
                        if (wrote && heartbeatInterval !== null && heartbeatSeconds > 0) {
                            scheduleHeartbeat();
                        }
                        return p;
                    },
                    signal: abortController.signal
                };
                if (acceptsStreaming) {
                    // SSE always responds with 200
                    res.status(200);
                    if (heartbeatSeconds !== null && heartbeatSeconds > 0) {
                        scheduleHeartbeat();
                    }
                }
                // For some reason the type system isn't picking up that the handler
                // is a one argument function.
                result = await handler(arg, responseProxy);
                clearScheduledHeartbeat();
            }
            if (!abortController.signal.aborted) {
                // Encode the result as JSON to preserve types like Dates.
                result = encode(result);
                // If there was some result, encode it in the body.
                const responseBody = {
                    result
                };
                if (acceptsStreaming) {
                    res.write(encodeSSE(responseBody));
                    res.end();
                } else {
                    res.status(200).send(responseBody);
                }
            } else {
                res.end();
            }
        } catch (err) {
            if (!abortController.signal.aborted) {
                let httpErr = err;
                if (!(err instanceof HttpsError)) {
                    // This doesn't count as an 'explicit' error.
                    logger.error("Unhandled error", err);
                    httpErr = new HttpsError("internal", "INTERNAL");
                }
                const { status } = httpErr.httpErrorCode;
                const body = {
                    error: httpErr.toJSON()
                };
                if (version === "gcfv2" && req.header("accept") === "text/event-stream") {
                    res.write(encodeSSE(body));
                    res.end();
                } else {
                    res.status(status).send(body);
                }
            } else {
                res.end();
            }
        } finally{
            clearScheduledHeartbeat();
        }
    };
}
}}),
"[project]/node_modules/firebase-functions/lib/common/providers/identity.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2022 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapHandler = exports.getUpdateMask = exports.validateAuthResponse = exports.parseAuthEventContext = exports.generateResponsePayload = exports.parseAuthUserRecord = exports.parseMultiFactor = exports.parseDate = exports.parseProviderData = exports.parseMetadata = exports.isValidRequest = exports.userRecordConstructor = exports.UserRecordMetadata = exports.HttpsError = void 0;
const auth = __turbopack_context__.r("[externals]/firebase-admin/auth [external] (firebase-admin/auth, cjs)");
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
const app_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/app.js [app-rsc] (ecmascript)");
const debug_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/debug.js [app-rsc] (ecmascript)");
const https_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/https.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HttpsError", {
    enumerable: true,
    get: function() {
        return https_1.HttpsError;
    }
});
const DISALLOWED_CUSTOM_CLAIMS = [
    "acr",
    "amr",
    "at_hash",
    "aud",
    "auth_time",
    "azp",
    "cnf",
    "c_hash",
    "exp",
    "iat",
    "iss",
    "jti",
    "nbf",
    "nonce",
    "firebase"
];
const CLAIMS_MAX_PAYLOAD_SIZE = 1000;
const EVENT_MAPPING = {
    beforeCreate: "providers/cloud.auth/eventTypes/user.beforeCreate",
    beforeSignIn: "providers/cloud.auth/eventTypes/user.beforeSignIn",
    beforeSendEmail: "providers/cloud.auth/eventTypes/user.beforeSendEmail",
    beforeSendSms: "providers/cloud.auth/eventTypes/user.beforeSendSms"
};
/**
 * Helper class to create the user metadata in a `UserRecord` object.
 */ class UserRecordMetadata {
    constructor(creationTime, lastSignInTime){
        this.creationTime = creationTime;
        this.lastSignInTime = lastSignInTime;
    }
    /** Returns a plain JavaScript object with the properties of UserRecordMetadata. */ toJSON() {
        return {
            creationTime: this.creationTime,
            lastSignInTime: this.lastSignInTime
        };
    }
}
exports.UserRecordMetadata = UserRecordMetadata;
/**
 * Helper function that creates a `UserRecord` class from data sent over the wire.
 * @param wireData data sent over the wire
 * @returns an instance of `UserRecord` with correct toJSON functions
 */ function userRecordConstructor(wireData) {
    // Falsey values from the wire format proto get lost when converted to JSON, this adds them back.
    const falseyValues = {
        email: null,
        emailVerified: false,
        displayName: null,
        photoURL: null,
        phoneNumber: null,
        disabled: false,
        providerData: [],
        customClaims: {},
        passwordSalt: null,
        passwordHash: null,
        tokensValidAfterTime: null
    };
    const record = {
        ...falseyValues,
        ...wireData
    };
    const meta = record.metadata;
    if (meta) {
        record.metadata = new UserRecordMetadata(meta.createdAt || meta.creationTime, meta.lastSignedInAt || meta.lastSignInTime);
    } else {
        record.metadata = new UserRecordMetadata(null, null);
    }
    record.toJSON = ()=>{
        const { uid, email, emailVerified, displayName, photoURL, phoneNumber, disabled, passwordHash, passwordSalt, tokensValidAfterTime } = record;
        const json = {
            uid,
            email,
            emailVerified,
            displayName,
            photoURL,
            phoneNumber,
            disabled,
            passwordHash,
            passwordSalt,
            tokensValidAfterTime
        };
        json.metadata = record.metadata.toJSON();
        json.customClaims = JSON.parse(JSON.stringify(record.customClaims));
        json.providerData = record.providerData.map((entry)=>{
            const newEntry = {
                ...entry
            };
            newEntry.toJSON = ()=>entry;
            return newEntry;
        });
        return json;
    };
    return record;
}
exports.userRecordConstructor = userRecordConstructor;
/**
 * Checks for a valid identity platform web request, otherwise throws an HttpsError.
 * @internal
 */ function isValidRequest(req) {
    var _a, _b;
    if (req.method !== "POST") {
        logger.warn(`Request has invalid method "${req.method}".`);
        return false;
    }
    const contentType = (req.header("Content-Type") || "").toLowerCase();
    if (!contentType.includes("application/json")) {
        logger.warn("Request has invalid header Content-Type.");
        return false;
    }
    if (!((_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.jwt)) {
        logger.warn("Request has an invalid body.");
        return false;
    }
    return true;
}
exports.isValidRequest = isValidRequest;
/**
 * Decode, but not verify, an Auth Blocking token.
 *
 * Do not use in production. Token should always be verified using the Admin SDK.
 *
 * This is exposed only for testing.
 */ function unsafeDecodeAuthBlockingToken(token) {
    const decoded = (0, https_1.unsafeDecodeToken)(token);
    decoded.uid = decoded.sub;
    return decoded;
}
/**
 * Helper function to parse the decoded metadata object into a `UserMetaData` object
 * @internal
 */ function parseMetadata(metadata) {
    const creationTime = (metadata === null || metadata === void 0 ? void 0 : metadata.creation_time) ? new Date(metadata.creation_time).toUTCString() : null;
    const lastSignInTime = (metadata === null || metadata === void 0 ? void 0 : metadata.last_sign_in_time) ? new Date(metadata.last_sign_in_time).toUTCString() : null;
    return {
        creationTime,
        lastSignInTime
    };
}
exports.parseMetadata = parseMetadata;
/**
 * Helper function to parse the decoded user info array into an `AuthUserInfo` array.
 * @internal
 */ function parseProviderData(providerData) {
    const providers = [];
    for (const provider of providerData){
        providers.push({
            uid: provider.uid,
            displayName: provider.display_name,
            email: provider.email,
            photoURL: provider.photo_url,
            providerId: provider.provider_id,
            phoneNumber: provider.phone_number
        });
    }
    return providers;
}
exports.parseProviderData = parseProviderData;
/**
 * Helper function to parse the date into a UTC string.
 * @internal
 */ function parseDate(tokensValidAfterTime) {
    if (!tokensValidAfterTime) {
        return null;
    }
    tokensValidAfterTime = tokensValidAfterTime * 1000;
    try {
        const date = new Date(tokensValidAfterTime);
        if (!isNaN(date.getTime())) {
            return date.toUTCString();
        }
    } catch  {
    // ignore error
    }
    return null;
}
exports.parseDate = parseDate;
/**
 * Helper function to parse the decoded enrolled factors into a valid MultiFactorSettings
 * @internal
 */ function parseMultiFactor(multiFactor) {
    if (!multiFactor) {
        return null;
    }
    const parsedEnrolledFactors = [];
    for (const factor of multiFactor.enrolled_factors || []){
        if (!factor.uid) {
            throw new https_1.HttpsError("internal", "INTERNAL ASSERT FAILED: Invalid multi-factor info response");
        }
        const enrollmentTime = factor.enrollment_time ? new Date(factor.enrollment_time).toUTCString() : null;
        parsedEnrolledFactors.push({
            uid: factor.uid,
            factorId: factor.phone_number ? factor.factor_id || "phone" : factor.factor_id,
            displayName: factor.display_name,
            enrollmentTime,
            phoneNumber: factor.phone_number
        });
    }
    if (parsedEnrolledFactors.length > 0) {
        return {
            enrolledFactors: parsedEnrolledFactors
        };
    }
    return null;
}
exports.parseMultiFactor = parseMultiFactor;
/**
 * Parses the decoded user record into a valid UserRecord for use in the handler
 * @internal
 */ function parseAuthUserRecord(decodedJWTUserRecord) {
    if (!decodedJWTUserRecord.uid) {
        throw new https_1.HttpsError("internal", "INTERNAL ASSERT FAILED: Invalid user response");
    }
    const disabled = decodedJWTUserRecord.disabled || false;
    const metadata = parseMetadata(decodedJWTUserRecord.metadata);
    const providerData = parseProviderData(decodedJWTUserRecord.provider_data);
    const tokensValidAfterTime = parseDate(decodedJWTUserRecord.tokens_valid_after_time);
    const multiFactor = parseMultiFactor(decodedJWTUserRecord.multi_factor);
    return {
        uid: decodedJWTUserRecord.uid,
        email: decodedJWTUserRecord.email,
        emailVerified: decodedJWTUserRecord.email_verified,
        displayName: decodedJWTUserRecord.display_name,
        photoURL: decodedJWTUserRecord.photo_url,
        phoneNumber: decodedJWTUserRecord.phone_number,
        disabled,
        metadata,
        providerData,
        passwordHash: decodedJWTUserRecord.password_hash,
        passwordSalt: decodedJWTUserRecord.password_salt,
        customClaims: decodedJWTUserRecord.custom_claims,
        tenantId: decodedJWTUserRecord.tenant_id,
        tokensValidAfterTime,
        multiFactor
    };
}
exports.parseAuthUserRecord = parseAuthUserRecord;
/** Helper to get the `AdditionalUserInfo` from the decoded JWT */ function parseAdditionalUserInfo(decodedJWT) {
    let profile;
    let username;
    if (decodedJWT.raw_user_info) {
        try {
            profile = JSON.parse(decodedJWT.raw_user_info);
        } catch (err) {
            logger.debug(`Parse Error: ${err.message}`);
        }
    }
    if (profile) {
        if (decodedJWT.sign_in_method === "github.com") {
            username = profile.login;
        }
        if (decodedJWT.sign_in_method === "twitter.com") {
            username = profile.screen_name;
        }
    }
    return {
        providerId: decodedJWT.sign_in_method === "emailLink" ? "password" : decodedJWT.sign_in_method,
        profile,
        username,
        isNewUser: decodedJWT.event_type === "beforeCreate" ? true : false,
        recaptchaScore: decodedJWT.recaptcha_score,
        email: decodedJWT.email,
        phoneNumber: decodedJWT.phone_number
    };
}
/**
 * Helper to generate a response from the blocking function to the Firebase Auth backend.
 * @internal
 */ function generateResponsePayload(authResponse) {
    if (!authResponse) {
        return {};
    }
    const { recaptchaActionOverride, ...formattedAuthResponse } = authResponse;
    const result = {};
    const updateMask = getUpdateMask(formattedAuthResponse);
    if (updateMask.length !== 0) {
        result.userRecord = {
            ...formattedAuthResponse,
            updateMask
        };
    }
    if (recaptchaActionOverride !== undefined) {
        result.recaptchaActionOverride = recaptchaActionOverride;
    }
    return result;
}
exports.generateResponsePayload = generateResponsePayload;
/** Helper to get the Credential from the decoded JWT */ function parseAuthCredential(decodedJWT, time) {
    if (!decodedJWT.sign_in_attributes && !decodedJWT.oauth_id_token && !decodedJWT.oauth_access_token && !decodedJWT.oauth_refresh_token) {
        return null;
    }
    return {
        claims: decodedJWT.sign_in_attributes,
        idToken: decodedJWT.oauth_id_token,
        accessToken: decodedJWT.oauth_access_token,
        refreshToken: decodedJWT.oauth_refresh_token,
        expirationTime: decodedJWT.oauth_expires_in ? new Date(time + decodedJWT.oauth_expires_in * 1000).toUTCString() : undefined,
        secret: decodedJWT.oauth_token_secret,
        providerId: decodedJWT.sign_in_method === "emailLink" ? "password" : decodedJWT.sign_in_method,
        signInMethod: decodedJWT.sign_in_method
    };
}
/**
 * Parses the decoded jwt into a valid AuthEventContext for use in the handler
 * @internal
 */ function parseAuthEventContext(decodedJWT, projectId, time = new Date().getTime()) {
    const eventType = (EVENT_MAPPING[decodedJWT.event_type] || decodedJWT.event_type) + (decodedJWT.sign_in_method ? `:${decodedJWT.sign_in_method}` : "");
    return {
        locale: decodedJWT.locale,
        ipAddress: decodedJWT.ip_address,
        userAgent: decodedJWT.user_agent,
        eventId: decodedJWT.event_id,
        eventType,
        authType: decodedJWT.user_record ? "USER" : "UNAUTHENTICATED",
        resource: {
            // TODO(colerogers): figure out the correct service
            service: "identitytoolkit.googleapis.com",
            name: decodedJWT.tenant_id ? `projects/${projectId}/tenants/${decodedJWT.tenant_id}` : `projects/${projectId}`
        },
        timestamp: new Date(decodedJWT.iat * 1000).toUTCString(),
        additionalUserInfo: parseAdditionalUserInfo(decodedJWT),
        credential: parseAuthCredential(decodedJWT, time),
        emailType: decodedJWT.email_type,
        smsType: decodedJWT.sms_type,
        params: {}
    };
}
exports.parseAuthEventContext = parseAuthEventContext;
/**
 * Checks the handler response for invalid customClaims & sessionClaims objects
 * @internal
 */ function validateAuthResponse(eventType, authRequest) {
    if (!authRequest) {
        authRequest = {};
    }
    if (authRequest.customClaims) {
        const invalidClaims = DISALLOWED_CUSTOM_CLAIMS.filter((claim)=>authRequest.customClaims.hasOwnProperty(claim));
        if (invalidClaims.length > 0) {
            throw new https_1.HttpsError("invalid-argument", `The customClaims claims "${invalidClaims.join(",")}" are reserved and cannot be specified.`);
        }
        if (JSON.stringify(authRequest.customClaims).length > CLAIMS_MAX_PAYLOAD_SIZE) {
            throw new https_1.HttpsError("invalid-argument", `The customClaims payload should not exceed ${CLAIMS_MAX_PAYLOAD_SIZE} characters.`);
        }
    }
    if (eventType === "beforeSignIn" && authRequest.sessionClaims) {
        const invalidClaims = DISALLOWED_CUSTOM_CLAIMS.filter((claim)=>authRequest.sessionClaims.hasOwnProperty(claim));
        if (invalidClaims.length > 0) {
            throw new https_1.HttpsError("invalid-argument", `The sessionClaims claims "${invalidClaims.join(",")}" are reserved and cannot be specified.`);
        }
        if (JSON.stringify(authRequest.sessionClaims).length > CLAIMS_MAX_PAYLOAD_SIZE) {
            throw new https_1.HttpsError("invalid-argument", `The sessionClaims payload should not exceed ${CLAIMS_MAX_PAYLOAD_SIZE} characters.`);
        }
        const combinedClaims = {
            ...authRequest.customClaims,
            ...authRequest.sessionClaims
        };
        if (JSON.stringify(combinedClaims).length > CLAIMS_MAX_PAYLOAD_SIZE) {
            throw new https_1.HttpsError("invalid-argument", `The customClaims and sessionClaims payloads should not exceed ${CLAIMS_MAX_PAYLOAD_SIZE} characters combined.`);
        }
    }
}
exports.validateAuthResponse = validateAuthResponse;
/**
 * Helper function to generate the update mask for the identity platform changed values
 * @internal
 */ function getUpdateMask(authResponse) {
    if (!authResponse) {
        return "";
    }
    const updateMask = [];
    for(const key in authResponse){
        if (authResponse.hasOwnProperty(key) && typeof authResponse[key] !== "undefined") {
            updateMask.push(key);
        }
    }
    return updateMask.join(",");
}
exports.getUpdateMask = getUpdateMask;
/** @internal */ function wrapHandler(eventType, handler) {
    return async (req, res)=>{
        try {
            const projectId = process.env.GCLOUD_PROJECT;
            if (!isValidRequest(req)) {
                logger.error("Invalid request, unable to process");
                throw new https_1.HttpsError("invalid-argument", "Bad Request");
            }
            if (!auth.getAuth((0, app_1.getApp)())._verifyAuthBlockingToken) {
                throw new Error("Cannot validate Auth Blocking token. Please update Firebase Admin SDK to >= v10.1.0");
            }
            const decodedPayload = (0, debug_1.isDebugFeatureEnabled)("skipTokenVerification") ? unsafeDecodeAuthBlockingToken(req.body.data.jwt) : handler.platform === "gcfv1" ? await auth.getAuth((0, app_1.getApp)())._verifyAuthBlockingToken(req.body.data.jwt) : await auth.getAuth((0, app_1.getApp)())._verifyAuthBlockingToken(req.body.data.jwt, "run.app");
            let authUserRecord;
            if (decodedPayload.event_type === "beforeCreate" || decodedPayload.event_type === "beforeSignIn") {
                authUserRecord = parseAuthUserRecord(decodedPayload.user_record);
            }
            const authEventContext = parseAuthEventContext(decodedPayload, projectId);
            let authResponse;
            if (handler.platform === "gcfv1") {
                authResponse = authUserRecord ? await handler(authUserRecord, authEventContext) || undefined : await handler(authEventContext) || undefined;
            } else {
                authResponse = await handler({
                    ...authEventContext,
                    data: authUserRecord
                }) || undefined;
            }
            validateAuthResponse(eventType, authResponse);
            const result = generateResponsePayload(authResponse);
            res.status(200);
            res.setHeader("Content-Type", "application/json");
            res.send(JSON.stringify(result));
        } catch (err) {
            let httpErr = err;
            if (!(httpErr instanceof https_1.HttpsError)) {
                // This doesn't count as an 'explicit' error.
                logger.error("Unhandled error", err);
                httpErr = new https_1.HttpsError("internal", "An unexpected error occurred.");
            }
            const { status } = httpErr.httpErrorCode;
            const body = {
                error: httpErr.toJSON()
            };
            res.setHeader("Content-Type", "application/json");
            res.status(status).send(body);
        }
    };
}
exports.wrapHandler = wrapHandler;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/auth.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UserBuilder = exports._userWithOptions = exports.user = exports.service = exports.provider = exports.HttpsError = exports.userRecordConstructor = exports.UserRecordMetadata = void 0;
const identity_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/identity.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HttpsError", {
    enumerable: true,
    get: function() {
        return identity_1.HttpsError;
    }
});
Object.defineProperty(exports, "userRecordConstructor", {
    enumerable: true,
    get: function() {
        return identity_1.userRecordConstructor;
    }
});
Object.defineProperty(exports, "UserRecordMetadata", {
    enumerable: true,
    get: function() {
        return identity_1.UserRecordMetadata;
    }
});
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
const manifest_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/runtime/manifest.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.firebase.auth";
/** @internal */ exports.service = "firebaseauth.googleapis.com";
/**
 * Handles events related to Firebase Auth users events.
 *
 * @param userOptions - Resource level options
 * @returns UserBuilder - Builder used to create functions for Firebase Auth user lifecycle events
 *
 * @public
 */ function user(userOptions) {
    return _userWithOptions({}, userOptions || {});
}
exports.user = user;
/** @internal */ function _userWithOptions(options, userOptions) {
    return new UserBuilder(()=>{
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error("process.env.GCLOUD_PROJECT is not set.");
        }
        return "projects/" + process.env.GCLOUD_PROJECT;
    }, options, userOptions);
}
exports._userWithOptions = _userWithOptions;
/**
 * Builder used to create functions for Firebase Auth user lifecycle events.
 * @public
 */ class UserBuilder {
    static dataConstructor(raw) {
        return (0, identity_1.userRecordConstructor)(raw.data);
    }
    /* @internal */ constructor(triggerResource, options, userOptions){
        this.triggerResource = triggerResource;
        this.options = options;
        this.userOptions = userOptions;
    }
    /**
     * Responds to the creation of a Firebase Auth user.
     *
     * @param handler Event handler that responds to the creation of a Firebase Auth user.
     *
     * @public
     */ onCreate(handler) {
        return this.onOperation(handler, "user.create");
    }
    /**
     * Responds to the deletion of a Firebase Auth user.
     *
     * @param handler Event handler that responds to the deletion of a Firebase Auth user.
     *
     * @public
     */ onDelete(handler) {
        return this.onOperation(handler, "user.delete");
    }
    /**
     * Blocks request to create a Firebase Auth user.
     *
     * @param handler Event handler that blocks creation of a Firebase Auth user.
     *
     * @public
     */ beforeCreate(handler) {
        return this.beforeOperation(handler, "beforeCreate");
    }
    /**
     * Blocks request to sign-in a Firebase Auth user.
     *
     * @param handler Event handler that blocks sign-in of a Firebase Auth user.
     *
     * @public
     */ beforeSignIn(handler) {
        return this.beforeOperation(handler, "beforeSignIn");
    }
    beforeEmail(handler) {
        return this.beforeOperation(handler, "beforeSendEmail");
    }
    beforeSms(handler) {
        return this.beforeOperation(handler, "beforeSendSms");
    }
    onOperation(handler, eventType) {
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            eventType,
            service: exports.service,
            triggerResource: this.triggerResource,
            // eslint-disable-next-line @typescript-eslint/unbound-method
            dataConstructor: UserBuilder.dataConstructor,
            legacyEventType: `providers/firebase.auth/eventTypes/${eventType}`,
            options: this.options
        });
    }
    beforeOperation(handler, eventType) {
        var _a, _b, _c, _d, _e, _f;
        const accessToken = ((_b = (_a = this.userOptions) === null || _a === void 0 ? void 0 : _a.blockingOptions) === null || _b === void 0 ? void 0 : _b.accessToken) || false;
        const idToken = ((_d = (_c = this.userOptions) === null || _c === void 0 ? void 0 : _c.blockingOptions) === null || _d === void 0 ? void 0 : _d.idToken) || false;
        const refreshToken = ((_f = (_e = this.userOptions) === null || _e === void 0 ? void 0 : _e.blockingOptions) === null || _f === void 0 ? void 0 : _f.refreshToken) || false;
        const annotatedHandler = Object.assign(handler, {
            platform: "gcfv1"
        });
        const func = (0, identity_1.wrapHandler)(eventType, annotatedHandler);
        const legacyEventType = `providers/cloud.auth/eventTypes/user.${eventType}`;
        func.__trigger = {
            labels: {},
            ...(0, cloud_functions_1.optionsToTrigger)(this.options),
            blockingTrigger: {
                eventType: legacyEventType,
                options: {
                    accessToken,
                    idToken,
                    refreshToken
                }
            }
        };
        func.__endpoint = {
            platform: "gcfv1",
            labels: {},
            ...(0, manifest_1.initV1Endpoint)(this.options),
            ...(0, cloud_functions_1.optionsToEndpoint)(this.options),
            blockingTrigger: {
                eventType: legacyEventType,
                options: {
                    accessToken,
                    idToken,
                    refreshToken
                }
            }
        };
        func.__requiredAPIs = [
            {
                api: "identitytoolkit.googleapis.com",
                reason: "Needed for auth blocking functions"
            }
        ];
        func.run = handler;
        return func;
    }
}
exports.UserBuilder = UserBuilder;
}}),
"[project]/node_modules/firebase-functions/lib/common/utilities/path.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.joinPath = exports.pathParts = exports.normalizePath = void 0;
/** @hidden
 * Removes leading and trailing slashes from a path.
 *
 * @param path A path to normalize, in POSIX format.
 */ function normalizePath(path) {
    if (!path) {
        return "";
    }
    return path.replace(/^\//, "").replace(/\/$/, "");
}
exports.normalizePath = normalizePath;
/**
 * Normalizes a given path and splits it into an array of segments.
 *
 * @param path A path to split, in POSIX format.
 */ function pathParts(path) {
    if (!path || path === "" || path === "/") {
        return [];
    }
    return normalizePath(path).split("/");
}
exports.pathParts = pathParts;
/**
 * Normalizes given paths and joins these together using a POSIX separator.
 *
 * @param base A first path segment, in POSIX format.
 * @param child A second path segment, in POSIX format.
 */ function joinPath(base, child) {
    return pathParts(base).concat(pathParts(child)).join("/");
}
exports.joinPath = joinPath;
}}),
"[project]/node_modules/firebase-functions/lib/common/providers/database.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2022 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataSnapshot = void 0;
const database = __turbopack_context__.r("[externals]/firebase-admin/database [external] (firebase-admin/database, cjs)");
const config_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/config.js [app-rsc] (ecmascript)");
const path_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/utilities/path.js [app-rsc] (ecmascript)");
/**
 * Interface representing a Firebase Realtime database data snapshot.
 */ class DataSnapshot {
    constructor(data, path, app, instance){
        this.app = app;
        const config = (0, config_1.firebaseConfig)();
        if (instance) {
            // SDK always supplies instance, but user's unit tests may not
            this.instance = instance;
        } else if (app) {
            this.instance = app.options.databaseURL;
        } else if (config.databaseURL) {
            this.instance = config.databaseURL;
        } else if (process.env.GCLOUD_PROJECT) {
            this.instance = "https://" + process.env.GCLOUD_PROJECT + "-default-rtdb.firebaseio.com";
        }
        this._path = path;
        this._data = data;
    }
    /**
     * Returns a [`Reference`](/docs/reference/admin/node/admin.database.Reference)
     * to the database location where the triggering write occurred. Has
     * full read and write access.
     */ get ref() {
        if (!this.app) {
            // may be unpopulated in user's unit tests
            throw new Error("Please supply a Firebase app in the constructor for DataSnapshot" + " in order to use the .ref method.");
        }
        if (!this._ref) {
            let db;
            if (this.instance) {
                db = database.getDatabaseWithUrl(this.instance, this.app);
            } else {
                db = database.getDatabase(this.app);
            }
            this._ref = db.ref(this._fullPath());
        }
        return this._ref;
    }
    /**
     * The key (last part of the path) of the location of this `DataSnapshot`.
     *
     * The last token in a database location is considered its key. For example,
     * "ada" is the key for the `/users/ada/` node. Accessing the key on any
     * `DataSnapshot` returns the key for the location that generated it.
     * However, accessing the key on the root URL of a database returns `null`.
     */ get key() {
        const segments = (0, path_1.pathParts)(this._fullPath());
        const last = segments[segments.length - 1];
        return !last || last === "" ? null : last;
    }
    /**
     * Extracts a JavaScript value from a `DataSnapshot`.
     *
     * Depending on the data in a `DataSnapshot`, the `val()` method may return a
     * scalar type (string, number, or boolean), an array, or an object. It may also
     * return `null`, indicating that the `DataSnapshot` is empty (contains no
     * data).
     *
     * @return The snapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */ val() {
        const parts = (0, path_1.pathParts)(this._childPath);
        let source = this._data;
        if (source === null) {
            return null;
        }
        if (parts.length) {
            for (const part of parts){
                if (source[part] === undefined) {
                    return null;
                }
                source = source[part];
            }
        }
        const node = source !== null && source !== void 0 ? source : null;
        return this._checkAndConvertToArray(node);
    }
    /**
     * Exports the entire contents of the `DataSnapshot` as a JavaScript object.
     *
     * @return The contents of the `DataSnapshot` as a JavaScript value
     *   (Object, Array, string, number, boolean, or `null`).
     */ exportVal() {
        return this.val();
    }
    /**
     * Gets the priority value of the data in this `DataSnapshot`.
     *
     * As an alternative to using priority, applications can order collections by
     * ordinary properties. See [Sorting and filtering
     * data](/docs/database/web/lists-of-data#sorting_and_filtering_data).
     *
     * @return The priority value of the data.
     */ getPriority() {
        return 0;
    }
    /**
     * Returns `true` if this `DataSnapshot` contains any data. It is slightly more
     * efficient than using `snapshot.val() !== null`.
     *
     * @return `true` if this `DataSnapshot` contains any data; otherwise, `false`.
     */ exists() {
        const val = this.val();
        if (typeof val === "undefined" || val === null) {
            return false;
        }
        if (typeof val === "object" && Object.keys(val).length === 0) {
            return false;
        }
        return true;
    }
    /**
     * Gets a `DataSnapshot` for the location at the specified relative path.
     *
     * The relative path can either be a simple child name (for example, "ada") or
     * a deeper slash-separated path (for example, "ada/name/first").
     *
     * @param path A relative path from this location to the desired child
     *   location.
     * @return The specified child location.
     */ child(childPath) {
        if (!childPath) {
            return this;
        }
        return this._dup(childPath);
    }
    /**
     * Enumerates the `DataSnapshot`s of the children items.
     *
     * Because of the way JavaScript objects work, the ordering of data in the
     * JavaScript object returned by `val()` is not guaranteed to match the ordering
     * on the server nor the ordering of `child_added` events. That is where
     * `forEach()` comes in handy. It guarantees the children of a `DataSnapshot`
     * can be iterated in their query order.
     *
     * If no explicit `orderBy*()` method is used, results are returned
     * ordered by key (unless priorities are used, in which case, results are
     * returned by priority).
     *
     * @param action A function that is called for each child `DataSnapshot`.
     *   The callback can return `true` to cancel further enumeration.
     *
     * @return `true` if enumeration was canceled due to your callback
     *   returning `true`.
     */ forEach(action) {
        const val = this.val() || {};
        if (typeof val === "object") {
            return Object.keys(val).some((key)=>action(this.child(key)) === true);
        }
        return false;
    }
    /**
     * Returns `true` if the specified child path has (non-`null`) data.
     *
     * @param path A relative path to the location of a potential child.
     * @return `true` if data exists at the specified child path; otherwise,
     *   `false`.
     */ hasChild(childPath) {
        return this.child(childPath).exists();
    }
    /**
     * Returns whether or not the `DataSnapshot` has any non-`null` child
     * properties.
     *
     * You can use `hasChildren()` to determine if a `DataSnapshot` has any
     * children. If it does, you can enumerate them using `forEach()`. If it
     * doesn't, then either this snapshot contains a primitive value (which can be
     * retrieved with `val()`) or it is empty (in which case, `val()` returns
     * `null`).
     *
     * @return `true` if this snapshot has any children; else `false`.
     */ hasChildren() {
        const val = this.val();
        return val !== null && typeof val === "object" && Object.keys(val).length > 0;
    }
    /**
     * Returns the number of child properties of this `DataSnapshot`.
     *
     * @return Number of child properties of this `DataSnapshot`.
     */ numChildren() {
        const val = this.val();
        return val !== null && typeof val === "object" ? Object.keys(val).length : 0;
    }
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @return A JSON-serializable representation of this object.
     */ toJSON() {
        return this.val();
    }
    /** Recursive function to check if keys are numeric & convert node object to array if they are
     *
     * @hidden
     */ _checkAndConvertToArray(node) {
        if (node === null || typeof node === "undefined") {
            return null;
        }
        if (typeof node !== "object") {
            return node;
        }
        const obj = {};
        let numKeys = 0;
        let maxKey = 0;
        let allIntegerKeys = true;
        for(const key in node){
            if (!node.hasOwnProperty(key)) {
                continue;
            }
            const childNode = node[key];
            const v = this._checkAndConvertToArray(childNode);
            if (v === null) {
                continue;
            }
            obj[key] = v;
            numKeys++;
            const integerRegExp = /^(0|[1-9]\d*)$/;
            if (allIntegerKeys && integerRegExp.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            } else {
                allIntegerKeys = false;
            }
        }
        if (numKeys === 0) {
            // Empty node
            return null;
        }
        if (allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            const array = [];
            for (const key of Object.keys(obj)){
                array[key] = obj[key];
            }
            return array;
        }
        return obj;
    }
    /** @hidden */ _dup(childPath) {
        const dup = new DataSnapshot(this._data, undefined, this.app, this.instance);
        [dup._path, dup._childPath] = [
            this._path,
            this._childPath
        ];
        if (childPath) {
            dup._childPath = (0, path_1.joinPath)(dup._childPath, childPath);
        }
        return dup;
    }
    /** @hidden */ _fullPath() {
        return (this._path || "") + "/" + (this._childPath || "");
    }
}
exports.DataSnapshot = DataSnapshot;
}}),
"[project]/node_modules/firebase-functions/lib/common/utilities/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.applyChange = void 0;
function isObject(obj) {
    return typeof obj === "object" && !!obj;
}
/** @hidden */ function applyChange(src, dest) {
    // if not mergeable, don't merge
    if (!isObject(dest) || !isObject(src)) {
        return dest;
    }
    return merge(src, dest);
}
exports.applyChange = applyChange;
function merge(src, dest) {
    const res = {};
    const keys = new Set([
        ...Object.keys(src),
        ...Object.keys(dest)
    ]);
    for (const key of keys.values()){
        if (key in dest) {
            if (dest[key] === null) {
                continue;
            }
            res[key] = applyChange(src[key], dest[key]);
        } else if (src[key] !== null) {
            res[key] = src[key];
        }
    }
    return res;
}
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/database.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractInstanceAndPath = exports.RefBuilder = exports._refWithOptions = exports.InstanceBuilder = exports._instanceWithOptions = exports.ref = exports.instance = exports.service = exports.provider = exports.DataSnapshot = void 0;
const app_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/app.js [app-rsc] (ecmascript)");
const config_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/config.js [app-rsc] (ecmascript)");
const database_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/database.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "DataSnapshot", {
    enumerable: true,
    get: function() {
        return database_1.DataSnapshot;
    }
});
const path_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/utilities/path.js [app-rsc] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/utilities/utils.js [app-rsc] (ecmascript)");
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.firebase.database";
/** @internal */ exports.service = "firebaseio.com";
const databaseURLRegex = new RegExp("^https://([^.]+).");
const emulatorDatabaseURLRegex = new RegExp("^http://.*ns=([^&]+)");
/**
 * Registers a function that triggers on events from a specific
 * Firebase Realtime Database instance.
 *
 * @remarks
 * Use this method together with `ref` to specify the instance on which to
 * watch for database events. For example: `firebase.database.instance('my-app-db-2').ref('/foo/bar')`
 *
 * Note that `functions.database.ref` used without `instance` watches the
 * *default* instance for events.
 *
 * @param instance The instance name of the database instance
 *   to watch for write events.
 * @returns Firebase Realtime Database instance builder interface.
 */ function instance(instance) {
    return _instanceWithOptions(instance, {});
}
exports.instance = instance;
/**
 * Registers a function that triggers on Firebase Realtime Database write
 * events.
 *
 * @remarks
 * This method behaves very similarly to the method of the same name in the
 * client and Admin Firebase SDKs. Any change to the Database that affects the
 * data at or below the provided `path` will fire an event in Cloud Functions.
 *
 * There are three important differences between listening to a Realtime
 * Database event in Cloud Functions and using the Realtime Database in the
 * client and Admin SDKs:
 *
 * 1. Cloud Functions allows wildcards in the `path` name. Any `path` component
 *    in curly brackets (`{}`) is a wildcard that matches all strings. The value
 *    that matched a certain invocation of a Cloud Function is returned as part
 *    of the [`EventContext.params`](cloud_functions_eventcontext.html#params object. For
 *    example, `ref("messages/{messageId}")` matches changes at
 *    `/messages/message1` or `/messages/message2`, resulting in
 *    `event.params.messageId` being set to `"message1"` or `"message2"`,
 *    respectively.
 *
 * 2. Cloud Functions do not fire an event for data that already existed before
 *    the Cloud Function was deployed.
 *
 * 3. Cloud Function events have access to more information, including a
 *    snapshot of the previous event data and information about the user who
 *    triggered the Cloud Function.
 *
 * @param path The path within the Database to watch for write events.
 * @returns Firebase Realtime Database builder interface.
 */ function ref(path) {
    return _refWithOptions(path, {});
}
exports.ref = ref;
/** @internal */ function _instanceWithOptions(instance, options) {
    return new InstanceBuilder(instance, options);
}
exports._instanceWithOptions = _instanceWithOptions;
/**
 * The Firebase Realtime Database instance builder interface.
 *
 * Access via [`database.instance()`](providers_database_.html#instance).
 */ class InstanceBuilder {
    constructor(instance, options){
        this.instance = instance;
        this.options = options;
    }
    /**
     * @returns Firebase Realtime Database reference builder interface.
     */ ref(path) {
        const normalized = (0, path_1.normalizePath)(path);
        return new RefBuilder(()=>`projects/_/instances/${this.instance}/refs/${normalized}`, this.options);
    }
}
exports.InstanceBuilder = InstanceBuilder;
/** @internal */ function _refWithOptions(path, options) {
    const resourceGetter = ()=>{
        const normalized = (0, path_1.normalizePath)(path);
        const databaseURL = (0, config_1.firebaseConfig)().databaseURL;
        if (!databaseURL) {
            throw new Error("Missing expected firebase config value databaseURL, " + "config is actually" + JSON.stringify((0, config_1.firebaseConfig)()) + "\n If you are unit testing, please set process.env.FIREBASE_CONFIG");
        }
        let instance;
        const prodMatch = databaseURL.match(databaseURLRegex);
        if (prodMatch) {
            instance = prodMatch[1];
        } else {
            const emulatorMatch = databaseURL.match(emulatorDatabaseURLRegex);
            if (emulatorMatch) {
                instance = emulatorMatch[1];
            }
        }
        if (!instance) {
            throw new Error("Invalid value for config firebase.databaseURL: " + databaseURL);
        }
        return `projects/_/instances/${instance}/refs/${normalized}`;
    };
    return new RefBuilder(resourceGetter, options);
}
exports._refWithOptions = _refWithOptions;
/**
 * The Firebase Realtime Database reference builder interface.
 *
 * Access via [`functions.database.ref()`](functions.database#.ref).
 */ class RefBuilder {
    constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
        this.changeConstructor = (raw)=>{
            const [dbInstance, path] = extractInstanceAndPath(raw.context.resource.name, raw.context.domain);
            const before = new database_1.DataSnapshot(raw.data.data, path, (0, app_1.getApp)(), dbInstance);
            const after = new database_1.DataSnapshot((0, utils_1.applyChange)(raw.data.data, raw.data.delta), path, (0, app_1.getApp)(), dbInstance);
            return {
                before,
                after
            };
        };
    }
    /**
     * Event handler that fires every time a Firebase Realtime Database write
     * of any kind (creation, update, or delete) occurs.
     *
     * @param handler Event handler that runs every time a Firebase Realtime Database
     *   write occurs.
     * @returns A function that you can export and deploy.
     */ onWrite(handler) {
        return this.onOperation(handler, "ref.write", this.changeConstructor);
    }
    /**
     * Event handler that fires every time data is updated in
     * Firebase Realtime Database.
     *
     * @param handler Event handler which is run every time a Firebase Realtime Database
     *   write occurs.
     * @returns A function which you can export and deploy.
     */ onUpdate(handler) {
        return this.onOperation(handler, "ref.update", this.changeConstructor);
    }
    /**
     * Event handler that fires every time new data is created in
     * Firebase Realtime Database.
     *
     * @param handler Event handler that runs every time new data is created in
     *   Firebase Realtime Database.
     * @returns A function that you can export and deploy.
     */ onCreate(handler) {
        const dataConstructor = (raw)=>{
            const [dbInstance, path] = extractInstanceAndPath(raw.context.resource.name, raw.context.domain);
            return new database_1.DataSnapshot(raw.data.delta, path, (0, app_1.getApp)(), dbInstance);
        };
        return this.onOperation(handler, "ref.create", dataConstructor);
    }
    /**
     * Event handler that fires every time data is deleted from
     * Firebase Realtime Database.
     *
     * @param handler Event handler that runs every time data is deleted from
     *   Firebase Realtime Database.
     * @returns A function that you can export and deploy.
     */ onDelete(handler) {
        const dataConstructor = (raw)=>{
            const [dbInstance, path] = extractInstanceAndPath(raw.context.resource.name, raw.context.domain);
            return new database_1.DataSnapshot(raw.data.data, path, (0, app_1.getApp)(), dbInstance);
        };
        return this.onOperation(handler, "ref.delete", dataConstructor);
    }
    onOperation(handler, eventType, dataConstructor) {
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            service: exports.service,
            eventType,
            legacyEventType: `providers/${exports.provider}/eventTypes/${eventType}`,
            triggerResource: this.triggerResource,
            dataConstructor,
            options: this.options
        });
    }
}
exports.RefBuilder = RefBuilder;
const resourceRegex = /^projects\/([^/]+)\/instances\/([a-zA-Z0-9-]+)\/refs(\/.+)?/;
/**
 * Utility function to extract database reference from resource string
 *
 * @param optional database domain override for the original of the source database.
 *    It defaults to `firebaseio.com`.
 *    Multi-region RTDB will be served from different domains.
 *    Since region is not part of the resource name, it is provided through context.
 *
 * @internal
 */ function extractInstanceAndPath(resource, domain = "firebaseio.com") {
    const match = resource.match(new RegExp(resourceRegex));
    if (!match) {
        throw new Error(`Unexpected resource string for Firebase Realtime Database event: ${resource}. ` + 'Expected string in the format of "projects/_/instances/{firebaseioSubdomain}/refs/{ref=**}"');
    }
    const [, project, dbInstanceName, path] = match;
    if (project !== "_") {
        throw new Error(`Expect project to be '_' in a Firebase Realtime Database event`);
    }
    const emuHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;
    if (emuHost) {
        const dbInstance = `http://${emuHost}/?ns=${dbInstanceName}`;
        return [
            dbInstance,
            path
        ];
    } else {
        const dbInstance = "https://" + dbInstanceName + "." + domain;
        return [
            dbInstance,
            path
        ];
    }
}
exports.extractInstanceAndPath = extractInstanceAndPath;
}}),
"[project]/node_modules/firebase-functions/protos/compiledFirestore.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/ "use strict";
var $protobuf = __turbopack_context__.r("[project]/node_modules/protobufjs/minimal.js [app-rsc] (ecmascript)");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.google = function() {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */ var google = {};
    google.protobuf = function() {
        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */ var protobuf = {};
        protobuf.Struct = function() {
            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */ /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */ function Struct(properties) {
                this.fields = {};
                if (properties) {
                    for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
            }
            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */ Struct.prototype.fields = $util.emptyObject;
            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */ Struct.create = function create(properties) {
                return new Struct(properties);
            };
            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Struct.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.fields != null && Object.hasOwnProperty.call(message, "fields")) for(var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i){
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork().uint32(/* id 1, wireType 2 =*/ 10).string(keys[i]);
                    $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim().ldelim();
                }
                return writer;
            };
            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;
                while(reader.pos < end){
                    var tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            {
                                if (message.fields === $util.emptyObject) message.fields = {};
                                var end2 = reader.uint32() + reader.pos;
                                key = "";
                                value = null;
                                while(reader.pos < end2){
                                    var tag2 = reader.uint32();
                                    switch(tag2 >>> 3){
                                        case 1:
                                            key = reader.string();
                                            break;
                                        case 2:
                                            value = $root.google.protobuf.Value.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag2 & 7);
                                            break;
                                    }
                                }
                                message.fields[key] = value;
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */ Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields)) return "fields: object expected";
                    var key = Object.keys(message.fields);
                    for(var i = 0; i < key.length; ++i){
                        var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error) return "fields." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */ Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct) return object;
                var message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object") throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for(var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i){
                        if (typeof object.fields[keys[i]] !== "object") throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */ Struct.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (options.objects || options.defaults) object.fields = {};
                var keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for(var j = 0; j < keys2.length; ++j)object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };
            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */ Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for Struct
             * @function getTypeUrl
             * @memberof google.protobuf.Struct
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */ Struct.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Struct";
            };
            return Struct;
        }();
        protobuf.Value = function() {
            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */ /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */ function Value(properties) {
                if (properties) {
                    for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
            }
            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue|null|undefined} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */ Value.prototype.nullValue = null;
            /**
             * Value numberValue.
             * @member {number|null|undefined} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */ Value.prototype.numberValue = null;
            /**
             * Value stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */ Value.prototype.stringValue = null;
            /**
             * Value boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */ Value.prototype.boolValue = null;
            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */ Value.prototype.structValue = null;
            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */ Value.prototype.listValue = null;
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */ Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]),
                set: $util.oneOfSetter($oneOfFields)
            });
            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */ Value.create = function create(properties) {
                return new Value(properties);
            };
            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Value.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.nullValue != null && Object.hasOwnProperty.call(message, "nullValue")) writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.nullValue);
                if (message.numberValue != null && Object.hasOwnProperty.call(message, "numberValue")) writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.numberValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue")) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.stringValue);
                if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue")) writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.boolValue);
                if (message.structValue != null && Object.hasOwnProperty.call(message, "structValue")) $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
                if (message.listValue != null && Object.hasOwnProperty.call(message, "listValue")) $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while(reader.pos < end){
                    var tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            {
                                message.nullValue = reader.int32();
                                break;
                            }
                        case 2:
                            {
                                message.numberValue = reader.double();
                                break;
                            }
                        case 3:
                            {
                                message.stringValue = reader.string();
                                break;
                            }
                        case 4:
                            {
                                message.boolValue = reader.bool();
                                break;
                            }
                        case 5:
                            {
                                message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                                break;
                            }
                        case 6:
                            {
                                message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */ Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                var properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch(message.nullValue){
                        default:
                            return "nullValue: enum value expected";
                        case 0:
                            break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1) return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number") return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1) return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue)) return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1) return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean") return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1) return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error) return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1) return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error) return "listValue." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */ Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value) return object;
                var message = new $root.google.protobuf.Value();
                switch(object.nullValue){
                    default:
                        if (typeof object.nullValue === "number") {
                            message.nullValue = object.nullValue;
                            break;
                        }
                        break;
                    case "NULL_VALUE":
                    case 0:
                        message.nullValue = 0;
                        break;
                }
                if (object.numberValue != null) message.numberValue = Number(object.numberValue);
                if (object.stringValue != null) message.stringValue = String(object.stringValue);
                if (object.boolValue != null) message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object") throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object") throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };
            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */ Value.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === undefined ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs) object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs) object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs) object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs) object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs) object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs) object.kind = "listValue";
                }
                return object;
            };
            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */ Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for Value
             * @function getTypeUrl
             * @memberof google.protobuf.Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */ Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Value";
            };
            return Value;
        }();
        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {number}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */ protobuf.NullValue = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        }();
        protobuf.ListValue = function() {
            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */ /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */ function ListValue(properties) {
                this.values = [];
                if (properties) {
                    for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
            }
            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */ ListValue.prototype.values = $util.emptyArray;
            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */ ListValue.create = function create(properties) {
                return new ListValue(properties);
            };
            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ ListValue.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.values != null && message.values.length) for(var i = 0; i < message.values.length; ++i)$root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                return writer;
            };
            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while(reader.pos < end){
                    var tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            {
                                if (!(message.values && message.values.length)) message.values = [];
                                message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */ ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values)) return "values: array expected";
                    for(var i = 0; i < message.values.length; ++i){
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error) return "values." + error;
                    }
                }
                return null;
            };
            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */ ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue) return object;
                var message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values)) throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for(var i = 0; i < object.values.length; ++i){
                        if (typeof object.values[i] !== "object") throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };
            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */ ListValue.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (options.arrays || options.defaults) object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for(var j = 0; j < message.values.length; ++j)object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };
            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */ ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for ListValue
             * @function getTypeUrl
             * @memberof google.protobuf.ListValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */ ListValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ListValue";
            };
            return ListValue;
        }();
        protobuf.Timestamp = function() {
            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */ /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */ function Timestamp(properties) {
                if (properties) {
                    for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
            }
            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */ Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */ Timestamp.prototype.nanos = 0;
            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */ Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };
            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Timestamp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds")) writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos")) writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
                return writer;
            };
            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while(reader.pos < end){
                    var tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            {
                                message.seconds = reader.int64();
                                break;
                            }
                        case 2:
                            {
                                message.nanos = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */ Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds")) {
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return "seconds: integer|Long expected";
                }
                if (message.nanos != null && message.hasOwnProperty("nanos")) {
                    if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
                }
                return null;
            };
            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */ Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp) return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null) {
                    if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string") message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number") message.seconds = object.seconds;
                    else if (typeof object.seconds === "object") message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                }
                if (object.nanos != null) message.nanos = object.nanos | 0;
                return message;
            };
            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */ Timestamp.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds")) if (typeof message.seconds === "number") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos")) object.nanos = message.nanos;
                return object;
            };
            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */ Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for Timestamp
             * @function getTypeUrl
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */ Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Timestamp";
            };
            return Timestamp;
        }();
        protobuf.Any = function() {
            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [typeUrl] Any typeUrl
             * @property {Uint8Array|null} [value] Any value
             */ /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */ function Any(properties) {
                if (properties) {
                    for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
            }
            /**
             * Any typeUrl.
             * @member {string} typeUrl
             * @memberof google.protobuf.Any
             * @instance
             */ Any.prototype.typeUrl = "";
            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */ Any.prototype.value = $util.newBuffer([]);
            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */ Any.create = function create(properties) {
                return new Any(properties);
            };
            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Any.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.typeUrl != null && Object.hasOwnProperty.call(message, "typeUrl")) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.typeUrl);
                if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
                return writer;
            };
            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while(reader.pos < end){
                    var tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            {
                                message.typeUrl = reader.string();
                                break;
                            }
                        case 2:
                            {
                                message.value = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */ Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.typeUrl != null && message.hasOwnProperty("typeUrl")) {
                    if (!$util.isString(message.typeUrl)) return "typeUrl: string expected";
                }
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value))) return "value: buffer expected";
                }
                return null;
            };
            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */ Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any) return object;
                var message = new $root.google.protobuf.Any();
                if (object.typeUrl != null) message.typeUrl = String(object.typeUrl);
                if (object.value != null) {
                    if (typeof object.value === "string") $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0) message.value = object.value;
                }
                return message;
            };
            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */ Any.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (options.defaults) {
                    object.typeUrl = "";
                    if (options.bytes === String) object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.typeUrl != null && message.hasOwnProperty("typeUrl")) object.typeUrl = message.typeUrl;
                if (message.value != null && message.hasOwnProperty("value")) object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */ Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for Any
             * @function getTypeUrl
             * @memberof google.protobuf.Any
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */ Any.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Any";
            };
            return Any;
        }();
        return protobuf;
    }();
    google.events = function() {
        /**
         * Namespace events.
         * @memberof google
         * @namespace
         */ var events = {};
        events.cloud = function() {
            /**
             * Namespace cloud.
             * @memberof google.events
             * @namespace
             */ var cloud = {};
            cloud.firestore = function() {
                /**
                 * Namespace firestore.
                 * @memberof google.events.cloud
                 * @namespace
                 */ var firestore = {};
                firestore.v1 = function() {
                    /**
                     * Namespace v1.
                     * @memberof google.events.cloud.firestore
                     * @namespace
                     */ var v1 = {};
                    v1.DocumentEventData = function() {
                        /**
                         * Properties of a DocumentEventData.
                         * @memberof google.events.cloud.firestore.v1
                         * @interface IDocumentEventData
                         * @property {google.events.cloud.firestore.v1.IDocument|null} [value] DocumentEventData value
                         * @property {google.events.cloud.firestore.v1.IDocument|null} [oldValue] DocumentEventData oldValue
                         * @property {google.events.cloud.firestore.v1.IDocumentMask|null} [updateMask] DocumentEventData updateMask
                         */ /**
                         * Constructs a new DocumentEventData.
                         * @memberof google.events.cloud.firestore.v1
                         * @classdesc Represents a DocumentEventData.
                         * @implements IDocumentEventData
                         * @constructor
                         * @param {google.events.cloud.firestore.v1.IDocumentEventData=} [properties] Properties to set
                         */ function DocumentEventData(properties) {
                            if (properties) {
                                for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                            }
                        }
                        /**
                         * DocumentEventData value.
                         * @member {google.events.cloud.firestore.v1.IDocument|null|undefined} value
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @instance
                         */ DocumentEventData.prototype.value = null;
                        /**
                         * DocumentEventData oldValue.
                         * @member {google.events.cloud.firestore.v1.IDocument|null|undefined} oldValue
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @instance
                         */ DocumentEventData.prototype.oldValue = null;
                        /**
                         * DocumentEventData updateMask.
                         * @member {google.events.cloud.firestore.v1.IDocumentMask|null|undefined} updateMask
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @instance
                         */ DocumentEventData.prototype.updateMask = null;
                        /**
                         * Creates a new DocumentEventData instance using the specified properties.
                         * @function create
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocumentEventData=} [properties] Properties to set
                         * @returns {google.events.cloud.firestore.v1.DocumentEventData} DocumentEventData instance
                         */ DocumentEventData.create = function create(properties) {
                            return new DocumentEventData(properties);
                        };
                        /**
                         * Encodes the specified DocumentEventData message. Does not implicitly {@link google.events.cloud.firestore.v1.DocumentEventData.verify|verify} messages.
                         * @function encode
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocumentEventData} message DocumentEventData message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ DocumentEventData.encode = function encode(message, writer) {
                            if (!writer) writer = $Writer.create();
                            if (message.value != null && Object.hasOwnProperty.call(message, "value")) $root.google.events.cloud.firestore.v1.Document.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                            if (message.oldValue != null && Object.hasOwnProperty.call(message, "oldValue")) $root.google.events.cloud.firestore.v1.Document.encode(message.oldValue, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
                            if (message.updateMask != null && Object.hasOwnProperty.call(message, "updateMask")) $root.google.events.cloud.firestore.v1.DocumentMask.encode(message.updateMask, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                            return writer;
                        };
                        /**
                         * Encodes the specified DocumentEventData message, length delimited. Does not implicitly {@link google.events.cloud.firestore.v1.DocumentEventData.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocumentEventData} message DocumentEventData message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ DocumentEventData.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
                        /**
                         * Decodes a DocumentEventData message from the specified reader or buffer.
                         * @function decode
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {google.events.cloud.firestore.v1.DocumentEventData} DocumentEventData
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ DocumentEventData.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.events.cloud.firestore.v1.DocumentEventData();
                            while(reader.pos < end){
                                var tag = reader.uint32();
                                switch(tag >>> 3){
                                    case 1:
                                        {
                                            message.value = $root.google.events.cloud.firestore.v1.Document.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 2:
                                        {
                                            message.oldValue = $root.google.events.cloud.firestore.v1.Document.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 3:
                                        {
                                            message.updateMask = $root.google.events.cloud.firestore.v1.DocumentMask.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                }
                            }
                            return message;
                        };
                        /**
                         * Decodes a DocumentEventData message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {google.events.cloud.firestore.v1.DocumentEventData} DocumentEventData
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ DocumentEventData.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
                        /**
                         * Verifies a DocumentEventData message.
                         * @function verify
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */ DocumentEventData.verify = function verify(message) {
                            if (typeof message !== "object" || message === null) return "object expected";
                            if (message.value != null && message.hasOwnProperty("value")) {
                                var error = $root.google.events.cloud.firestore.v1.Document.verify(message.value);
                                if (error) return "value." + error;
                            }
                            if (message.oldValue != null && message.hasOwnProperty("oldValue")) {
                                var error = $root.google.events.cloud.firestore.v1.Document.verify(message.oldValue);
                                if (error) return "oldValue." + error;
                            }
                            if (message.updateMask != null && message.hasOwnProperty("updateMask")) {
                                var error = $root.google.events.cloud.firestore.v1.DocumentMask.verify(message.updateMask);
                                if (error) return "updateMask." + error;
                            }
                            return null;
                        };
                        /**
                         * Creates a DocumentEventData message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {google.events.cloud.firestore.v1.DocumentEventData} DocumentEventData
                         */ DocumentEventData.fromObject = function fromObject(object) {
                            if (object instanceof $root.google.events.cloud.firestore.v1.DocumentEventData) return object;
                            var message = new $root.google.events.cloud.firestore.v1.DocumentEventData();
                            if (object.value != null) {
                                if (typeof object.value !== "object") throw TypeError(".google.events.cloud.firestore.v1.DocumentEventData.value: object expected");
                                message.value = $root.google.events.cloud.firestore.v1.Document.fromObject(object.value);
                            }
                            if (object.oldValue != null) {
                                if (typeof object.oldValue !== "object") throw TypeError(".google.events.cloud.firestore.v1.DocumentEventData.oldValue: object expected");
                                message.oldValue = $root.google.events.cloud.firestore.v1.Document.fromObject(object.oldValue);
                            }
                            if (object.updateMask != null) {
                                if (typeof object.updateMask !== "object") throw TypeError(".google.events.cloud.firestore.v1.DocumentEventData.updateMask: object expected");
                                message.updateMask = $root.google.events.cloud.firestore.v1.DocumentMask.fromObject(object.updateMask);
                            }
                            return message;
                        };
                        /**
                         * Creates a plain object from a DocumentEventData message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {google.events.cloud.firestore.v1.DocumentEventData} message DocumentEventData
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */ DocumentEventData.toObject = function toObject(message, options) {
                            if (!options) options = {};
                            var object = {};
                            if (options.defaults) {
                                object.value = null;
                                object.oldValue = null;
                                object.updateMask = null;
                            }
                            if (message.value != null && message.hasOwnProperty("value")) object.value = $root.google.events.cloud.firestore.v1.Document.toObject(message.value, options);
                            if (message.oldValue != null && message.hasOwnProperty("oldValue")) object.oldValue = $root.google.events.cloud.firestore.v1.Document.toObject(message.oldValue, options);
                            if (message.updateMask != null && message.hasOwnProperty("updateMask")) object.updateMask = $root.google.events.cloud.firestore.v1.DocumentMask.toObject(message.updateMask, options);
                            return object;
                        };
                        /**
                         * Converts this DocumentEventData to JSON.
                         * @function toJSON
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */ DocumentEventData.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
                        /**
                         * Gets the default type url for DocumentEventData
                         * @function getTypeUrl
                         * @memberof google.events.cloud.firestore.v1.DocumentEventData
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */ DocumentEventData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/google.events.cloud.firestore.v1.DocumentEventData";
                        };
                        return DocumentEventData;
                    }();
                    v1.DocumentMask = function() {
                        /**
                         * Properties of a DocumentMask.
                         * @memberof google.events.cloud.firestore.v1
                         * @interface IDocumentMask
                         * @property {Array.<string>|null} [fieldPaths] DocumentMask fieldPaths
                         */ /**
                         * Constructs a new DocumentMask.
                         * @memberof google.events.cloud.firestore.v1
                         * @classdesc Represents a DocumentMask.
                         * @implements IDocumentMask
                         * @constructor
                         * @param {google.events.cloud.firestore.v1.IDocumentMask=} [properties] Properties to set
                         */ function DocumentMask(properties) {
                            this.fieldPaths = [];
                            if (properties) {
                                for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                            }
                        }
                        /**
                         * DocumentMask fieldPaths.
                         * @member {Array.<string>} fieldPaths
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @instance
                         */ DocumentMask.prototype.fieldPaths = $util.emptyArray;
                        /**
                         * Creates a new DocumentMask instance using the specified properties.
                         * @function create
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocumentMask=} [properties] Properties to set
                         * @returns {google.events.cloud.firestore.v1.DocumentMask} DocumentMask instance
                         */ DocumentMask.create = function create(properties) {
                            return new DocumentMask(properties);
                        };
                        /**
                         * Encodes the specified DocumentMask message. Does not implicitly {@link google.events.cloud.firestore.v1.DocumentMask.verify|verify} messages.
                         * @function encode
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocumentMask} message DocumentMask message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ DocumentMask.encode = function encode(message, writer) {
                            if (!writer) writer = $Writer.create();
                            if (message.fieldPaths != null && message.fieldPaths.length) for(var i = 0; i < message.fieldPaths.length; ++i)writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.fieldPaths[i]);
                            return writer;
                        };
                        /**
                         * Encodes the specified DocumentMask message, length delimited. Does not implicitly {@link google.events.cloud.firestore.v1.DocumentMask.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocumentMask} message DocumentMask message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ DocumentMask.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
                        /**
                         * Decodes a DocumentMask message from the specified reader or buffer.
                         * @function decode
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {google.events.cloud.firestore.v1.DocumentMask} DocumentMask
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ DocumentMask.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.events.cloud.firestore.v1.DocumentMask();
                            while(reader.pos < end){
                                var tag = reader.uint32();
                                switch(tag >>> 3){
                                    case 1:
                                        {
                                            if (!(message.fieldPaths && message.fieldPaths.length)) message.fieldPaths = [];
                                            message.fieldPaths.push(reader.string());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                }
                            }
                            return message;
                        };
                        /**
                         * Decodes a DocumentMask message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {google.events.cloud.firestore.v1.DocumentMask} DocumentMask
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ DocumentMask.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
                        /**
                         * Verifies a DocumentMask message.
                         * @function verify
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */ DocumentMask.verify = function verify(message) {
                            if (typeof message !== "object" || message === null) return "object expected";
                            if (message.fieldPaths != null && message.hasOwnProperty("fieldPaths")) {
                                if (!Array.isArray(message.fieldPaths)) return "fieldPaths: array expected";
                                for(var i = 0; i < message.fieldPaths.length; ++i)if (!$util.isString(message.fieldPaths[i])) return "fieldPaths: string[] expected";
                            }
                            return null;
                        };
                        /**
                         * Creates a DocumentMask message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {google.events.cloud.firestore.v1.DocumentMask} DocumentMask
                         */ DocumentMask.fromObject = function fromObject(object) {
                            if (object instanceof $root.google.events.cloud.firestore.v1.DocumentMask) return object;
                            var message = new $root.google.events.cloud.firestore.v1.DocumentMask();
                            if (object.fieldPaths) {
                                if (!Array.isArray(object.fieldPaths)) throw TypeError(".google.events.cloud.firestore.v1.DocumentMask.fieldPaths: array expected");
                                message.fieldPaths = [];
                                for(var i = 0; i < object.fieldPaths.length; ++i)message.fieldPaths[i] = String(object.fieldPaths[i]);
                            }
                            return message;
                        };
                        /**
                         * Creates a plain object from a DocumentMask message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {google.events.cloud.firestore.v1.DocumentMask} message DocumentMask
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */ DocumentMask.toObject = function toObject(message, options) {
                            if (!options) options = {};
                            var object = {};
                            if (options.arrays || options.defaults) object.fieldPaths = [];
                            if (message.fieldPaths && message.fieldPaths.length) {
                                object.fieldPaths = [];
                                for(var j = 0; j < message.fieldPaths.length; ++j)object.fieldPaths[j] = message.fieldPaths[j];
                            }
                            return object;
                        };
                        /**
                         * Converts this DocumentMask to JSON.
                         * @function toJSON
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */ DocumentMask.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
                        /**
                         * Gets the default type url for DocumentMask
                         * @function getTypeUrl
                         * @memberof google.events.cloud.firestore.v1.DocumentMask
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */ DocumentMask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/google.events.cloud.firestore.v1.DocumentMask";
                        };
                        return DocumentMask;
                    }();
                    v1.Document = function() {
                        /**
                         * Properties of a Document.
                         * @memberof google.events.cloud.firestore.v1
                         * @interface IDocument
                         * @property {string|null} [name] Document name
                         * @property {Object.<string,google.events.cloud.firestore.v1.IValue>|null} [fields] Document fields
                         * @property {google.protobuf.ITimestamp|null} [createTime] Document createTime
                         * @property {google.protobuf.ITimestamp|null} [updateTime] Document updateTime
                         */ /**
                         * Constructs a new Document.
                         * @memberof google.events.cloud.firestore.v1
                         * @classdesc Represents a Document.
                         * @implements IDocument
                         * @constructor
                         * @param {google.events.cloud.firestore.v1.IDocument=} [properties] Properties to set
                         */ function Document(properties) {
                            this.fields = {};
                            if (properties) {
                                for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                            }
                        }
                        /**
                         * Document name.
                         * @member {string} name
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @instance
                         */ Document.prototype.name = "";
                        /**
                         * Document fields.
                         * @member {Object.<string,google.events.cloud.firestore.v1.IValue>} fields
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @instance
                         */ Document.prototype.fields = $util.emptyObject;
                        /**
                         * Document createTime.
                         * @member {google.protobuf.ITimestamp|null|undefined} createTime
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @instance
                         */ Document.prototype.createTime = null;
                        /**
                         * Document updateTime.
                         * @member {google.protobuf.ITimestamp|null|undefined} updateTime
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @instance
                         */ Document.prototype.updateTime = null;
                        /**
                         * Creates a new Document instance using the specified properties.
                         * @function create
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocument=} [properties] Properties to set
                         * @returns {google.events.cloud.firestore.v1.Document} Document instance
                         */ Document.create = function create(properties) {
                            return new Document(properties);
                        };
                        /**
                         * Encodes the specified Document message. Does not implicitly {@link google.events.cloud.firestore.v1.Document.verify|verify} messages.
                         * @function encode
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocument} message Document message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ Document.encode = function encode(message, writer) {
                            if (!writer) writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name")) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
                            if (message.fields != null && Object.hasOwnProperty.call(message, "fields")) for(var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i){
                                writer.uint32(/* id 2, wireType 2 =*/ 18).fork().uint32(/* id 1, wireType 2 =*/ 10).string(keys[i]);
                                $root.google.events.cloud.firestore.v1.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim().ldelim();
                            }
                            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime")) $root.google.protobuf.Timestamp.encode(message.createTime, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
                            if (message.updateTime != null && Object.hasOwnProperty.call(message, "updateTime")) $root.google.protobuf.Timestamp.encode(message.updateTime, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
                            return writer;
                        };
                        /**
                         * Encodes the specified Document message, length delimited. Does not implicitly {@link google.events.cloud.firestore.v1.Document.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {google.events.cloud.firestore.v1.IDocument} message Document message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ Document.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
                        /**
                         * Decodes a Document message from the specified reader or buffer.
                         * @function decode
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {google.events.cloud.firestore.v1.Document} Document
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ Document.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.events.cloud.firestore.v1.Document(), key, value;
                            while(reader.pos < end){
                                var tag = reader.uint32();
                                switch(tag >>> 3){
                                    case 1:
                                        {
                                            message.name = reader.string();
                                            break;
                                        }
                                    case 2:
                                        {
                                            if (message.fields === $util.emptyObject) message.fields = {};
                                            var end2 = reader.uint32() + reader.pos;
                                            key = "";
                                            value = null;
                                            while(reader.pos < end2){
                                                var tag2 = reader.uint32();
                                                switch(tag2 >>> 3){
                                                    case 1:
                                                        key = reader.string();
                                                        break;
                                                    case 2:
                                                        value = $root.google.events.cloud.firestore.v1.Value.decode(reader, reader.uint32());
                                                        break;
                                                    default:
                                                        reader.skipType(tag2 & 7);
                                                        break;
                                                }
                                            }
                                            message.fields[key] = value;
                                            break;
                                        }
                                    case 3:
                                        {
                                            message.createTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 4:
                                        {
                                            message.updateTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                }
                            }
                            return message;
                        };
                        /**
                         * Decodes a Document message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {google.events.cloud.firestore.v1.Document} Document
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ Document.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
                        /**
                         * Verifies a Document message.
                         * @function verify
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */ Document.verify = function verify(message) {
                            if (typeof message !== "object" || message === null) return "object expected";
                            if (message.name != null && message.hasOwnProperty("name")) {
                                if (!$util.isString(message.name)) return "name: string expected";
                            }
                            if (message.fields != null && message.hasOwnProperty("fields")) {
                                if (!$util.isObject(message.fields)) return "fields: object expected";
                                var key = Object.keys(message.fields);
                                for(var i = 0; i < key.length; ++i){
                                    var error = $root.google.events.cloud.firestore.v1.Value.verify(message.fields[key[i]]);
                                    if (error) return "fields." + error;
                                }
                            }
                            if (message.createTime != null && message.hasOwnProperty("createTime")) {
                                var error = $root.google.protobuf.Timestamp.verify(message.createTime);
                                if (error) return "createTime." + error;
                            }
                            if (message.updateTime != null && message.hasOwnProperty("updateTime")) {
                                var error = $root.google.protobuf.Timestamp.verify(message.updateTime);
                                if (error) return "updateTime." + error;
                            }
                            return null;
                        };
                        /**
                         * Creates a Document message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {google.events.cloud.firestore.v1.Document} Document
                         */ Document.fromObject = function fromObject(object) {
                            if (object instanceof $root.google.events.cloud.firestore.v1.Document) return object;
                            var message = new $root.google.events.cloud.firestore.v1.Document();
                            if (object.name != null) message.name = String(object.name);
                            if (object.fields) {
                                if (typeof object.fields !== "object") throw TypeError(".google.events.cloud.firestore.v1.Document.fields: object expected");
                                message.fields = {};
                                for(var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i){
                                    if (typeof object.fields[keys[i]] !== "object") throw TypeError(".google.events.cloud.firestore.v1.Document.fields: object expected");
                                    message.fields[keys[i]] = $root.google.events.cloud.firestore.v1.Value.fromObject(object.fields[keys[i]]);
                                }
                            }
                            if (object.createTime != null) {
                                if (typeof object.createTime !== "object") throw TypeError(".google.events.cloud.firestore.v1.Document.createTime: object expected");
                                message.createTime = $root.google.protobuf.Timestamp.fromObject(object.createTime);
                            }
                            if (object.updateTime != null) {
                                if (typeof object.updateTime !== "object") throw TypeError(".google.events.cloud.firestore.v1.Document.updateTime: object expected");
                                message.updateTime = $root.google.protobuf.Timestamp.fromObject(object.updateTime);
                            }
                            return message;
                        };
                        /**
                         * Creates a plain object from a Document message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {google.events.cloud.firestore.v1.Document} message Document
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */ Document.toObject = function toObject(message, options) {
                            if (!options) options = {};
                            var object = {};
                            if (options.objects || options.defaults) object.fields = {};
                            if (options.defaults) {
                                object.name = "";
                                object.createTime = null;
                                object.updateTime = null;
                            }
                            if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
                            var keys2;
                            if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                                object.fields = {};
                                for(var j = 0; j < keys2.length; ++j)object.fields[keys2[j]] = $root.google.events.cloud.firestore.v1.Value.toObject(message.fields[keys2[j]], options);
                            }
                            if (message.createTime != null && message.hasOwnProperty("createTime")) object.createTime = $root.google.protobuf.Timestamp.toObject(message.createTime, options);
                            if (message.updateTime != null && message.hasOwnProperty("updateTime")) object.updateTime = $root.google.protobuf.Timestamp.toObject(message.updateTime, options);
                            return object;
                        };
                        /**
                         * Converts this Document to JSON.
                         * @function toJSON
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */ Document.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
                        /**
                         * Gets the default type url for Document
                         * @function getTypeUrl
                         * @memberof google.events.cloud.firestore.v1.Document
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */ Document.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/google.events.cloud.firestore.v1.Document";
                        };
                        return Document;
                    }();
                    v1.Value = function() {
                        /**
                         * Properties of a Value.
                         * @memberof google.events.cloud.firestore.v1
                         * @interface IValue
                         * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
                         * @property {boolean|null} [booleanValue] Value booleanValue
                         * @property {number|Long|null} [integerValue] Value integerValue
                         * @property {number|null} [doubleValue] Value doubleValue
                         * @property {google.protobuf.ITimestamp|null} [timestampValue] Value timestampValue
                         * @property {string|null} [stringValue] Value stringValue
                         * @property {Uint8Array|null} [bytesValue] Value bytesValue
                         * @property {string|null} [referenceValue] Value referenceValue
                         * @property {google.type.ILatLng|null} [geoPointValue] Value geoPointValue
                         * @property {google.events.cloud.firestore.v1.IArrayValue|null} [arrayValue] Value arrayValue
                         * @property {google.events.cloud.firestore.v1.IMapValue|null} [mapValue] Value mapValue
                         */ /**
                         * Constructs a new Value.
                         * @memberof google.events.cloud.firestore.v1
                         * @classdesc Represents a Value.
                         * @implements IValue
                         * @constructor
                         * @param {google.events.cloud.firestore.v1.IValue=} [properties] Properties to set
                         */ function Value(properties) {
                            if (properties) {
                                for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                            }
                        }
                        /**
                         * Value nullValue.
                         * @member {google.protobuf.NullValue|null|undefined} nullValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.nullValue = null;
                        /**
                         * Value booleanValue.
                         * @member {boolean|null|undefined} booleanValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.booleanValue = null;
                        /**
                         * Value integerValue.
                         * @member {number|Long|null|undefined} integerValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.integerValue = null;
                        /**
                         * Value doubleValue.
                         * @member {number|null|undefined} doubleValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.doubleValue = null;
                        /**
                         * Value timestampValue.
                         * @member {google.protobuf.ITimestamp|null|undefined} timestampValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.timestampValue = null;
                        /**
                         * Value stringValue.
                         * @member {string|null|undefined} stringValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.stringValue = null;
                        /**
                         * Value bytesValue.
                         * @member {Uint8Array|null|undefined} bytesValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.bytesValue = null;
                        /**
                         * Value referenceValue.
                         * @member {string|null|undefined} referenceValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.referenceValue = null;
                        /**
                         * Value geoPointValue.
                         * @member {google.type.ILatLng|null|undefined} geoPointValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.geoPointValue = null;
                        /**
                         * Value arrayValue.
                         * @member {google.events.cloud.firestore.v1.IArrayValue|null|undefined} arrayValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.arrayValue = null;
                        /**
                         * Value mapValue.
                         * @member {google.events.cloud.firestore.v1.IMapValue|null|undefined} mapValue
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Value.prototype.mapValue = null;
                        // OneOf field names bound to virtual getters and setters
                        var $oneOfFields;
                        /**
                         * Value valueType.
                         * @member {"nullValue"|"booleanValue"|"integerValue"|"doubleValue"|"timestampValue"|"stringValue"|"bytesValue"|"referenceValue"|"geoPointValue"|"arrayValue"|"mapValue"|undefined} valueType
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         */ Object.defineProperty(Value.prototype, "valueType", {
                            get: $util.oneOfGetter($oneOfFields = [
                                "nullValue",
                                "booleanValue",
                                "integerValue",
                                "doubleValue",
                                "timestampValue",
                                "stringValue",
                                "bytesValue",
                                "referenceValue",
                                "geoPointValue",
                                "arrayValue",
                                "mapValue"
                            ]),
                            set: $util.oneOfSetter($oneOfFields)
                        });
                        /**
                         * Creates a new Value instance using the specified properties.
                         * @function create
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {google.events.cloud.firestore.v1.IValue=} [properties] Properties to set
                         * @returns {google.events.cloud.firestore.v1.Value} Value instance
                         */ Value.create = function create(properties) {
                            return new Value(properties);
                        };
                        /**
                         * Encodes the specified Value message. Does not implicitly {@link google.events.cloud.firestore.v1.Value.verify|verify} messages.
                         * @function encode
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {google.events.cloud.firestore.v1.IValue} message Value message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ Value.encode = function encode(message, writer) {
                            if (!writer) writer = $Writer.create();
                            if (message.booleanValue != null && Object.hasOwnProperty.call(message, "booleanValue")) writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.booleanValue);
                            if (message.integerValue != null && Object.hasOwnProperty.call(message, "integerValue")) writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.integerValue);
                            if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue")) writer.uint32(/* id 3, wireType 1 =*/ 25).double(message.doubleValue);
                            if (message.referenceValue != null && Object.hasOwnProperty.call(message, "referenceValue")) writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.referenceValue);
                            if (message.mapValue != null && Object.hasOwnProperty.call(message, "mapValue")) $root.google.events.cloud.firestore.v1.MapValue.encode(message.mapValue, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
                            if (message.geoPointValue != null && Object.hasOwnProperty.call(message, "geoPointValue")) $root.google.type.LatLng.encode(message.geoPointValue, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
                            if (message.arrayValue != null && Object.hasOwnProperty.call(message, "arrayValue")) $root.google.events.cloud.firestore.v1.ArrayValue.encode(message.arrayValue, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
                            if (message.timestampValue != null && Object.hasOwnProperty.call(message, "timestampValue")) $root.google.protobuf.Timestamp.encode(message.timestampValue, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
                            if (message.nullValue != null && Object.hasOwnProperty.call(message, "nullValue")) writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.nullValue);
                            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue")) writer.uint32(/* id 17, wireType 2 =*/ 138).string(message.stringValue);
                            if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue")) writer.uint32(/* id 18, wireType 2 =*/ 146).bytes(message.bytesValue);
                            return writer;
                        };
                        /**
                         * Encodes the specified Value message, length delimited. Does not implicitly {@link google.events.cloud.firestore.v1.Value.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {google.events.cloud.firestore.v1.IValue} message Value message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ Value.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
                        /**
                         * Decodes a Value message from the specified reader or buffer.
                         * @function decode
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {google.events.cloud.firestore.v1.Value} Value
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ Value.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.events.cloud.firestore.v1.Value();
                            while(reader.pos < end){
                                var tag = reader.uint32();
                                switch(tag >>> 3){
                                    case 11:
                                        {
                                            message.nullValue = reader.int32();
                                            break;
                                        }
                                    case 1:
                                        {
                                            message.booleanValue = reader.bool();
                                            break;
                                        }
                                    case 2:
                                        {
                                            message.integerValue = reader.int64();
                                            break;
                                        }
                                    case 3:
                                        {
                                            message.doubleValue = reader.double();
                                            break;
                                        }
                                    case 10:
                                        {
                                            message.timestampValue = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 17:
                                        {
                                            message.stringValue = reader.string();
                                            break;
                                        }
                                    case 18:
                                        {
                                            message.bytesValue = reader.bytes();
                                            break;
                                        }
                                    case 5:
                                        {
                                            message.referenceValue = reader.string();
                                            break;
                                        }
                                    case 8:
                                        {
                                            message.geoPointValue = $root.google.type.LatLng.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 9:
                                        {
                                            message.arrayValue = $root.google.events.cloud.firestore.v1.ArrayValue.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 6:
                                        {
                                            message.mapValue = $root.google.events.cloud.firestore.v1.MapValue.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                }
                            }
                            return message;
                        };
                        /**
                         * Decodes a Value message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {google.events.cloud.firestore.v1.Value} Value
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ Value.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
                        /**
                         * Verifies a Value message.
                         * @function verify
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */ Value.verify = function verify(message) {
                            if (typeof message !== "object" || message === null) return "object expected";
                            var properties = {};
                            if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                                properties.valueType = 1;
                                switch(message.nullValue){
                                    default:
                                        return "nullValue: enum value expected";
                                    case 0:
                                        break;
                                }
                            }
                            if (message.booleanValue != null && message.hasOwnProperty("booleanValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                if (typeof message.booleanValue !== "boolean") return "booleanValue: boolean expected";
                            }
                            if (message.integerValue != null && message.hasOwnProperty("integerValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                if (!$util.isInteger(message.integerValue) && !(message.integerValue && $util.isInteger(message.integerValue.low) && $util.isInteger(message.integerValue.high))) return "integerValue: integer|Long expected";
                            }
                            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                if (typeof message.doubleValue !== "number") return "doubleValue: number expected";
                            }
                            if (message.timestampValue != null && message.hasOwnProperty("timestampValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                {
                                    var error = $root.google.protobuf.Timestamp.verify(message.timestampValue);
                                    if (error) return "timestampValue." + error;
                                }
                            }
                            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                if (!$util.isString(message.stringValue)) return "stringValue: string expected";
                            }
                            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue))) return "bytesValue: buffer expected";
                            }
                            if (message.referenceValue != null && message.hasOwnProperty("referenceValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                if (!$util.isString(message.referenceValue)) return "referenceValue: string expected";
                            }
                            if (message.geoPointValue != null && message.hasOwnProperty("geoPointValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                {
                                    var error = $root.google.type.LatLng.verify(message.geoPointValue);
                                    if (error) return "geoPointValue." + error;
                                }
                            }
                            if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                {
                                    var error = $root.google.events.cloud.firestore.v1.ArrayValue.verify(message.arrayValue);
                                    if (error) return "arrayValue." + error;
                                }
                            }
                            if (message.mapValue != null && message.hasOwnProperty("mapValue")) {
                                if (properties.valueType === 1) return "valueType: multiple values";
                                properties.valueType = 1;
                                {
                                    var error = $root.google.events.cloud.firestore.v1.MapValue.verify(message.mapValue);
                                    if (error) return "mapValue." + error;
                                }
                            }
                            return null;
                        };
                        /**
                         * Creates a Value message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {google.events.cloud.firestore.v1.Value} Value
                         */ Value.fromObject = function fromObject(object) {
                            if (object instanceof $root.google.events.cloud.firestore.v1.Value) return object;
                            var message = new $root.google.events.cloud.firestore.v1.Value();
                            switch(object.nullValue){
                                default:
                                    if (typeof object.nullValue === "number") {
                                        message.nullValue = object.nullValue;
                                        break;
                                    }
                                    break;
                                case "NULL_VALUE":
                                case 0:
                                    message.nullValue = 0;
                                    break;
                            }
                            if (object.booleanValue != null) message.booleanValue = Boolean(object.booleanValue);
                            if (object.integerValue != null) {
                                if ($util.Long) (message.integerValue = $util.Long.fromValue(object.integerValue)).unsigned = false;
                                else if (typeof object.integerValue === "string") message.integerValue = parseInt(object.integerValue, 10);
                                else if (typeof object.integerValue === "number") message.integerValue = object.integerValue;
                                else if (typeof object.integerValue === "object") message.integerValue = new $util.LongBits(object.integerValue.low >>> 0, object.integerValue.high >>> 0).toNumber();
                            }
                            if (object.doubleValue != null) message.doubleValue = Number(object.doubleValue);
                            if (object.timestampValue != null) {
                                if (typeof object.timestampValue !== "object") throw TypeError(".google.events.cloud.firestore.v1.Value.timestampValue: object expected");
                                message.timestampValue = $root.google.protobuf.Timestamp.fromObject(object.timestampValue);
                            }
                            if (object.stringValue != null) message.stringValue = String(object.stringValue);
                            if (object.bytesValue != null) {
                                if (typeof object.bytesValue === "string") $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                                else if (object.bytesValue.length >= 0) message.bytesValue = object.bytesValue;
                            }
                            if (object.referenceValue != null) message.referenceValue = String(object.referenceValue);
                            if (object.geoPointValue != null) {
                                if (typeof object.geoPointValue !== "object") throw TypeError(".google.events.cloud.firestore.v1.Value.geoPointValue: object expected");
                                message.geoPointValue = $root.google.type.LatLng.fromObject(object.geoPointValue);
                            }
                            if (object.arrayValue != null) {
                                if (typeof object.arrayValue !== "object") throw TypeError(".google.events.cloud.firestore.v1.Value.arrayValue: object expected");
                                message.arrayValue = $root.google.events.cloud.firestore.v1.ArrayValue.fromObject(object.arrayValue);
                            }
                            if (object.mapValue != null) {
                                if (typeof object.mapValue !== "object") throw TypeError(".google.events.cloud.firestore.v1.Value.mapValue: object expected");
                                message.mapValue = $root.google.events.cloud.firestore.v1.MapValue.fromObject(object.mapValue);
                            }
                            return message;
                        };
                        /**
                         * Creates a plain object from a Value message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {google.events.cloud.firestore.v1.Value} message Value
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */ Value.toObject = function toObject(message, options) {
                            if (!options) options = {};
                            var object = {};
                            if (message.booleanValue != null && message.hasOwnProperty("booleanValue")) {
                                object.booleanValue = message.booleanValue;
                                if (options.oneofs) object.valueType = "booleanValue";
                            }
                            if (message.integerValue != null && message.hasOwnProperty("integerValue")) {
                                if (typeof message.integerValue === "number") object.integerValue = options.longs === String ? String(message.integerValue) : message.integerValue;
                                else object.integerValue = options.longs === String ? $util.Long.prototype.toString.call(message.integerValue) : options.longs === Number ? new $util.LongBits(message.integerValue.low >>> 0, message.integerValue.high >>> 0).toNumber() : message.integerValue;
                                if (options.oneofs) object.valueType = "integerValue";
                            }
                            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                                object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                                if (options.oneofs) object.valueType = "doubleValue";
                            }
                            if (message.referenceValue != null && message.hasOwnProperty("referenceValue")) {
                                object.referenceValue = message.referenceValue;
                                if (options.oneofs) object.valueType = "referenceValue";
                            }
                            if (message.mapValue != null && message.hasOwnProperty("mapValue")) {
                                object.mapValue = $root.google.events.cloud.firestore.v1.MapValue.toObject(message.mapValue, options);
                                if (options.oneofs) object.valueType = "mapValue";
                            }
                            if (message.geoPointValue != null && message.hasOwnProperty("geoPointValue")) {
                                object.geoPointValue = $root.google.type.LatLng.toObject(message.geoPointValue, options);
                                if (options.oneofs) object.valueType = "geoPointValue";
                            }
                            if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                                object.arrayValue = $root.google.events.cloud.firestore.v1.ArrayValue.toObject(message.arrayValue, options);
                                if (options.oneofs) object.valueType = "arrayValue";
                            }
                            if (message.timestampValue != null && message.hasOwnProperty("timestampValue")) {
                                object.timestampValue = $root.google.protobuf.Timestamp.toObject(message.timestampValue, options);
                                if (options.oneofs) object.valueType = "timestampValue";
                            }
                            if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                                object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === undefined ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                                if (options.oneofs) object.valueType = "nullValue";
                            }
                            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                                object.stringValue = message.stringValue;
                                if (options.oneofs) object.valueType = "stringValue";
                            }
                            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                                object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                                if (options.oneofs) object.valueType = "bytesValue";
                            }
                            return object;
                        };
                        /**
                         * Converts this Value to JSON.
                         * @function toJSON
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */ Value.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
                        /**
                         * Gets the default type url for Value
                         * @function getTypeUrl
                         * @memberof google.events.cloud.firestore.v1.Value
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */ Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/google.events.cloud.firestore.v1.Value";
                        };
                        return Value;
                    }();
                    v1.ArrayValue = function() {
                        /**
                         * Properties of an ArrayValue.
                         * @memberof google.events.cloud.firestore.v1
                         * @interface IArrayValue
                         * @property {Array.<google.events.cloud.firestore.v1.IValue>|null} [values] ArrayValue values
                         */ /**
                         * Constructs a new ArrayValue.
                         * @memberof google.events.cloud.firestore.v1
                         * @classdesc Represents an ArrayValue.
                         * @implements IArrayValue
                         * @constructor
                         * @param {google.events.cloud.firestore.v1.IArrayValue=} [properties] Properties to set
                         */ function ArrayValue(properties) {
                            this.values = [];
                            if (properties) {
                                for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                            }
                        }
                        /**
                         * ArrayValue values.
                         * @member {Array.<google.events.cloud.firestore.v1.IValue>} values
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @instance
                         */ ArrayValue.prototype.values = $util.emptyArray;
                        /**
                         * Creates a new ArrayValue instance using the specified properties.
                         * @function create
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.IArrayValue=} [properties] Properties to set
                         * @returns {google.events.cloud.firestore.v1.ArrayValue} ArrayValue instance
                         */ ArrayValue.create = function create(properties) {
                            return new ArrayValue(properties);
                        };
                        /**
                         * Encodes the specified ArrayValue message. Does not implicitly {@link google.events.cloud.firestore.v1.ArrayValue.verify|verify} messages.
                         * @function encode
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.IArrayValue} message ArrayValue message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ ArrayValue.encode = function encode(message, writer) {
                            if (!writer) writer = $Writer.create();
                            if (message.values != null && message.values.length) for(var i = 0; i < message.values.length; ++i)$root.google.events.cloud.firestore.v1.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
                            return writer;
                        };
                        /**
                         * Encodes the specified ArrayValue message, length delimited. Does not implicitly {@link google.events.cloud.firestore.v1.ArrayValue.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.IArrayValue} message ArrayValue message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
                        /**
                         * Decodes an ArrayValue message from the specified reader or buffer.
                         * @function decode
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {google.events.cloud.firestore.v1.ArrayValue} ArrayValue
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ ArrayValue.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.events.cloud.firestore.v1.ArrayValue();
                            while(reader.pos < end){
                                var tag = reader.uint32();
                                switch(tag >>> 3){
                                    case 1:
                                        {
                                            if (!(message.values && message.values.length)) message.values = [];
                                            message.values.push($root.google.events.cloud.firestore.v1.Value.decode(reader, reader.uint32()));
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                }
                            }
                            return message;
                        };
                        /**
                         * Decodes an ArrayValue message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {google.events.cloud.firestore.v1.ArrayValue} ArrayValue
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ ArrayValue.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
                        /**
                         * Verifies an ArrayValue message.
                         * @function verify
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */ ArrayValue.verify = function verify(message) {
                            if (typeof message !== "object" || message === null) return "object expected";
                            if (message.values != null && message.hasOwnProperty("values")) {
                                if (!Array.isArray(message.values)) return "values: array expected";
                                for(var i = 0; i < message.values.length; ++i){
                                    var error = $root.google.events.cloud.firestore.v1.Value.verify(message.values[i]);
                                    if (error) return "values." + error;
                                }
                            }
                            return null;
                        };
                        /**
                         * Creates an ArrayValue message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {google.events.cloud.firestore.v1.ArrayValue} ArrayValue
                         */ ArrayValue.fromObject = function fromObject(object) {
                            if (object instanceof $root.google.events.cloud.firestore.v1.ArrayValue) return object;
                            var message = new $root.google.events.cloud.firestore.v1.ArrayValue();
                            if (object.values) {
                                if (!Array.isArray(object.values)) throw TypeError(".google.events.cloud.firestore.v1.ArrayValue.values: array expected");
                                message.values = [];
                                for(var i = 0; i < object.values.length; ++i){
                                    if (typeof object.values[i] !== "object") throw TypeError(".google.events.cloud.firestore.v1.ArrayValue.values: object expected");
                                    message.values[i] = $root.google.events.cloud.firestore.v1.Value.fromObject(object.values[i]);
                                }
                            }
                            return message;
                        };
                        /**
                         * Creates a plain object from an ArrayValue message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.ArrayValue} message ArrayValue
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */ ArrayValue.toObject = function toObject(message, options) {
                            if (!options) options = {};
                            var object = {};
                            if (options.arrays || options.defaults) object.values = [];
                            if (message.values && message.values.length) {
                                object.values = [];
                                for(var j = 0; j < message.values.length; ++j)object.values[j] = $root.google.events.cloud.firestore.v1.Value.toObject(message.values[j], options);
                            }
                            return object;
                        };
                        /**
                         * Converts this ArrayValue to JSON.
                         * @function toJSON
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */ ArrayValue.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
                        /**
                         * Gets the default type url for ArrayValue
                         * @function getTypeUrl
                         * @memberof google.events.cloud.firestore.v1.ArrayValue
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */ ArrayValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/google.events.cloud.firestore.v1.ArrayValue";
                        };
                        return ArrayValue;
                    }();
                    v1.MapValue = function() {
                        /**
                         * Properties of a MapValue.
                         * @memberof google.events.cloud.firestore.v1
                         * @interface IMapValue
                         * @property {Object.<string,google.events.cloud.firestore.v1.IValue>|null} [fields] MapValue fields
                         */ /**
                         * Constructs a new MapValue.
                         * @memberof google.events.cloud.firestore.v1
                         * @classdesc Represents a MapValue.
                         * @implements IMapValue
                         * @constructor
                         * @param {google.events.cloud.firestore.v1.IMapValue=} [properties] Properties to set
                         */ function MapValue(properties) {
                            this.fields = {};
                            if (properties) {
                                for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                            }
                        }
                        /**
                         * MapValue fields.
                         * @member {Object.<string,google.events.cloud.firestore.v1.IValue>} fields
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @instance
                         */ MapValue.prototype.fields = $util.emptyObject;
                        /**
                         * Creates a new MapValue instance using the specified properties.
                         * @function create
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.IMapValue=} [properties] Properties to set
                         * @returns {google.events.cloud.firestore.v1.MapValue} MapValue instance
                         */ MapValue.create = function create(properties) {
                            return new MapValue(properties);
                        };
                        /**
                         * Encodes the specified MapValue message. Does not implicitly {@link google.events.cloud.firestore.v1.MapValue.verify|verify} messages.
                         * @function encode
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.IMapValue} message MapValue message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ MapValue.encode = function encode(message, writer) {
                            if (!writer) writer = $Writer.create();
                            if (message.fields != null && Object.hasOwnProperty.call(message, "fields")) for(var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i){
                                writer.uint32(/* id 1, wireType 2 =*/ 10).fork().uint32(/* id 1, wireType 2 =*/ 10).string(keys[i]);
                                $root.google.events.cloud.firestore.v1.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim().ldelim();
                            }
                            return writer;
                        };
                        /**
                         * Encodes the specified MapValue message, length delimited. Does not implicitly {@link google.events.cloud.firestore.v1.MapValue.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.IMapValue} message MapValue message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */ MapValue.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
                        /**
                         * Decodes a MapValue message from the specified reader or buffer.
                         * @function decode
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {google.events.cloud.firestore.v1.MapValue} MapValue
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ MapValue.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.events.cloud.firestore.v1.MapValue(), key, value;
                            while(reader.pos < end){
                                var tag = reader.uint32();
                                switch(tag >>> 3){
                                    case 1:
                                        {
                                            if (message.fields === $util.emptyObject) message.fields = {};
                                            var end2 = reader.uint32() + reader.pos;
                                            key = "";
                                            value = null;
                                            while(reader.pos < end2){
                                                var tag2 = reader.uint32();
                                                switch(tag2 >>> 3){
                                                    case 1:
                                                        key = reader.string();
                                                        break;
                                                    case 2:
                                                        value = $root.google.events.cloud.firestore.v1.Value.decode(reader, reader.uint32());
                                                        break;
                                                    default:
                                                        reader.skipType(tag2 & 7);
                                                        break;
                                                }
                                            }
                                            message.fields[key] = value;
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                }
                            }
                            return message;
                        };
                        /**
                         * Decodes a MapValue message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {google.events.cloud.firestore.v1.MapValue} MapValue
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */ MapValue.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
                        /**
                         * Verifies a MapValue message.
                         * @function verify
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */ MapValue.verify = function verify(message) {
                            if (typeof message !== "object" || message === null) return "object expected";
                            if (message.fields != null && message.hasOwnProperty("fields")) {
                                if (!$util.isObject(message.fields)) return "fields: object expected";
                                var key = Object.keys(message.fields);
                                for(var i = 0; i < key.length; ++i){
                                    var error = $root.google.events.cloud.firestore.v1.Value.verify(message.fields[key[i]]);
                                    if (error) return "fields." + error;
                                }
                            }
                            return null;
                        };
                        /**
                         * Creates a MapValue message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {google.events.cloud.firestore.v1.MapValue} MapValue
                         */ MapValue.fromObject = function fromObject(object) {
                            if (object instanceof $root.google.events.cloud.firestore.v1.MapValue) return object;
                            var message = new $root.google.events.cloud.firestore.v1.MapValue();
                            if (object.fields) {
                                if (typeof object.fields !== "object") throw TypeError(".google.events.cloud.firestore.v1.MapValue.fields: object expected");
                                message.fields = {};
                                for(var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i){
                                    if (typeof object.fields[keys[i]] !== "object") throw TypeError(".google.events.cloud.firestore.v1.MapValue.fields: object expected");
                                    message.fields[keys[i]] = $root.google.events.cloud.firestore.v1.Value.fromObject(object.fields[keys[i]]);
                                }
                            }
                            return message;
                        };
                        /**
                         * Creates a plain object from a MapValue message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {google.events.cloud.firestore.v1.MapValue} message MapValue
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */ MapValue.toObject = function toObject(message, options) {
                            if (!options) options = {};
                            var object = {};
                            if (options.objects || options.defaults) object.fields = {};
                            var keys2;
                            if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                                object.fields = {};
                                for(var j = 0; j < keys2.length; ++j)object.fields[keys2[j]] = $root.google.events.cloud.firestore.v1.Value.toObject(message.fields[keys2[j]], options);
                            }
                            return object;
                        };
                        /**
                         * Converts this MapValue to JSON.
                         * @function toJSON
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */ MapValue.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
                        /**
                         * Gets the default type url for MapValue
                         * @function getTypeUrl
                         * @memberof google.events.cloud.firestore.v1.MapValue
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */ MapValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/google.events.cloud.firestore.v1.MapValue";
                        };
                        return MapValue;
                    }();
                    return v1;
                }();
                return firestore;
            }();
            return cloud;
        }();
        return events;
    }();
    google.type = function() {
        /**
         * Namespace type.
         * @memberof google
         * @namespace
         */ var type = {};
        type.LatLng = function() {
            /**
             * Properties of a LatLng.
             * @memberof google.type
             * @interface ILatLng
             * @property {number|null} [latitude] LatLng latitude
             * @property {number|null} [longitude] LatLng longitude
             */ /**
             * Constructs a new LatLng.
             * @memberof google.type
             * @classdesc Represents a LatLng.
             * @implements ILatLng
             * @constructor
             * @param {google.type.ILatLng=} [properties] Properties to set
             */ function LatLng(properties) {
                if (properties) {
                    for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
            }
            /**
             * LatLng latitude.
             * @member {number} latitude
             * @memberof google.type.LatLng
             * @instance
             */ LatLng.prototype.latitude = 0;
            /**
             * LatLng longitude.
             * @member {number} longitude
             * @memberof google.type.LatLng
             * @instance
             */ LatLng.prototype.longitude = 0;
            /**
             * Creates a new LatLng instance using the specified properties.
             * @function create
             * @memberof google.type.LatLng
             * @static
             * @param {google.type.ILatLng=} [properties] Properties to set
             * @returns {google.type.LatLng} LatLng instance
             */ LatLng.create = function create(properties) {
                return new LatLng(properties);
            };
            /**
             * Encodes the specified LatLng message. Does not implicitly {@link google.type.LatLng.verify|verify} messages.
             * @function encode
             * @memberof google.type.LatLng
             * @static
             * @param {google.type.ILatLng} message LatLng message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ LatLng.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude")) writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.latitude);
                if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude")) writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.longitude);
                return writer;
            };
            /**
             * Encodes the specified LatLng message, length delimited. Does not implicitly {@link google.type.LatLng.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.type.LatLng
             * @static
             * @param {google.type.ILatLng} message LatLng message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */ LatLng.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LatLng message from the specified reader or buffer.
             * @function decode
             * @memberof google.type.LatLng
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.type.LatLng} LatLng
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ LatLng.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.type.LatLng();
                while(reader.pos < end){
                    var tag = reader.uint32();
                    switch(tag >>> 3){
                        case 1:
                            {
                                message.latitude = reader.double();
                                break;
                            }
                        case 2:
                            {
                                message.longitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Decodes a LatLng message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.type.LatLng
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.type.LatLng} LatLng
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */ LatLng.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LatLng message.
             * @function verify
             * @memberof google.type.LatLng
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */ LatLng.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.latitude != null && message.hasOwnProperty("latitude")) {
                    if (typeof message.latitude !== "number") return "latitude: number expected";
                }
                if (message.longitude != null && message.hasOwnProperty("longitude")) {
                    if (typeof message.longitude !== "number") return "longitude: number expected";
                }
                return null;
            };
            /**
             * Creates a LatLng message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.type.LatLng
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.type.LatLng} LatLng
             */ LatLng.fromObject = function fromObject(object) {
                if (object instanceof $root.google.type.LatLng) return object;
                var message = new $root.google.type.LatLng();
                if (object.latitude != null) message.latitude = Number(object.latitude);
                if (object.longitude != null) message.longitude = Number(object.longitude);
                return message;
            };
            /**
             * Creates a plain object from a LatLng message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.type.LatLng
             * @static
             * @param {google.type.LatLng} message LatLng
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */ LatLng.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};
                if (options.defaults) {
                    object.latitude = 0;
                    object.longitude = 0;
                }
                if (message.latitude != null && message.hasOwnProperty("latitude")) object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
                if (message.longitude != null && message.hasOwnProperty("longitude")) object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
                return object;
            };
            /**
             * Converts this LatLng to JSON.
             * @function toJSON
             * @memberof google.type.LatLng
             * @instance
             * @returns {Object.<string,*>} JSON object
             */ LatLng.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for LatLng
             * @function getTypeUrl
             * @memberof google.type.LatLng
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */ LatLng.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.type.LatLng";
            };
            return LatLng;
        }();
        return type;
    }();
    return google;
}();
module.exports = $root;
}}),
"[project]/node_modules/firebase-functions/lib/common/utilities/encoder.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dateToTimestampProto = void 0;
function dateToTimestampProto(timeString) {
    if (typeof timeString === "undefined") {
        return;
    }
    const date = new Date(timeString);
    const seconds = Math.floor(date.getTime() / 1000);
    let nanos = 0;
    if (timeString.length > 20) {
        const nanoString = timeString.substring(20, timeString.length - 1);
        const trailingZeroes = 9 - nanoString.length;
        nanos = parseInt(nanoString, 10) * Math.pow(10, trailingZeroes);
    }
    return {
        seconds,
        nanos
    };
}
exports.dateToTimestampProto = dateToTimestampProto;
}}),
"[project]/node_modules/firebase-functions/lib/common/providers/firestore.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2023 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createBeforeSnapshotFromJson = exports.createSnapshotFromJson = exports.createBeforeSnapshotFromProtobuf = exports.createSnapshotFromProtobuf = void 0;
const firestore = __turbopack_context__.r("[externals]/firebase-admin/firestore [external] (firebase-admin/firestore, cjs)");
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
const app_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/app.js [app-rsc] (ecmascript)");
const compiledFirestore_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/protos/compiledFirestore.js [app-rsc] (ecmascript)");
const encoder_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/utilities/encoder.js [app-rsc] (ecmascript)");
/** static-complied protobufs */ const DocumentEventData = compiledFirestore_1.google.events.cloud.firestore.v1.DocumentEventData;
let firestoreInstance;
/** @hidden */ function _getValueProto(data, resource, valueFieldName) {
    const value = data === null || data === void 0 ? void 0 : data[valueFieldName];
    if (typeof value === "undefined" || value === null || typeof value === "object" && !Object.keys(value).length) {
        // Firestore#snapshot_ takes resource string instead of proto for a non-existent snapshot
        return resource;
    }
    const proto = {
        fields: (value === null || value === void 0 ? void 0 : value.fields) || {},
        createTime: (0, encoder_1.dateToTimestampProto)(value === null || value === void 0 ? void 0 : value.createTime),
        updateTime: (0, encoder_1.dateToTimestampProto)(value === null || value === void 0 ? void 0 : value.updateTime),
        name: (value === null || value === void 0 ? void 0 : value.name) || resource
    };
    return proto;
}
/** @internal */ function createSnapshotFromProtobuf(data, path, databaseId) {
    if (!firestoreInstance) {
        firestoreInstance = firestore.getFirestore((0, app_1.getApp)(), databaseId);
    }
    try {
        const dataBuffer = Buffer.from(data);
        const firestoreDecoded = DocumentEventData.decode(dataBuffer);
        return firestoreInstance.snapshot_(firestoreDecoded.value || path, null, "protobufJS");
    } catch (err) {
        logger.error("Failed to decode protobuf and create a snapshot.");
        throw err;
    }
}
exports.createSnapshotFromProtobuf = createSnapshotFromProtobuf;
/** @internal */ function createBeforeSnapshotFromProtobuf(data, path, databaseId) {
    if (!firestoreInstance) {
        firestoreInstance = firestore.getFirestore((0, app_1.getApp)(), databaseId);
    }
    try {
        const dataBuffer = Buffer.from(data);
        const firestoreDecoded = DocumentEventData.decode(dataBuffer);
        return firestoreInstance.snapshot_(firestoreDecoded.oldValue || path, null, "protobufJS");
    } catch (err) {
        logger.error("Failed to decode protobuf and create a before snapshot.");
        throw err;
    }
}
exports.createBeforeSnapshotFromProtobuf = createBeforeSnapshotFromProtobuf;
/** @internal */ function createSnapshotFromJson(data, source, createTime, updateTime, databaseId) {
    if (!firestoreInstance) {
        firestoreInstance = databaseId ? firestore.getFirestore((0, app_1.getApp)(), databaseId) : firestore.getFirestore((0, app_1.getApp)());
    }
    const valueProto = _getValueProto(data, source, "value");
    let timeString = createTime || updateTime;
    if (!timeString) {
        logger.warn("Snapshot has no readTime. Using now()");
        timeString = new Date().toISOString();
    }
    const readTime = (0, encoder_1.dateToTimestampProto)(timeString);
    return firestoreInstance.snapshot_(valueProto, readTime, "json");
}
exports.createSnapshotFromJson = createSnapshotFromJson;
/** @internal */ function createBeforeSnapshotFromJson(data, source, createTime, updateTime, databaseId) {
    if (!firestoreInstance) {
        firestoreInstance = databaseId ? firestore.getFirestore((0, app_1.getApp)(), databaseId) : firestore.getFirestore((0, app_1.getApp)());
    }
    const oldValueProto = _getValueProto(data, source, "oldValue");
    const oldReadTime = (0, encoder_1.dateToTimestampProto)(createTime || updateTime);
    return firestoreInstance.snapshot_(oldValueProto, oldReadTime, "json");
}
exports.createBeforeSnapshotFromJson = createBeforeSnapshotFromJson;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/firestore.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DocumentBuilder = exports.beforeSnapshotConstructor = exports.snapshotConstructor = exports.NamespaceBuilder = exports.DatabaseBuilder = exports._documentWithOptions = exports._namespaceWithOptions = exports._databaseWithOptions = exports.database = exports.namespace = exports.document = exports.defaultDatabase = exports.service = exports.provider = void 0;
const path_1 = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const change_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/change.js [app-rsc] (ecmascript)");
const firestore_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/firestore.js [app-rsc] (ecmascript)");
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.firestore";
/** @internal */ exports.service = "firestore.googleapis.com";
/** @internal */ exports.defaultDatabase = "(default)";
/**
 * Select the Firestore document to listen to for events.
 * @param path Full database path to listen to. This includes the name of
 * the collection that the document is a part of. For example, if the
 * collection is named "users" and the document is named "Ada", then the
 * path is "/users/Ada".
 */ function document(path) {
    return _documentWithOptions(path, {});
}
exports.document = document;
// Multiple namespaces are not yet supported by Firestore.
function namespace(namespace) {
    return _namespaceWithOptions(namespace, {});
}
exports.namespace = namespace;
// Multiple databases are not yet supported by Firestore.
function database(database) {
    return _databaseWithOptions(database, {});
}
exports.database = database;
/** @internal */ function _databaseWithOptions(database = exports.defaultDatabase, options) {
    return new DatabaseBuilder(database, options);
}
exports._databaseWithOptions = _databaseWithOptions;
/** @internal */ function _namespaceWithOptions(namespace, options) {
    return _databaseWithOptions(exports.defaultDatabase, options).namespace(namespace);
}
exports._namespaceWithOptions = _namespaceWithOptions;
/** @internal */ function _documentWithOptions(path, options) {
    return _databaseWithOptions(exports.defaultDatabase, options).document(path);
}
exports._documentWithOptions = _documentWithOptions;
class DatabaseBuilder {
    constructor(database, options){
        this.database = database;
        this.options = options;
    }
    namespace(namespace) {
        return new NamespaceBuilder(this.database, this.options, namespace);
    }
    document(path) {
        return new NamespaceBuilder(this.database, this.options).document(path);
    }
}
exports.DatabaseBuilder = DatabaseBuilder;
class NamespaceBuilder {
    constructor(database, options, namespace){
        this.database = database;
        this.options = options;
        this.namespace = namespace;
    }
    document(path) {
        return new DocumentBuilder(()=>{
            if (!process.env.GCLOUD_PROJECT) {
                throw new Error("process.env.GCLOUD_PROJECT is not set.");
            }
            const database = path_1.posix.join("projects", process.env.GCLOUD_PROJECT, "databases", this.database);
            return path_1.posix.join(database, this.namespace ? `documents@${this.namespace}` : "documents", path);
        }, this.options);
    }
}
exports.NamespaceBuilder = NamespaceBuilder;
function snapshotConstructor(event) {
    var _a, _b, _c, _d;
    return (0, firestore_1.createSnapshotFromJson)(event.data, event.context.resource.name, (_b = (_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.readTime, (_d = (_c = event === null || event === void 0 ? void 0 : event.data) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.updateTime);
}
exports.snapshotConstructor = snapshotConstructor;
// TODO remove this function when wire format changes to new format
function beforeSnapshotConstructor(event) {
    var _a, _b;
    return (0, firestore_1.createBeforeSnapshotFromJson)(event.data, event.context.resource.name, (_b = (_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.oldValue) === null || _b === void 0 ? void 0 : _b.readTime, undefined);
}
exports.beforeSnapshotConstructor = beforeSnapshotConstructor;
function changeConstructor(raw) {
    return change_1.Change.fromObjects(beforeSnapshotConstructor(raw), snapshotConstructor(raw));
}
class DocumentBuilder {
    constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    // TODO what validation do we want to do here?
    }
    /** Respond to all document writes (creates, updates, or deletes). */ onWrite(handler) {
        return this.onOperation(handler, "document.write", changeConstructor);
    }
    /** Respond only to document updates. */ onUpdate(handler) {
        return this.onOperation(handler, "document.update", changeConstructor);
    }
    /** Respond only to document creations. */ onCreate(handler) {
        return this.onOperation(handler, "document.create", snapshotConstructor);
    }
    /** Respond only to document deletions. */ onDelete(handler) {
        return this.onOperation(handler, "document.delete", beforeSnapshotConstructor);
    }
    onOperation(handler, eventType, dataConstructor) {
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            eventType,
            service: exports.service,
            triggerResource: this.triggerResource,
            legacyEventType: `providers/cloud.firestore/eventTypes/${eventType}`,
            dataConstructor,
            options: this.options
        });
    }
}
exports.DocumentBuilder = DocumentBuilder;
}}),
"[project]/node_modules/firebase-functions/lib/v2/trace.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapTraceContext = void 0;
const trace_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/trace.js [app-rsc] (ecmascript)");
function wrapTraceContext(handler) {
    return (...args)=>{
        let traceParent;
        if (args.length === 1) {
            traceParent = (0, trace_1.extractTraceContext)(args[0]);
        } else {
            traceParent = (0, trace_1.extractTraceContext)(args[0].headers);
        }
        if (!traceParent) {
            // eslint-disable-next-line prefer-spread
            return handler.apply(null, args);
        }
        return trace_1.traceContext.run(traceParent, handler, ...args);
    };
}
exports.wrapTraceContext = wrapTraceContext;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/https.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._onCallWithOptions = exports._onRequestWithOptions = exports.onCall = exports.onRequest = exports.HttpsError = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/encoding.js [app-rsc] (ecmascript)");
const https_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/https.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HttpsError", {
    enumerable: true,
    get: function() {
        return https_1.HttpsError;
    }
});
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
const manifest_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/runtime/manifest.js [app-rsc] (ecmascript)");
const onInit_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/onInit.js [app-rsc] (ecmascript)");
const trace_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v2/trace.js [app-rsc] (ecmascript)");
/**
 * Handle HTTP requests.
 * @param handler A function that takes a request and response object,
 * same signature as an Express app.
 */ function onRequest(handler) {
    return _onRequestWithOptions(handler, {});
}
exports.onRequest = onRequest;
/**
 * Declares a callable method for clients to call using a Firebase SDK.
 * @param handler A method that takes a data and context and returns a value.
 */ function onCall(handler) {
    return _onCallWithOptions(handler, {});
}
exports.onCall = onCall;
/** @internal */ function _onRequestWithOptions(handler, options) {
    // lets us add __endpoint without altering handler:
    const cloudFunction = (req, res)=>{
        return (0, trace_1.wrapTraceContext)((0, onInit_1.withInit)(handler))(req, res);
    };
    cloudFunction.__trigger = {
        ...(0, cloud_functions_1.optionsToTrigger)(options),
        httpsTrigger: {}
    };
    (0, encoding_1.convertIfPresent)(cloudFunction.__trigger.httpsTrigger, options, "invoker", "invoker", encoding_1.convertInvoker);
    // TODO parse the options
    cloudFunction.__endpoint = {
        platform: "gcfv1",
        ...(0, manifest_1.initV1Endpoint)(options),
        ...(0, cloud_functions_1.optionsToEndpoint)(options),
        httpsTrigger: {}
    };
    (0, encoding_1.convertIfPresent)(cloudFunction.__endpoint.httpsTrigger, options, "invoker", "invoker", encoding_1.convertInvoker);
    return cloudFunction;
}
exports._onRequestWithOptions = _onRequestWithOptions;
/** @internal */ function _onCallWithOptions(handler, options) {
    // fix the length of handler to make the call to handler consistent
    // in the onCallHandler
    const fixedLen = (data, context)=>{
        return (0, onInit_1.withInit)(handler)(data, context);
    };
    const func = (0, trace_1.wrapTraceContext)((0, https_1.onCallHandler)({
        enforceAppCheck: options.enforceAppCheck,
        consumeAppCheckToken: options.consumeAppCheckToken,
        cors: {
            origin: true,
            methods: "POST"
        }
    }, fixedLen, "gcfv1"));
    func.__trigger = {
        labels: {},
        ...(0, cloud_functions_1.optionsToTrigger)(options),
        httpsTrigger: {}
    };
    func.__trigger.labels["deployment-callable"] = "true";
    func.__endpoint = {
        platform: "gcfv1",
        labels: {},
        ...(0, manifest_1.initV1Endpoint)(options),
        ...(0, cloud_functions_1.optionsToEndpoint)(options),
        callableTrigger: {}
    };
    func.run = fixedLen;
    return func;
}
exports._onCallWithOptions = _onCallWithOptions;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/pubsub.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Message = exports.ScheduleBuilder = exports._scheduleWithOptions = exports.schedule = exports.TopicBuilder = exports._topicWithOptions = exports.topic = exports.service = exports.provider = void 0;
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.pubsub";
/** @internal */ exports.service = "pubsub.googleapis.com";
/**
 * Registers a Cloud Function triggered when a Google Cloud Pub/Sub message
 * is sent to a specified topic.
 *
 * @param topic - The Pub/Sub topic to watch for message events.
 * @returns Pub/Sub topic builder interface.
 */ function topic(topic) {
    return _topicWithOptions(topic, {});
}
exports.topic = topic;
/** @internal */ function _topicWithOptions(topic, options) {
    if (topic.indexOf("/") !== -1) {
        throw new Error("Topic name may not have a /");
    }
    return new TopicBuilder(()=>{
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error("process.env.GCLOUD_PROJECT is not set.");
        }
        return `projects/${process.env.GCLOUD_PROJECT}/topics/${topic}`;
    }, options);
}
exports._topicWithOptions = _topicWithOptions;
/**
 * The Google Cloud Pub/Sub topic builder.
 *
 * Access via `functions.pubsub.topic()`.
 */ class TopicBuilder {
    /** @hidden */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    /**
     * Event handler that fires every time a Cloud Pub/Sub message is
     * published.
     *
     * @param handler - Event handler that runs every time a Cloud Pub/Sub message
     *   is published.
     * @returns A function that you can export and deploy.
     */ onPublish(handler) {
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            service: exports.service,
            triggerResource: this.triggerResource,
            eventType: "topic.publish",
            dataConstructor: (raw)=>new Message(raw.data),
            options: this.options
        });
    }
}
exports.TopicBuilder = TopicBuilder;
/**
 * Registers a Cloud Function to run at specified times.
 *
 * @param schedule - The schedule, in Unix Crontab or AppEngine syntax.
 * @returns ScheduleBuilder interface.
 */ function schedule(schedule) {
    return _scheduleWithOptions(schedule, {});
}
exports.schedule = schedule;
/** @internal */ function _scheduleWithOptions(schedule, options) {
    const triggerResource = ()=>{
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error("process.env.GCLOUD_PROJECT is not set.");
        }
        // The CLI will append the correct topic name based on region and function name
        return `projects/${process.env.GCLOUD_PROJECT}/topics`;
    };
    return new ScheduleBuilder(triggerResource, {
        ...options,
        schedule: {
            schedule
        }
    });
}
exports._scheduleWithOptions = _scheduleWithOptions;
/**
 * The builder for scheduled functions, which are powered by
 * Google Pub/Sub and Cloud Scheduler. Describes the Cloud Scheduler
 * job that is deployed to trigger a scheduled function at the provided
 * frequency. For more information, see
 * [Schedule functions](/docs/functions/schedule-functions).
 *
 * Access via `functions.pubsub.schedule()`.
 */ class ScheduleBuilder {
    /** @hidden */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    retryConfig(config) {
        this.options.schedule.retryConfig = config;
        return this;
    }
    timeZone(timeZone) {
        this.options.schedule.timeZone = timeZone;
        return this;
    }
    /**
     * Event handler for scheduled functions. Triggered whenever the associated
     * scheduler job sends a Pub/Sub message.
     *
     * @param handler - Handler that fires whenever the associated
     *   scheduler job sends a Pub/Sub message.
     * @returns A function that you can export and deploy.
     */ onRun(handler) {
        const cloudFunction = (0, cloud_functions_1.makeCloudFunction)({
            contextOnlyHandler: handler,
            provider: exports.provider,
            service: exports.service,
            triggerResource: this.triggerResource,
            eventType: "topic.publish",
            options: this.options,
            labels: {
                "deployment-scheduled": "true"
            }
        });
        return cloudFunction;
    }
}
exports.ScheduleBuilder = ScheduleBuilder;
/**
 * Interface representing a Google Cloud Pub/Sub message.
 *
 * @param data - Payload of a Pub/Sub message.
 */ class Message {
    constructor(data){
        [this.data, this.attributes, this._json] = [
            data.data,
            data.attributes || {},
            data.json
        ];
    }
    /**
     * The JSON data payload of this message object, if any.
     */ get json() {
        if (typeof this._json === "undefined") {
            this._json = JSON.parse(Buffer.from(this.data, "base64").toString("utf8"));
        }
        return this._json;
    }
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns A JSON-serializable representation of this object.
     */ toJSON() {
        return {
            data: this.data,
            attributes: this.attributes
        };
    }
}
exports.Message = Message;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/remoteConfig.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2018 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateBuilder = exports._onUpdateWithOptions = exports.onUpdate = exports.service = exports.provider = void 0;
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.firebase.remoteconfig";
/** @internal */ exports.service = "firebaseremoteconfig.googleapis.com";
/**
 * Registers a function that triggers on Firebase Remote Config template
 * update events.
 *
 * @param handler A function that takes the updated Remote Config
 *   template version metadata as an argument.
 *
 * @returns A function that you can export and deploy.
 */ function onUpdate(handler) {
    return _onUpdateWithOptions(handler, {});
}
exports.onUpdate = onUpdate;
/** @internal */ function _onUpdateWithOptions(handler, options) {
    const triggerResource = ()=>{
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error("process.env.GCLOUD_PROJECT is not set.");
        }
        return `projects/${process.env.GCLOUD_PROJECT}`;
    };
    return new UpdateBuilder(triggerResource, options).onUpdate(handler);
}
exports._onUpdateWithOptions = _onUpdateWithOptions;
/** Builder used to create Cloud Functions for Remote Config. */ class UpdateBuilder {
    /** @internal */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    /**
     * Handle all updates (including rollbacks) that affect a Remote Config
     * project.
     * @param handler A function that takes the updated Remote Config template
     * version metadata as an argument.
     */ onUpdate(handler) {
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            service: exports.service,
            triggerResource: this.triggerResource,
            eventType: "update",
            options: this.options
        });
    }
}
exports.UpdateBuilder = UpdateBuilder;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/storage.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ObjectBuilder = exports.BucketBuilder = exports._objectWithOptions = exports._bucketWithOptions = exports.object = exports.bucket = exports.service = exports.provider = void 0;
const config_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/config.js [app-rsc] (ecmascript)");
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.provider = "google.storage";
/** @internal */ exports.service = "storage.googleapis.com";
/**
 * Registers a Cloud Function scoped to a specific storage bucket.
 *
 * @param bucket Name of the bucket to which this Cloud Function is
 *   scoped.
 *
 * @returns Storage bucket builder interface.
 */ function bucket(bucket) {
    return _bucketWithOptions({}, bucket);
}
exports.bucket = bucket;
/**
 * Registers a Cloud Function scoped to the default storage bucket for the
 * project.
 *
 * @returns Storage object builder interface.
 */ function object() {
    return _objectWithOptions({});
}
exports.object = object;
/** @internal */ function _bucketWithOptions(options, bucket) {
    const resourceGetter = ()=>{
        bucket = bucket || (0, config_1.firebaseConfig)().storageBucket;
        if (!bucket) {
            throw new Error("Missing bucket name. If you are unit testing, please provide a bucket name" + " through `functions.storage.bucket(bucketName)`, or set process.env.FIREBASE_CONFIG.");
        }
        if (!/^[a-z\d][a-z\d\\._-]{1,230}[a-z\d]$/.test(bucket)) {
            throw new Error(`Invalid bucket name ${bucket}`);
        }
        return `projects/_/buckets/${bucket}`;
    };
    return new BucketBuilder(resourceGetter, options);
}
exports._bucketWithOptions = _bucketWithOptions;
/** @internal */ function _objectWithOptions(options) {
    return _bucketWithOptions(options).object();
}
exports._objectWithOptions = _objectWithOptions;
/**
 * The Google Cloud Storage bucket builder interface.
 *
 * Access via `functions.storage.bucket()`.
 */ class BucketBuilder {
    /** @internal */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    /**
     * Event handler which fires every time a Google Cloud Storage change occurs.
     *
     * @returns Storage object builder interface scoped to the specified storage
     *   bucket.
     */ object() {
        return new ObjectBuilder(this.triggerResource, this.options);
    }
}
exports.BucketBuilder = BucketBuilder;
/**
 * The Google Cloud Storage object builder interface.
 *
 * Access via `functions.storage.object()`.
 */ class ObjectBuilder {
    /** @internal */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    /**
     * Event handler sent only when a bucket has enabled object versioning.
     * This event indicates that the live version of an object has become an
     * archived version, either because it was archived or because it was
     * overwritten by the upload of an object of the same name.
     *
     * @param handler Event handler which is run every time a Google Cloud Storage
     *   archival occurs.
     *
     * @returns A function which you can export and deploy.
     */ onArchive(handler) {
        return this.onOperation(handler, "object.archive");
    }
    /**
     * Event handler which fires every time a Google Cloud Storage deletion occurs.
     *
     * Sent when an object has been permanently deleted. This includes objects
     * that are overwritten or are deleted as part of the bucket's lifecycle
     * configuration. For buckets with object versioning enabled, this is not
     * sent when an object is archived, even if archival occurs
     * via the `storage.objects.delete` method.
     *
     * @param handler Event handler which is run every time a Google Cloud Storage
     *   deletion occurs.
     *
     * @returns A function which you can export and deploy.
     */ onDelete(handler) {
        return this.onOperation(handler, "object.delete");
    }
    /**
     * Event handler which fires every time a Google Cloud Storage object
     * creation occurs.
     *
     * Sent when a new object (or a new generation of an existing object)
     * is successfully created in the bucket. This includes copying or rewriting
     * an existing object. A failed upload does not trigger this event.
     *
     * @param handler Event handler which is run every time a Google Cloud Storage
     *   object creation occurs.
     *
     * @returns A function which you can export and deploy.
     */ onFinalize(handler) {
        return this.onOperation(handler, "object.finalize");
    }
    /**
     * Event handler which fires every time the metadata of an existing object
     * changes.
     *
     * @param handler Event handler which is run every time a Google Cloud Storage
     *   metadata update occurs.
     *
     * @returns A function which you can export and deploy.
     */ onMetadataUpdate(handler) {
        return this.onOperation(handler, "object.metadataUpdate");
    }
    /** @hidden */ onOperation(handler, eventType) {
        return (0, cloud_functions_1.makeCloudFunction)({
            handler,
            provider: exports.provider,
            service: exports.service,
            eventType,
            triggerResource: this.triggerResource,
            options: this.options
        });
    }
}
exports.ObjectBuilder = ObjectBuilder;
}}),
"[project]/node_modules/firebase-functions/lib/common/providers/tasks.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2022 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onDispatchHandler = void 0;
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
const https = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/https.js [app-rsc] (ecmascript)");
/** @internal */ function onDispatchHandler(handler) {
    return async (req, res)=>{
        var _a;
        try {
            if (!https.isValidRequest(req)) {
                logger.error("Invalid request, unable to process.");
                throw new https.HttpsError("invalid-argument", "Bad Request");
            }
            const headers = {};
            for (const [key, value] of Object.entries(req.headers)){
                if (!Array.isArray(value)) {
                    headers[key] = value;
                }
            }
            const context = {
                queueName: req.header("X-CloudTasks-QueueName"),
                id: req.header("X-CloudTasks-TaskName"),
                retryCount: req.header("X-CloudTasks-TaskRetryCount") ? Number(req.header("X-CloudTasks-TaskRetryCount")) : undefined,
                executionCount: req.header("X-CloudTasks-TaskExecutionCount") ? Number(req.header("X-CloudTasks-TaskExecutionCount")) : undefined,
                scheduledTime: req.header("X-CloudTasks-TaskETA"),
                previousResponse: req.header("X-CloudTasks-TaskPreviousResponse") ? Number(req.header("X-CloudTasks-TaskPreviousResponse")) : undefined,
                retryReason: req.header("X-CloudTasks-TaskRetryReason"),
                headers
            };
            if (!process.env.FUNCTIONS_EMULATOR) {
                const authHeader = req.header("Authorization") || "";
                const token = (_a = authHeader.match(/^Bearer (.*)$/)) === null || _a === void 0 ? void 0 : _a[1];
                // Note: this should never happen since task queue functions are guarded by IAM.
                if (!token) {
                    throw new https.HttpsError("unauthenticated", "Unauthenticated");
                }
                // We skip authenticating the token since tq functions are guarded by IAM.
                const authToken = https.unsafeDecodeIdToken(token);
                context.auth = {
                    uid: authToken.uid,
                    token: authToken
                };
            }
            const data = https.decode(req.body.data);
            if (handler.length === 2) {
                await handler(data, context);
            } else {
                const arg = {
                    ...context,
                    data
                };
                // For some reason the type system isn't picking up that the handler
                // is a one argument function.
                await handler(arg);
            }
            res.status(204).end();
        } catch (err) {
            let httpErr = err;
            if (!(err instanceof https.HttpsError)) {
                // This doesn't count as an 'explicit' error.
                logger.error("Unhandled error", err);
                httpErr = new https.HttpsError("internal", "INTERNAL");
            }
            const { status } = httpErr.httpErrorCode;
            const body = {
                error: httpErr.toJSON()
            };
            res.status(status).send(body);
        }
    };
}
exports.onDispatchHandler = onDispatchHandler;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/tasks.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2022 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.taskQueue = exports.TaskQueueBuilder = void 0;
const encoding_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/encoding.js [app-rsc] (ecmascript)");
const tasks_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/providers/tasks.js [app-rsc] (ecmascript)");
const manifest_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/runtime/manifest.js [app-rsc] (ecmascript)");
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/**
 * Builder for creating a `TaskQueueFunction`.
 */ class TaskQueueBuilder {
    /** @internal */ constructor(tqOpts, depOpts){
        this.tqOpts = tqOpts;
        this.depOpts = depOpts;
    }
    /**
     * Creates a handler for tasks sent to a Google Cloud Tasks queue.
     * @param handler - A callback to handle task requests.
     * @returns A function you can export and deploy.
     */ onDispatch(handler) {
        var _a, _b;
        // onEnqueueHandler sniffs the function length of the passed-in callback
        // and the user could have only tried to listen to data. Wrap their handler
        // in another handler to avoid accidentally triggering the v2 API
        const fixedLen = (data, context)=>handler(data, context);
        const func = (0, tasks_1.onDispatchHandler)(fixedLen);
        func.__trigger = {
            ...(0, cloud_functions_1.optionsToTrigger)(this.depOpts || {}),
            taskQueueTrigger: {}
        };
        (0, encoding_1.copyIfPresent)(func.__trigger.taskQueueTrigger, this.tqOpts, "retryConfig");
        (0, encoding_1.copyIfPresent)(func.__trigger.taskQueueTrigger, this.tqOpts, "rateLimits");
        (0, encoding_1.convertIfPresent)(func.__trigger.taskQueueTrigger, this.tqOpts, "invoker", "invoker", encoding_1.convertInvoker);
        func.__endpoint = {
            platform: "gcfv1",
            ...(0, manifest_1.initV1Endpoint)(this.depOpts),
            ...(0, cloud_functions_1.optionsToEndpoint)(this.depOpts),
            taskQueueTrigger: (0, manifest_1.initTaskQueueTrigger)(this.depOpts)
        };
        (0, encoding_1.copyIfPresent)(func.__endpoint.taskQueueTrigger.retryConfig, ((_a = this.tqOpts) === null || _a === void 0 ? void 0 : _a.retryConfig) || {}, "maxAttempts", "maxBackoffSeconds", "maxDoublings", "maxRetrySeconds", "minBackoffSeconds");
        (0, encoding_1.copyIfPresent)(func.__endpoint.taskQueueTrigger.rateLimits, ((_b = this.tqOpts) === null || _b === void 0 ? void 0 : _b.rateLimits) || {}, "maxConcurrentDispatches", "maxDispatchesPerSecond");
        (0, encoding_1.convertIfPresent)(func.__endpoint.taskQueueTrigger, this.tqOpts, "invoker", "invoker", encoding_1.convertInvoker);
        func.__requiredAPIs = [
            {
                api: "cloudtasks.googleapis.com",
                reason: "Needed for task queue functions"
            }
        ];
        func.run = handler;
        return func;
    }
}
exports.TaskQueueBuilder = TaskQueueBuilder;
/**
 * Declares a function that can handle tasks enqueued using the Firebase Admin SDK.
 * @param options - Configuration for the Task Queue that feeds into this function.
 *        Omitting options will configure a Task Queue with default settings.
 */ function taskQueue(options) {
    return new TaskQueueBuilder(options);
}
exports.taskQueue = taskQueue;
}}),
"[project]/node_modules/firebase-functions/lib/v1/providers/testLab.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2019 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResultStorage = exports.ClientInfo = exports.TestMatrix = exports.TestMatrixBuilder = exports._testMatrixWithOpts = exports.testMatrix = exports.TEST_MATRIX_COMPLETE_EVENT_TYPE = exports.SERVICE = exports.PROVIDER = void 0;
const cloud_functions_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)");
/** @internal */ exports.PROVIDER = "google.testing";
/** @internal */ exports.SERVICE = "testing.googleapis.com";
/** @internal */ exports.TEST_MATRIX_COMPLETE_EVENT_TYPE = "testMatrix.complete";
/** Handle events related to Test Lab test matrices. */ function testMatrix() {
    return _testMatrixWithOpts({});
}
exports.testMatrix = testMatrix;
/** @internal */ function _testMatrixWithOpts(opts) {
    return new TestMatrixBuilder(()=>{
        if (!process.env.GCLOUD_PROJECT) {
            throw new Error("process.env.GCLOUD_PROJECT is not set.");
        }
        return "projects/" + process.env.GCLOUD_PROJECT + "/testMatrices/{matrix}";
    }, opts);
}
exports._testMatrixWithOpts = _testMatrixWithOpts;
/** Builder used to create Cloud Functions for Test Lab test matrices events. */ class TestMatrixBuilder {
    /** @internal */ constructor(triggerResource, options){
        this.triggerResource = triggerResource;
        this.options = options;
    }
    /** Handle a TestMatrix that reached a final test state. */ onComplete(handler) {
        const dataConstructor = (raw)=>{
            return new TestMatrix(raw.data);
        };
        return (0, cloud_functions_1.makeCloudFunction)({
            provider: exports.PROVIDER,
            eventType: exports.TEST_MATRIX_COMPLETE_EVENT_TYPE,
            triggerResource: this.triggerResource,
            service: exports.SERVICE,
            dataConstructor,
            handler,
            options: this.options
        });
    }
}
exports.TestMatrixBuilder = TestMatrixBuilder;
/** TestMatrix captures details about a test run. */ class TestMatrix {
    /** @internal */ constructor(data){
        this.testMatrixId = data.testMatrixId;
        this.createTime = data.timestamp;
        this.state = data.state;
        this.outcomeSummary = data.outcomeSummary;
        this.invalidMatrixDetails = data.invalidMatrixDetails;
        this.resultStorage = new ResultStorage(data.resultStorage);
        this.clientInfo = new ClientInfo(data.clientInfo);
    }
}
exports.TestMatrix = TestMatrix;
/** Information about the client which invoked the test. */ class ClientInfo {
    /** @internal */ constructor(data){
        this.name = (data === null || data === void 0 ? void 0 : data.name) || "";
        this.details = {};
        for (const detail of (data === null || data === void 0 ? void 0 : data.clientInfoDetails) || []){
            this.details[detail.key] = detail.value || "";
        }
    }
}
exports.ClientInfo = ClientInfo;
/** Locations where the test results are stored. */ class ResultStorage {
    /** @internal */ constructor(data){
        var _a, _b, _c;
        this.gcsPath = (_a = data === null || data === void 0 ? void 0 : data.googleCloudStorage) === null || _a === void 0 ? void 0 : _a.gcsPath;
        this.toolResultsHistoryId = (_b = data === null || data === void 0 ? void 0 : data.toolResultsHistory) === null || _b === void 0 ? void 0 : _b.historyId;
        this.toolResultsExecutionId = (_c = data === null || data === void 0 ? void 0 : data.toolResultsExecution) === null || _c === void 0 ? void 0 : _c.executionId;
        this.resultsUrl = data === null || data === void 0 ? void 0 : data.resultsUrl;
    }
}
exports.ResultStorage = ResultStorage;
}}),
"[project]/node_modules/firebase-functions/lib/v1/config.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.config = exports.resetCache = exports.singleton = exports.firebaseConfig = void 0;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var config_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/config.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "firebaseConfig", {
    enumerable: true,
    get: function() {
        return config_1.firebaseConfig;
    }
});
/** @internal */ function resetCache() {
    exports.singleton = undefined;
}
exports.resetCache = resetCache;
/**
 * Store and retrieve project configuration data such as third-party API
 * keys or other settings. You can set configuration values using the
 * Firebase CLI as described in
 * https://firebase.google.com/docs/functions/config-env.
 *
 * @deprecated Using functions.config() is discouraged. See https://firebase.google.com/docs/functions/config-env.
 */ function config() {
    // K_CONFIGURATION is only set in GCFv2
    if (process.env.K_CONFIGURATION) {
        throw new Error("functions.config() is no longer available in Cloud Functions for " + "Firebase v2. Please see the latest documentation for information " + "on how to transition to using environment variables");
    }
    if (typeof exports.singleton === "undefined") {
        init();
    }
    return exports.singleton;
}
exports.config = config;
function init() {
    try {
        const parsed = JSON.parse(process.env.CLOUD_RUNTIME_CONFIG);
        delete parsed.firebase;
        exports.singleton = parsed;
        return;
    } catch (e) {
    // Do nothing
    }
    try {
        const configPath = process.env.CLOUD_RUNTIME_CONFIG || path.join(process.cwd(), ".runtimeconfig.json");
        const contents = fs.readFileSync(configPath);
        const parsed = JSON.parse(contents.toString("utf8"));
        delete parsed.firebase;
        exports.singleton = parsed;
        return;
    } catch (e) {
    // Do nothing
    }
    exports.singleton = {};
}
}}),
"[project]/node_modules/firebase-functions/lib/v1/function-builder.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FunctionBuilder = exports.runWith = exports.region = void 0;
const options_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/options.js [app-rsc] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/types.js [app-rsc] (ecmascript)");
const function_configuration_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/function-configuration.js [app-rsc] (ecmascript)");
const analytics = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/analytics.js [app-rsc] (ecmascript)");
const auth = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/auth.js [app-rsc] (ecmascript)");
const database = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/database.js [app-rsc] (ecmascript)");
const firestore = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/firestore.js [app-rsc] (ecmascript)");
const https = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/https.js [app-rsc] (ecmascript)");
const pubsub = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/pubsub.js [app-rsc] (ecmascript)");
const remoteConfig = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/remoteConfig.js [app-rsc] (ecmascript)");
const storage = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/storage.js [app-rsc] (ecmascript)");
const tasks = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/tasks.js [app-rsc] (ecmascript)");
const testLab = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/testLab.js [app-rsc] (ecmascript)");
/**
 * Assert that the runtime options passed in are valid.
 * @param runtimeOptions object containing memory and timeout information.
 * @throws { Error } Memory and TimeoutSeconds values must be valid.
 */ function assertRuntimeOptionsValid(runtimeOptions) {
    const mem = runtimeOptions.memory;
    if (mem && typeof mem !== "object" && !function_configuration_1.VALID_MEMORY_OPTIONS.includes(mem)) {
        throw new Error(`The only valid memory allocation values are: ${function_configuration_1.VALID_MEMORY_OPTIONS.join(", ")}`);
    }
    if (typeof runtimeOptions.timeoutSeconds === "number" && (runtimeOptions.timeoutSeconds > function_configuration_1.MAX_TIMEOUT_SECONDS || runtimeOptions.timeoutSeconds < 0)) {
        throw new Error(`TimeoutSeconds must be between 0 and ${function_configuration_1.MAX_TIMEOUT_SECONDS}`);
    }
    if (runtimeOptions.ingressSettings && !(runtimeOptions.ingressSettings instanceof options_1.ResetValue) && !function_configuration_1.INGRESS_SETTINGS_OPTIONS.includes(runtimeOptions.ingressSettings)) {
        throw new Error(`The only valid ingressSettings values are: ${function_configuration_1.INGRESS_SETTINGS_OPTIONS.join(",")}`);
    }
    if (runtimeOptions.vpcConnectorEgressSettings && !(runtimeOptions.vpcConnectorEgressSettings instanceof options_1.ResetValue) && !function_configuration_1.VPC_EGRESS_SETTINGS_OPTIONS.includes(runtimeOptions.vpcConnectorEgressSettings)) {
        throw new Error(`The only valid vpcConnectorEgressSettings values are: ${function_configuration_1.VPC_EGRESS_SETTINGS_OPTIONS.join(",")}`);
    }
    validateFailurePolicy(runtimeOptions.failurePolicy);
    const serviceAccount = runtimeOptions.serviceAccount;
    if (serviceAccount && !(serviceAccount === "default" || serviceAccount instanceof options_1.ResetValue || serviceAccount instanceof types_1.Expression || serviceAccount.includes("@"))) {
        throw new Error(`serviceAccount must be set to 'default', a string expression, a service account email, or '{serviceAccountName}@'`);
    }
    if (runtimeOptions.labels) {
        // Labels must follow the rules listed in
        // https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements
        if (Object.keys(runtimeOptions.labels).length > function_configuration_1.MAX_NUMBER_USER_LABELS) {
            throw new Error(`A function must not have more than ${function_configuration_1.MAX_NUMBER_USER_LABELS} user-defined labels.`);
        }
        // We reserve the 'deployment' and 'firebase' namespaces for future feature development.
        const reservedKeys = Object.keys(runtimeOptions.labels).filter((key)=>key.startsWith("deployment") || key.startsWith("firebase"));
        if (reservedKeys.length) {
            throw new Error(`Invalid labels: ${reservedKeys.join(", ")}. Labels may not start with reserved names 'deployment' or 'firebase'`);
        }
        const invalidLengthKeys = Object.keys(runtimeOptions.labels).filter((key)=>key.length < 1 || key.length > 63);
        if (invalidLengthKeys.length > 0) {
            throw new Error(`Invalid labels: ${invalidLengthKeys.join(", ")}. Label keys must be between 1 and 63 characters in length.`);
        }
        const invalidLengthValues = Object.values(runtimeOptions.labels).filter((value)=>value.length > 63);
        if (invalidLengthValues.length > 0) {
            throw new Error(`Invalid labels: ${invalidLengthValues.join(", ")}. Label values must be less than 64 charcters.`);
        }
        // Keys can contain lowercase letters, foreign characters, numbers, _ or -. They must start with a letter.
        const validKeyPattern = /^[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}$/u;
        const invalidKeys = Object.keys(runtimeOptions.labels).filter((key)=>!validKeyPattern.test(key));
        if (invalidKeys.length > 0) {
            throw new Error(`Invalid labels: ${invalidKeys.join(", ")}. Label keys can only contain lowercase letters, international characters, numbers, _ or -, and must start with a letter.`);
        }
        // Values can contain lowercase letters, foreign characters, numbers, _ or -.
        const validValuePattern = /^[\p{Ll}\p{Lo}\p{N}_-]{0,63}$/u;
        const invalidValues = Object.values(runtimeOptions.labels).filter((value)=>!validValuePattern.test(value));
        if (invalidValues.length > 0) {
            throw new Error(`Invalid labels: ${invalidValues.join(", ")}. Label values can only contain lowercase letters, international characters, numbers, _ or -.`);
        }
    }
    if (typeof runtimeOptions.invoker === "string" && runtimeOptions.invoker.length === 0) {
        throw new Error("Invalid service account for function invoker, must be a non-empty string");
    }
    if (runtimeOptions.invoker !== undefined && Array.isArray(runtimeOptions.invoker)) {
        if (runtimeOptions.invoker.length === 0) {
            throw new Error("Invalid invoker array, must contain at least 1 service account entry");
        }
        for (const serviceAccount of runtimeOptions.invoker){
            if (serviceAccount.length === 0) {
                throw new Error("Invalid invoker array, a service account must be a non-empty string");
            }
            if (serviceAccount === "public") {
                throw new Error("Invalid invoker array, a service account cannot be set to the 'public' identifier");
            }
            if (serviceAccount === "private") {
                throw new Error("Invalid invoker array, a service account cannot be set to the 'private' identifier");
            }
        }
    }
    if (runtimeOptions.secrets !== undefined) {
        const invalidSecrets = runtimeOptions.secrets.filter((s)=>!/^[A-Za-z\d\-_]+$/.test(s instanceof types_1.SecretParam ? s.name : s));
        if (invalidSecrets.length > 0) {
            throw new Error(`Invalid secrets: ${invalidSecrets.join(",")}. ` + "Secret must be configured using the resource id (e.g. API_KEY)");
        }
    }
    if ("allowInvalidAppCheckToken" in runtimeOptions) {
        throw new Error('runWith option "allowInvalidAppCheckToken" has been inverted and ' + 'renamed "enforceAppCheck"');
    }
    return true;
}
function validateFailurePolicy(policy) {
    if (typeof policy === "boolean" || typeof policy === "undefined") {
        return;
    }
    if (typeof policy !== "object") {
        throw new Error(`failurePolicy must be a boolean or an object.`);
    }
    const retry = policy.retry;
    if (typeof retry !== "object" || Object.keys(retry).length) {
        throw new Error("failurePolicy.retry must be an empty object.");
    }
}
/**
 * Assert regions specified are valid.
 * @param regions list of regions.
 * @throws { Error } Regions must be in list of supported regions.
 */ function assertRegionsAreValid(regions) {
    if (!regions.length) {
        throw new Error("You must specify at least one region");
    }
    return true;
}
/**
 * Configure the regions that the function is deployed to.
 * @param regions One of more region strings.
 * @example
 * functions.region('us-east1')
 * @example
 * functions.region('us-east1', 'us-central1')
 */ function region(...regions) {
    if (assertRegionsAreValid(regions)) {
        return new FunctionBuilder({
            regions
        });
    }
}
exports.region = region;
/**
 * Configure runtime options for the function.
 * @param runtimeOptions Object with optional fields:
 * 1. `memory`: amount of memory to allocate to the function, possible values
 *    are: '128MB', '256MB', '512MB', '1GB', '2GB', '4GB', and '8GB'.
 * 2. `timeoutSeconds`: timeout for the function in seconds, possible values are
 *    0 to 540.
 * 3. `failurePolicy`: failure policy of the function, with boolean `true` being
 *    equivalent to providing an empty retry object.
 * 4. `vpcConnector`: id of a VPC connector in same project and region.
 * 5. `vpcConnectorEgressSettings`: when a vpcConnector is set, control which
 *    egress traffic is sent through the vpcConnector.
 * 6. `serviceAccount`: Specific service account for the function.
 * 7. `ingressSettings`: ingress settings for the function, which control where a HTTPS
 *    function can be called from.
 *
 * Value must not be null.
 */ function runWith(runtimeOptions) {
    if (assertRuntimeOptionsValid(runtimeOptions)) {
        return new FunctionBuilder(runtimeOptions);
    }
}
exports.runWith = runWith;
class FunctionBuilder {
    constructor(options){
        this.options = options;
    }
    /**
     * Configure the regions that the function is deployed to.
     * @param regions One or more region strings.
     * @example
     * functions.region('us-east1')
     * @example
     * functions.region('us-east1', 'us-central1')
     */ region(...regions) {
        if (assertRegionsAreValid(regions)) {
            this.options.regions = regions;
            return this;
        }
    }
    /**
     * Configure runtime options for the function.
     * @param runtimeOptions Object with optional fields:
     * 1. `memory`: amount of memory to allocate to the function, possible values
     *    are: '128MB', '256MB', '512MB', '1GB', '2GB', '4GB', and '8GB'.
     * 2. `timeoutSeconds`: timeout for the function in seconds, possible values are
     *    0 to 540.
     * 3. `failurePolicy`: failure policy of the function, with boolean `true` being
     *    equivalent to providing an empty retry object.
     * 4. `vpcConnector`: id of a VPC connector in the same project and region
     * 5. `vpcConnectorEgressSettings`: when a `vpcConnector` is set, control which
     *    egress traffic is sent through the `vpcConnector`.
     *
     * Value must not be null.
     */ runWith(runtimeOptions) {
        if (assertRuntimeOptionsValid(runtimeOptions)) {
            this.options = {
                ...this.options,
                ...runtimeOptions
            };
            return this;
        }
    }
    get https() {
        if (this.options.failurePolicy !== undefined) {
            console.warn("RuntimeOptions.failurePolicy is not supported in https functions.");
        }
        return {
            /**
             * Handle HTTP requests.
             * @param handler A function that takes a request and response object,
             * same signature as an Express app.
             */ onRequest: (handler)=>https._onRequestWithOptions(handler, this.options),
            /**
             * Declares a callable method for clients to call using a Firebase SDK.
             * @param handler A method that takes a data and context and returns a value.
             */ onCall: (handler)=>https._onCallWithOptions(handler, this.options)
        };
    }
    get tasks() {
        return {
            /**
             * Declares a task queue function for clients to call using a Firebase Admin SDK.
             * @param options Configurations for the task queue function.
             */ /** @hidden */ taskQueue: (options)=>{
                return new tasks.TaskQueueBuilder(options, this.options);
            }
        };
    }
    get database() {
        return {
            /**
             * Selects a database instance that will trigger the function. If omitted,
             * will pick the default database for your project.
             * @param instance The Realtime Database instance to use.
             */ instance: (instance)=>database._instanceWithOptions(instance, this.options),
            /**
             * Select Firebase Realtime Database Reference to listen to.
             *
             * This method behaves very similarly to the method of the same name in
             * the client and Admin Firebase SDKs. Any change to the Database that
             * affects the data at or below the provided `path` will fire an event in
             * Cloud Functions.
             *
             * There are three important differences between listening to a Realtime
             * Database event in Cloud Functions and using the Realtime Database in
             * the client and Admin SDKs:
             * 1. Cloud Functions allows wildcards in the `path` name. Any `path`
             *    component in curly brackets (`{}`) is a wildcard that matches all
             *    strings. The value that matched a certain invocation of a Cloud
             *    Function is returned as part of the `context.params` object. For
             *    example, `ref("messages/{messageId}")` matches changes at
             *    `/messages/message1` or `/messages/message2`, resulting in
             *    `context.params.messageId` being set to `"message1"` or
             *    `"message2"`, respectively.
             * 2. Cloud Functions do not fire an event for data that already existed
             *    before the Cloud Function was deployed.
             * 3. Cloud Function events have access to more information, including
             *    information about the user who triggered the Cloud Function.
             * @param ref Path of the database to listen to.
             */ ref: (path)=>database._refWithOptions(path, this.options)
        };
    }
    get firestore() {
        return {
            /**
             * Select the Firestore document to listen to for events.
             * @param path Full database path to listen to. This includes the name of
             * the collection that the document is a part of. For example, if the
             * collection is named "users" and the document is named "Ada", then the
             * path is "/users/Ada".
             */ document: (path)=>firestore._documentWithOptions(path, this.options),
            /** @hidden */ namespace: (namespace)=>firestore._namespaceWithOptions(namespace, this.options),
            /** @hidden */ database: (database)=>firestore._databaseWithOptions(database, this.options)
        };
    }
    get analytics() {
        return {
            /**
             * Select analytics events to listen to for events.
             * @param analyticsEventType Name of the analytics event type.
             */ event: (analyticsEventType)=>analytics._eventWithOptions(analyticsEventType, this.options)
        };
    }
    get remoteConfig() {
        return {
            /**
             * Handle all updates (including rollbacks) that affect a Remote Config
             * project.
             * @param handler A function that takes the updated Remote Config template
             * version metadata as an argument.
             */ onUpdate: (handler)=>remoteConfig._onUpdateWithOptions(handler, this.options)
        };
    }
    get storage() {
        return {
            /**
             * The optional bucket function allows you to choose which buckets' events
             * to handle. This step can be bypassed by calling object() directly,
             * which will use the default Cloud Storage for Firebase bucket.
             * @param bucket Name of the Google Cloud Storage bucket to listen to.
             */ bucket: (bucket)=>storage._bucketWithOptions(this.options, bucket),
            /**
             * Handle events related to Cloud Storage objects.
             */ object: ()=>storage._objectWithOptions(this.options)
        };
    }
    get pubsub() {
        return {
            /**
             * Select Cloud Pub/Sub topic to listen to.
             * @param topic Name of Pub/Sub topic, must belong to the same project as
             * the function.
             */ topic: (topic)=>pubsub._topicWithOptions(topic, this.options),
            schedule: (schedule)=>pubsub._scheduleWithOptions(schedule, this.options)
        };
    }
    get auth() {
        return {
            /**
             * Handle events related to Firebase authentication users.
             */ user: (userOptions)=>auth._userWithOptions(this.options, userOptions)
        };
    }
    get testLab() {
        return {
            /**
             * Handle events related to Test Lab test matrices.
             */ testMatrix: ()=>testLab._testMatrixWithOpts(this.options)
        };
    }
}
exports.FunctionBuilder = FunctionBuilder;
}}),
"[project]/node_modules/firebase-functions/lib/v1/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onInit = exports.params = exports.app = exports.logger = exports.testLab = exports.tasks = exports.storage = exports.remoteConfig = exports.pubsub = exports.https = exports.firestore = exports.database = exports.auth = exports.analytics = void 0;
// Providers:
const logger = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/logger/index.js [app-rsc] (ecmascript)");
exports.logger = logger;
const analytics = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/analytics.js [app-rsc] (ecmascript)");
exports.analytics = analytics;
const auth = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/auth.js [app-rsc] (ecmascript)");
exports.auth = auth;
const database = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/database.js [app-rsc] (ecmascript)");
exports.database = database;
const firestore = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/firestore.js [app-rsc] (ecmascript)");
exports.firestore = firestore;
const https = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/https.js [app-rsc] (ecmascript)");
exports.https = https;
const pubsub = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/pubsub.js [app-rsc] (ecmascript)");
exports.pubsub = pubsub;
const remoteConfig = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/remoteConfig.js [app-rsc] (ecmascript)");
exports.remoteConfig = remoteConfig;
const storage = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/storage.js [app-rsc] (ecmascript)");
exports.storage = storage;
const tasks = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/tasks.js [app-rsc] (ecmascript)");
exports.tasks = tasks;
const testLab = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/providers/testLab.js [app-rsc] (ecmascript)");
exports.testLab = testLab;
const app_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/app.js [app-rsc] (ecmascript)");
exports.app = {
    setEmulatedAdminApp: app_1.setApp
};
// Exported root types:
__exportStar(__turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/cloud-functions.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/config.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/function-builder.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/firebase-functions/lib/v1/function-configuration.js [app-rsc] (ecmascript)"), exports);
// NOTE: Equivalent to `export * as params from "../params"` but api-extractor doesn't support that syntax.
const params = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/params/index.js [app-rsc] (ecmascript)");
exports.params = params;
var onInit_1 = __turbopack_context__.r("[project]/node_modules/firebase-functions/lib/common/onInit.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "onInit", {
    enumerable: true,
    get: function() {
        return onInit_1.onInit;
    }
});
}}),

};

//# sourceMappingURL=node_modules_firebase-functions_b7e8d5af._.js.map